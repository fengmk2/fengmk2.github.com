<!DOCTYPE html><html><head><title>Coverage</title><script>

headings = [];

onload = function(){
  headings = document.querySelectorAll('h2');
};

onscroll = function(e){
  var heading = find(window.scrollY);
  if (!heading) return;
  var links = document.querySelectorAll('#menu a')
    , link;

  for (var i = 0, len = links.length; i < len; ++i) {
    link = links[i];
    link.className = link.getAttribute('href') == '#' + heading.id
      ? 'active'
      : '';
  }
};

function find(y) {
  var i = headings.length
    , heading;

  while (i--) {
    heading = headings[i];
    if (y >= heading.offsetTop) {
      return heading;
    }
  }
}
</script>
<style>

body {
  font: 14px/1.6 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 0;
  color: #2C2C2C;
  border-top: 2px solid #ddd;
}

#coverage {
  padding: 60px;
}

h1 a {
  color: inherit;
  font-weight: inherit;
}

h1 a:hover {
  text-decoration: none;
}

.onload h1 {
  opacity: 1;
}

h2 {
  width: 80%;
  margin-top: 80px;
  margin-bottom: 0;
  font-weight: 100;
  letter-spacing: 1px;
  border-bottom: 1px solid #eee;
}

a {
  color: #8A6343;
  font-weight: bold;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

ul {
  margin-top: 20px;
  padding: 0 15px;
  width: 100%;
}

ul li {
  float: left;
  width: 40%;
  margin-top: 5px;
  margin-right: 60px;
  list-style: none;
  border-bottom: 1px solid #eee;
  padding: 5px 0;
  font-size: 12px;
}

ul::after {
  content: '.';
  height: 0;
  display: block;
  visibility: hidden;
  clear: both;
}

code {
  font: 12px monaco, monospace;
}

pre {
  margin: 30px;
  padding: 30px;
  border: 1px solid #eee;
  border-bottom-color: #ddd;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-box-shadow: inset 0 0 10px #eee;
  -moz-box-shadow: inset 0 0 10px #eee;
  overflow-x: auto;
}

img {
  margin: 30px;
  padding: 1px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  -webkit-box-shadow: 0 3px 10px #dedede, 0 1px 5px #888;
  -moz-box-shadow: 0 3px 10px #dedede, 0 1px 5px #888;
  max-width: 100%;
}

footer {
  background: #eee;
  width: 100%;
  padding: 50px 0;
  text-align: right;
  border-top: 1px solid #ddd;
}

footer span {
  display: block;
  margin-right: 30px;
  color: #888;
  font-size: 12px;
}

#menu {
  position: fixed;
  font-size: 12px;
  overflow-y: auto;
  top: 0;
  right: 0;
  margin: 0;
  height: 100%;
  padding: 15px 0;
  text-align: right;
  border-left: 1px solid #eee;
  -moz-box-shadow: 0 0 2px #888
     , inset 5px 0 20px rgba(0,0,0,.5)
     , inset 5px 0 3px rgba(0,0,0,.3);
  -webkit-box-shadow: 0 0 2px #888
     , inset 5px 0 20px rgba(0,0,0,.5)
     , inset 5px 0 3px rgba(0,0,0,.3);
  -webkit-font-smoothing: antialiased;
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAABmCAMAAAAOARRQAAABelBMVEUjJSU6OzshIyM5OjoqKy02NjgsLS01NTYjJCUzNTUgISMlJSc0NTUvMDA6PDwlJyg1NjYoKis2NjYrLS02ODkpKyw0NDYrLC04ODovLzA4Ojo0NDUtLy86OjwjIyU4OTosLS82ODgtLS8hIyQvMTEnKCooKSsrKy0qLCwkJSUnKCkrLCwpKiwwMjIxMzMqLC0tLS0pKissLC00NTYwMDIwMTQpKysoKSovMDEtLzA2OTkxMzUrKywvLy8qKyszNTY5OzsqKiw6OjswMDExNDUoKiozNDUvMDIyNDY1Njg2Njk5OTozMzU0NjY4ODkiIyUiIyQ4OTkuMDEmKCowMjQwMTErLS4qKywwMTMhIiMpKiopKy0tLjAkJScxNDQvLzExNDYyNDQmKCk5OTslJig5OjskJSYxMzQrLS8gISIwMTIoKCk1NTUlJSUnJygwMDA4ODgiIiMhISI8PDw6Ojo5OTkpKSojIyQ7OzsyMjIpKSssLCw6Ozw1NjlrfLakAAAg2UlEQVR42jR6i3ea6rYvPgANIAhVXh8WvkQlioUiFlFcBtAmoiRNdzxqu9p0J7vrdK29zuPeex77nnvO/35n1r1ndHRktI0jTOacv/l7lCBK5UqVpOha/YxmWK7BC4TQFKVXrbYsnimqxuuMVlOQ0XltWjUdCwRJ1M+tC1KudOs9q6+da2adUewG0SC0SwELfHtgDds93VEuydEbl3QMWeNoYkR7b/0x1ZRobGI3mLwzAhePqTAwhg6aogjNsGy7/jwQ4rkdqe7CWLxF8k9LfMVFyRS7VJqtkrW8Vt/bkR8FZJao16ipknbC3Yw2lM7laO6HBEOadEZ2tpf65c4v8e3u7FyU6qbiNNyCuzXZ6pawgnwgmrpTT/Q7w2EZmiIJ0dzWDI7mhQ80IfRnMu2kzA5r5r1pIFoia+/d93HRYp1GV8TbrkWoU/+jdI0Ff6yGwTjT1Hn8J+8m1rKpGiYPuNiHnMtNMIv+zpsk84MYTNW1/+DpwXLvckdOCMYowVNPREe0QlM8xRHXXFhcNDzupwsSmb5pH+0t0RP2Qk+QtI7F1Qm6JRC6ZPBtPq/dq/kH+jxtCljn9TIpW6rQIgmSVyj6lPICIw4N/taka41PFUInth0je9+jO6Kt1G4/a7V2LEgG02B0pHVuCZrgltSKMuIl5SyufUv9mYuQi+mFgzbBEtFo2g+Dh4sSTrLNu8JPh00sQydpb00tqXBvqRN7Q7kqzcnIxCGnvZt/WmJacoOEO6Dcn8Qre03pOCSQxbMOXUuDNx9SxuLz4W1I18gvjViQ67zV0rxdWL8Te/TQkuo8STS41DR48W7L6YP2uWIqiUV8rd6Gbf/rnegKZeG8TpAM6afhGze9JAOxbLjsnUXEbrZ9vLYd7MT32cPF5mKKxmjy7huaoD9n62GOxni3iIJwv0IzZAZjdZkUtolCNLVfYZNaquFjGszVVf+J0vrz4CawoKdHnOzb0NMH7CDBOybfYNJ4rfeMyFNjkFYVTzMFs87rnPGXLUOeNKRVc0LnU7/UIgelzsy3CMuth0YfvnY0wsD3vODUL3eJcKqHQpm8yM3XZQWJxO6Un9iYloyyLpOwN2obHy6W6gbpcb44XmyC+mg+itAcaprGcrwZCqMj/GmtKn0zPvpTz/Cv1dw21XwP3cRupg3H3MF/S71eTKj1YrdwKdc2Mw0fRmb2sFf8lW3aU6JbIZSEPqvXvjM7G/aApyXlXeqKfMq0g/Su3rUGJPSPrtGElgknrZM3xUXqsAP6zMCNVn5u8aJnSNpJv2uru7t2jfRziW2+GuhqfldUNbPk71olwo+46ePUo1U3WKk/e5YK07F/wGRgcpODmQnIlVeHCWBE4puBi2jq28UKpqiN1/4UOrGz59TNYrrQHtd+11sG40BGD+pXdelNqGOg4NXe8W4eacJV/NS9/2Umtym6WQqveqR9xdCMElpxnbkalM4Vf9uaEcWZaKdyibEIjWKxJZPN95niCL3GiaXyssIrHxoLkqkzLCXULN46/f2h3tQJgyip+Tk9EAjJ9aJshq7t8X45aowSKspMSvPf7r9R8yxNptIaHS5ozuEm6luPDApugyNP8OaqiQ4BjaequXA54SLC83eHIY2r+CZp4409Xqw8Aa2oI7XkCrQi+in0w5AqF/kLNrcUz+qkl/lAobY1jSnx5OJNhyXIz3qfNFlXc0TKaglNwdWkWYt9QQ1Kr6W8zue21iNrdJk+N5oCr2O9nEtWKC7IS5J/zdDEYrmnAYfg6agCy+qcgz7ZofeDc4PbUWSvkshWuAc7OjiUyLkj+RAtdlwXJcjxdpkTTHDhK8lBCi8+JtvDVL1W6elmOM++YS0LuSlaP1oUvAeiW3cFnvTr8EbTz1tsSMYdGeZe40sRWu5uAfj7q+ZoKv2FNQ0p5XY1lmlcigHZqTPpabufEVrNuNPi165w3uCVQJHyJqmSJ7ZHnguqwtCmwViIJijj04ba2JNYtB+yORf5gg1/9t9iw4vUpeqiunSAbf+IBdj/b+iG2qrHvuNP0Vd/+ThVZT/lrvHYjjgDbbyxaqgHNM2uhxa1GW3UedZYhMMwM4mQhltouK+IV4NdbIQNM+8Yv311RZk9kT4tiYR4LkyFcuPpdcjuhUuFqBAWRZa11lcZ3gEBlXywsNhrt+plISZP5DlsV9l4EgY6J3yZPTUcMrgaWAT3oI79eSbGEbcJpr6BD8kyDiVt+G0/hXosQN4NFXKlfWIfsIs0BHODVok1/IGnKFHJYIquh8Xo+2+bkQNTGgWmN/fZ0Y33LSj6lr1GyV7mWIKg7ZTRZPGuhF/zjRNcQ1UPtSYgnWQxSs0yrVhwNDcdGMNSNe2JT3WuzbAM3HykyAajS3Uphf6STKEqxLas9EnmnhA/lyj9Uj+JoY7SVgVmGLl46Rm2u98sbkap2lzAdKBG4r6LgulQOSSjQv1GWdQ0jtDUK/mAaqM1Uqjpu4k3Rvfvxv7YTxLSK+wN3E5jVIzmF23uZ7hiH/sVP49D7tvoKp4S8b1LuvRlivVB/algbhcFITYVXvDpLzpDfplR2uD5V4XJFxpjmIpLc9Y5sB2TpBRix7Bme6GZIq+06v3XzNeTcA4obQIKxrnT4C2JpOqD92dbmSX8MGazly5EsZVMvSU1f4RZwyu8iQXbVdeLlZrjuTT1jrY1uk5c7iZ7RsvhhluqAkq4JpVQAg7RJFtSu+xgJ8Pv6O1j5DkLxT8mkbfyRW5DrQmG7hiDIjCgBsADbjuof6YHLGeV6a5Q1Smx9joUXPpdaaDx97A/Wq00oJkdR7ZYuQRfS533JtxO1erduqWOYIt3wh0wpbLuCNIYkwxbswbikCUu2CDCS+Q+7rgVtfRcm+SOcdKPRlZ/rE7wNVUEE39KTS5uvUKN1PUnkloPkyzhyGQ8qkouEjJ3H/VXdqG6asSRiw3ecMlBvDDt8dDhBHXMwZ2Cajzjr7/76T+IavqPYvz6r7//E/3X3+N//h/0QozbjPgPiir69P/8X3/9F/yv8b/827/++98WItPu5/Hvwd8YPf5bp/2/lX/T/+Of/0MJ/lYTa+L/Ef+d9vN/3/2T6P/+jyTzu/evf6U7vxN7B6pJkRtAF6jUr8I+P8RsP/ptGhfqFk+pQ/DgAy6NJtRYJdXmp4gK7WLqLKJ+MaKhGjOojvL+SnIWrkpy0SLHDe4QuyNzaEA15mLMCcmE8Em+4HdOihW4/ZWuppJEmzeAwcDtv7MuLc9y2V5atvxXNe3S4DUMt5/Qy2LM9kSYKiVWBuKlfp4nxTntpuW03JbIlkiRvBXmT23g1I2OYe6IizUHPIq6zm6mbfsbteKmi/sg9J+ocQBMctGFO7iljo8TPN+z3jxw4do+ZwfqoR9dkNTKHyM305GpTkfhcHexVkPVGEbUOjuo9f0UMPHBFlGEx0SLvJvVRKTwW7PSew5oPme+E42+frJa9cGt2njS3dK5kIif2eYbhuSEQXEqMVfUjhGIuin0G0/W5ezJyJQy3SpMLai4M0JUWb5u1k9tny5bd1pPwYBpQuDCXZl62xg4CdVEAtflXHs6JKmP/pH6mOl796Lgopj0o8d5kKh00hxG3OSdEE/QBo9Hgr8JJqAeLDwJohG5j/DGh61Rc/+tf22/8kEnxHNCEjo0ElvvGfESZkqmz2BDcKV1H1buSkhkdg7p1IMGs2s17nYjpblrWuE2K9WEO/hcRp5e9oOF/QBmOaDtgil+oaU6szPrdwW65fOB0KUTsVUn7LFU7J8e6cxJIl9+FHw5MQMzuQJ+4oxMH3iW/5GK+hWuG0T+gTLs+fAjdtUd58TmIUq04EeyRCYCjkldow234aIgR5bqwrtZosZ+6YEqAmDqatJ9lWasz4IquKALPtd92hGI3Z2BdzzZue+REl1Om4DIWD+RrtUTOJLI+S0jHowXXdAxsGLSd40zYNuEUlOGhrwL6c7tcOtUOvpJCP7QBQS19H+GvZn05ewjlVLz+IGKoC9TyfQjLMBNmXCuqqtTdOSukZW48B0HqgSTCBrBnlFvF4CG2Su7yFzqmJFURK3UmTT3ru050r0ptUpMilYnBJWfl2Bv6kPlUuE1kxxpdzui9AubsR2N2boVSu81OulAwBqoSr1LZ0LLYOomyZHmjqnXlP72s8LnDouEJjtodBvdHaG1jMySYO7crWd90MpCRyCG14vb5IE7Arupw/y/RcCm/Tm3zK6zYj8PYNaGldiUfkB/LHWcmf2lVM+mwyU27a0qq2tscrQ/vzBjN26DnntIrOyGizzXK35yKQdYnUABkyN4saz3WD/viF+eCcsXnIajdWYJWaYHRstIis9CS+tqnFGmz2j5uzfr3Z4prqgK4XOT/PyftvjZqIm8lhkfxJ7Ol3CJF1piYBGAG8wtAk56Drw1YwmOpcz+NdfkSpSLplRXLXHL0Rquj6YW/gabqgK7Dgr6NwtH0B/AN7XrN+MVJ6AmXmUuqmQulrNNYPmH0RoDogydOKLo/QbfYNARSQQKISRCzRXU+q9WWJFL3LZW6u34CkeG97xC0NNGaJ0bvK6SnZS3zPskr5EtuCgjMWR5o2x5BqhKmDWJPRe7JMEOyRb5uUKlHaGVtq5ivSOaSliSXp9SQm2qk8MRJh10MAp9QQ2H5t59J8rjiwSZtoIfMGjlLPVNdYl/LBR0AO6WLGDmkLkIPRE45Y9MftdAK/yNu1Hn6tzOQTesgQ+8fSzB19wO91vCnO23vOWQdwJ63SJrYjdfKFW6W281PKs2k8iT9ai1cgJ4sa3xqdvmtxR8/+D1B8AKc2u+6JftryRhMWSQtoSBgIyyQGyxcnELuAasXN12oSriU4RMz1DD6RL0TSV+om7i1Yt+jEE/jnawM8cX/UhN4nkiv/w9eALrzNhXuQfOzFL0Fi6SjF7/4Qn8rLYBoa85cvgAnkCEBP+HPbEnquVXCZsMS/yzYw2Vru60P/+nJPYKkzZFjmbykzUoEqV836T5q3fP/L383dF82tx18/AZgZczMAgyeWYKmSZIqtHL+e+O4ZRcq9VI3g/qPeCoiK4pcgEqdbS0S/Be54sbVQOuJVPNBblIghzeasNu7h/g+Sz1IdhI5lCwq1nUb3Ji4OCIcqQZqtqJ5w7rXrg/DA9IgVmEGhDgGecEwnCTHffXcXs0V3OCEVzYDKS1vp/oX+ng+6XVU86UjA6FMO2RXOOOrqY1GgPvrAk9HV/BXtCu5RuwF8qgdGDLsBcui4E33ymdBip1X8uKyhIWT8qNRDsXz+gvO9UiEC0d8RG4Tf2x8H4slljgHtCBcxHLTWOYJm5H/fCPCzOgf9qgOUxTRZ0Pc6ha5yLuLVT9ntvIa6gacE99mCovdUumTQdRP4RPsS9129eEe2uSvvGh0bV4Y3QPPhPZMqhZWSMa5R0Hc1SGO4IVOQc0FrirlibTVfKRrYkD8kz3b+X65/QkUNaZdrdl3mCap0Hf3YcCw/LiouJYNbqz88UqeDYv93yO7vvXtgl4XCyAO4ODkY6W+83+LZU//p3/zXNGGrUKClCiOnL27iJZbNWDF02XXAOeFlB7IaADoMH1Yqr+UP9biyZDEa/iJt4MDeIz6GKTdLVBfWGVtRN4fdT2rgReX8UXwF2zOrradm4J0nyTgdPnai3RvzpZvCKDUqjOwD/QA6EDaMCLewX6QWYVnHY1sx1bd8ovYnPm1ZvPH+rE20lWjOCnZ66/xDt0QAl15FjfBcZp+i9OU0RNPQ0t3x2pSNWo8eiYudwsnuP1Hq6iH1LJCJynkYsfgJ0p3pF6SoQk2l+jqE8CPk+ziGJRSKjs+W5AO185umPdkYzlK4wl7TC9NxyyDP7ZoyYVoXiuS6SjnInlLWrwz1i8bGTKXX0AVQWkSfIlglW3zRJRJ8bg5VgE6ZEnqNu9B++0GNQvDQJvFize4ESNKBJP+8vA3LM4AX5SIBq08Mob+7QMTCZx4nwP/64+4BnlZC+8WtlP/CXw6t1PwMwkJ3jhP1FiXLhDF/3I6FGUzO2DSi9ABxKyyL9paZxSEz40ZCPQToDAJu1959k7QdbVxgB4icsu2s4zsTPJhcEDo+N1GX4zSk/wriRh8AqwL62972i9HJHd1ydaLXVzvKvOfGGw5RVcUVMiKXFH4APdkQU/dc5BX0YfKTNZYXCW9mb8bc8mufoQP6BbdQmT99ZjoYfr/go4TgQX9IDgztim7wyFeGMfbNaeqj8Dzs38pgcqwSv2hbqB3oSGKWKy+sesY7p57wAHldqE6NDudk/W7s/zjrK4rZFlFvaGxnSZdHbc1y47qDN6xkoK8O3bfr2j41dlJZ71rB4dlDqapPFa8N6xBrprUdtenUCHwxKNhw1uuTBh+9uU45k4REpQABN2bAO9DSLqoIL26gNroWgup5pUMxHUNSq4Gyz47vBPvilpo5f9OYI2ddAqTqmnxXERxQJ3UK8fHbVE9HagHi3+tqNRoNsArdmAxHA5LwtQo9ZAaNKUTljnokljo2x8scqVpEEIPc01fPCdHOCg0DeWBz8D5TVAAfx8aRH5X2ZYNI3ebKDZdeJ+oBDAxmRqJ30Eh2/DaeAy5diVNMpEDmXiPDsGTzBLXy8eVDdJoIafgx/gxMyQi454QrW56nCyeELgSuNNEmYkflF+t3CZQOVRWjKhIuCclmQSlAXT3+4JGG75B4t/5hQ+ldMP4LsAW6z3XmU6IJJwpnGVnsgUZhoY1fZlwTR8wSU7xRejf2uCx9Z5trVTRRJP9KnEb134dEieil6eCOGWgboI7xsqsqM99jfJLTePjygKlH2CVxxsse9QRzTBFjD/Kjqitr/CCTBt/SJ6nLxz7cKP9pFqBpp0lN5y+adKNsZjrPuroemZauH9aTTFD3EKHW8S55XBLFQAt1jgxTQCTwxmx/JyfsZDN1RroN3VaxpSenpIX7K+ZbL8VdlQDcI4Cbzg3QJLa9yVqNxUelu+EtxLVqeekaAvSJkO6sSVqbUajxqhKshNpvZqoeApF0k/0P0ikkwUcbdwc4A1ejN7Oo0O15kG7hTMoK3hZRBCX7YYeLW0wvcXx/18n/u37yLgzBYVBUvORGli+sfRcX/74uD6P4hq+7xu54TlWJLFzT63uwUDwuEDdOjJQqx7JV+ZjaEAPi7t0MMrR4Q8Rkf18uxD6RK0RKh0hL8YU+DeL97i4pa5ZSyAfXKwZRS/8gXcxdZXm62RBDj8U3sN8x95b5PpPs/mCBKYvpaA50pN5Ct/499AFTtwQ5vgeSh+NHrKIi4NVpwM/XzRaNfJD856lPE6M21zWPguFsH7jbLVyEDfRmt4VwrhCJ5VTYmcSPfGgO5clfN+vbaDZ7sakU5+2vZ2WCDY031NxJarVytfDDVtiafcTGO2rJ/taoL3zChN2qmjxofczTOYQPPVQPh0JVtYgdUQINcSiNEEy58UdYXX1MpWUCEBx7LbcGtAm8XWRQTVOaoV3ySri4RShhs/B/0m4jX6OAwXOvcA09bNSG4czEGv/Wey6V/jbTCNTW6awXdNTcA1GsPe1E9fZdGl7R0vyoVpIdJtfC6d32NNErrvq/R+d65VG+YOwRXppXxOCYyGNSf1K3x6VxAW/vtz4EC1SgCOSPdN62sLsoIzuDfg8GwZAbquVO8HIuFP/ToVoeUB7nnwMF35a1wK1tI6fkrqFKhQdeJpwyls0pIy8AZde3/6LUUbFaYJthyUJSU/kqDXTLQElnn0Jr4B2RVghNrmNmoEn7pXIeshPguXVsvwoTdmClq49JJU3LWhHyWTrJL9bRP6VKv3tZoA/th77p5Jw++OEENvyvWy/pNeExiDUVQaXIRGh8xySZTI36yueFaSXo1uJY0RnXYgEOoWWOJHeaVuX/bGNhHsh2yinznl/++NJcE9j6fBPRcBdq9hb8awNw8U7Bl6GM7x69EDOIIbX/npZ++amlHR9L/35mE/2Ss4gb0xCcY4VyTFLRE796vHysLAamqcyO+aFQyJIDBNslbH2/MrAvZiSEIedc/cqjmv4fbda2pXbv+F5a2szSsdkm9noiNURXt8edUhGUF6fSZWd1IJaXKFwD+49R6eCXD4Bkef7j9tRtNMVgW8BhRz/Qpy1TmeYk0doyjZoJSbePOReVHgkFsCFuQJ+Lgc4BxeAsK/cOiNDRmdNw0ctYhn/nQ498dYI5znzGLoJi1rav7Cn88rL3wLePVtDK5gl77Tki3gHEsIAQ2+IKgarj7Y8W1IQzV5V9N+0TjLqbg68WfKcOmBCOj3JkwJhVIkwDhc+JorXuZEPMEh0vvH3x7iqf+VAwXgd4diZiaJD1zHL9Snx6Wfg4IugreyhabQkcir+y5XgDtdx3Avs7lkeeCBwDvZoTUCXx5QrZkcEqWfYEiEYRs/EphmRALSNGR1Iclgdr5VFoELpzF4++f35w3/j0t5ucW3n2ch4PQCLuUXupsPRR7UA5FjSKrMtPcKAZJfagO4lGE7FH3YKMjorpK0ZxAv+i2JkJhtAMWWWFej4RhPR/cJ3DxwocCvXDi4SGZU4cu+K32XndiFWgopAl+0GApcwf1XvymJcFs39jExIBO4yUjU9MExBLQYc9H+W7+IgdESPRpciT+rKZPebVtaVq+1GYO/5xTAL3HASjNTGIgMvdjWbgc7JvdE1zIFpuC0U9ESiZyzBixzxWxj4Kwh8My34q+FK3KNLtmsA1qyrmKSNQOXCPUZd+ONelBTvFoUI/CYsqa/RhtKiyMf2CgSFqEPk59Y3uqnlZ8gFpswfSYyko23yVZYxzKGxGm49Zqxg1l8oz5Ra9XaRwHkuxepmgyhm0SoNy2KlbcEqK+9QqS9PNx9Ihm9U7gsR55SSJ1FBDNnkuWKxIZ0SDpXuOGwZdoUbOMDPHP4vBAgz2VlSEJAHZGJVbYIg7l/FO5KfIVvxC8pPPxMGcNMoevFDeStt2iqztE10n2TA4dgJH76YS9HDhKHD3iCx6ieFX84BAI3QQnngh76f5ruPQVbr5qZmck/5UjDc26lfrOvUBWy0Ogl8bCoOkMOns81TnC3cuUS9KW8+9A+fe3XYZOFUPG1u5epSSmDLw0s5s2F0W30ANeo+zJkJQz9SPZgzwYpEoktofhGVfmLOAB20boCbW1QWq/NpET/hnMecw/uSyAH4NJc3ECOU4nnkK1fj3S/i5dwb3R7k00AqQQUwt7Ie1qV0aY/VQX0J8hLPy7eBNXMHYZYDNxHZ2Qh6AuXJxq+AeRec/Q+JLhZV6hpXwQEzw7bf5v9uUf2vpq3qlhmy0IIGTkwYdCfSAFmqbdo+3XvDTDjFJde0mbeQLcn2n31xaAqJ0ixO/CLsT4I4G4DoncVTgRGNBtsCcjISWT+oeXZ4Iedw/8OsJI1aPnNKLX/60VvcZb94uasRxCkqlPQ11u1Sa2hHvB80WQENxVyzjns0/PiEByyil21Te6oisk3mNCEMrhouCFO3yEZTHHOCMy9eb/4Tmi8cVf3Lf7P53SY2hX3PSN033As3ETIMLHWumWEO9JXHA2y2SIBlIPpLGG2qvNsCIlIr+B1SWAqRKm2w6Blf7U+zCSBwJrfHG5i8J5Gax/cVonMlon7aHJX/gSvucIncRP93XCqkv7D8IFKFsLiBgHqUpXhE3pYjEcV1dk/JD9zFVCfEaQIVX8Jmfz7IIofcBKQ4OaG+C3xC2veX9CD+iAFXDNaGg9eTVxvkbJRJlW4Nk9Wk13kn696jWppRDe/8pDrYMO9ZyxZ98ReKSz9kWKLLyk2zCZgAniCkLJVX3n1M9DYbomyahWiv/KixRIV9hj/oFz87I+HLznbPTjpa+D+bZQnMuRsljTpv90vQUt/pK7jCFnA30B/jtroSF2/m/gpWn1aQs5WeA6ghzF8SdqWI20fghdSeDOCSCmLgTkfaGgGDmw7nHFkRzGtag57IHS2na06I+gzEphXo1w/Zx2BM/jKL2nZoFjHggtFQjYi8nSVRSXIE58RPbBObXk7uuIL9+rs/5Zo7suJInEUxgsiZZAWS25iBtpEiZeBgDtghEoAE0sjcayNq85M4tbu/LF5h51335PsGzQ09O875+vUS89lkWMyNOFoip2PuyWyMP/iU2XIZdfCCJNDjebDoBLQdpy7QQZC7s9c0wjHJervQNDu2jWzBW5MSAJMr7bP+Iv92BkS/GGgzjEn7MF1IRKFwwzbjbS4/slGOmhx9cZrFu7HSEefojNv3r0UaKfKOWzXsq1zEugbzlMDFsacRJJI/iJlK3vtkZ+PLZIVMFlKA32wbq2Kd5T0uCLZ1CPkAfCdzkz2EYscjDcZq2AWfziN2covN4kXE1lQXPPLTNM1xx3tbiepcO/t3SWm4w87qfh99SL0ZnY+LKFPLPeXVM2mIIoVWt+9Nk0I7nY4O79iGYqxZ8RVz289an6NVdJWnSKZvJQCAuHNiVaDxPAFoH392t9wot5t0/qmU95eEWNbU2udUW5sN9JVqcYlvAIfLeYC33oUzzxZgSktsv21mA7Uly1FA5VnoJFh6N244Wmv3YJGFv/TCPryaw+ZORlpZjQdq/2DYXr3EZskfed0G61P09ipTKmlTQ1067Rg5+PAk5FlQ9e0SWbGf2B/08kqymOTMVOznsALHHNFH4LFRKl2F/NOiYFl9khNHnSu9Ak5sq26Ynl/i2fdTle29Y1ugqmR5Yj4YT9pvslFyYCbw0mNFr5rVQm1LvkG27QMq9ph3t8fmn6r6SQ4oSbr5tz+J1kIawGzDxb6VYOvvWhobDTXfBeNv3b4aNm5XUinsCGqG2q/45m3+LoCOsddFceYhRx1Tsss9PLdPfJdErFMjYd3gddjiP0+XQjcRadZP6bwNLySvunFf20Czy6JqdEW2a96KxdYdOryBv1BjbuUq2yCHeh+6sk7fGmmPi50pe/1l5TyPe5oHW9oPnhPswLyf2TFDdCyYlhwBCstv5C1HwlW7xWoGT9XZt4qVj5WryLPLLD6h/5cMLEjWzgCeAIKNsLak92aBqBsHl4AJwl2N4jfvbSkBExGimv0nFvv09uDScQbjx+w4kPQjgjlW+g9ws9VEJvI2k8N6XxVu0uIwovgTFdunG24gBtaDi+y1YLQwZ8mwbip5fVlO3k0n0AEr/ETbtu8Vjkm+nNSiEb7X/3fMjBL5A8PdgG+/FnbexbFFExmEfetXAnisEKy5z44WVPpQZjSy/jzeGn4yDRsFGqhh87QPaDBWhlo37IFbe/C0xynS91d2tP/AJoJS0sVF6iwAAAAAElFTkSuQmCC");
}

#menu::after {
  display: block;
  content: '';
  padding-top: 80px;
}

#logo {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(255,255,255,.1);
  font-size: 11px;
  display: block;
  width: 20px;
  height: 20px;
  line-height: 20px;
  text-align: center;
  -webkit-border-radius: 20px;
  -moz-border-radius: 20px;
  -webkit-box-shadow: 0 0 3px rgba(0,0,0,.2);
  -moz-box-shadow: 0 0 3px rgba(0,0,0,.2);
  color: inherit;
}

#menu li a {
  display: block;
  color: white;
  padding: 0 35px 0 25px;
  -webkit-transition: background 300ms;
  -moz-transition: background 300ms;
}

#menu li {
  position: relative;
  list-style: none;
}

#menu a:hover,
#menu a.active {
  text-decoration: none;
  background: rgba(255,255,255,.1);
}

#menu li:hover .cov {
  opacity: 1;
}

#menu li .dirname {
  opacity: .60;
  padding-right: 2px;
}

#menu li .basename {
  opacity: 1;
}

#menu .cov {
  background: rgba(0,0,0,.4);
  position: absolute;
  top: 0;
  right: 8px;
  font-size: 9px;
  opacity: .6;
  text-align: left;
  width: 17px;
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  padding: 2px 3px;
  text-align: center;
}

#stats:nth-child(2n) {
  display: inline-block;
  margin-top: 15px;
  border: 1px solid #eee;
  padding: 10px;
  -webkit-box-shadow: inset 0 0 2px #eee;
  -moz-box-shadow: inset 0 0 2px #eee;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
}

#stats div {
  float: left;
  padding: 0 5px;
}

#stats::after {
  display: block;
  content: '';
  clear: both;
}

#stats .sloc::after {
  content: ' SLOC';
  color: #b6b6b6;
}

#stats .percentage::after {
  content: ' coverage';
  color: #b6b6b6;
}

#stats .hits,
#stats .misses {
  display: none;
}

.high {
  color: #00d4b4;
}
.medium {
  color: #e87d0d;
}
.low {
  color: #d4081a;
}
.terrible {
  color: #d4081a;
  font-weight: bold;
}

table {
  width: 80%;
  margin-top: 10px;
  border-collapse: collapse;
  border: 1px solid #cbcbcb;
  color: #363636;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
}

table thead {
  display: none;
}

table td.line,
table td.hits {
  width: 20px;
  background: #eaeaea;
  text-align: center;
  font-size: 11px;
  padding: 0 10px;
  color: #949494;
}

table td.hits {
  width: 10px;
  padding: 2px 5px;
  color: rgba(0,0,0,.2);
  background: #f0f0f0;
}

tr.miss td.line,
tr.miss td.hits {
  background: #e6c3c7;
}

tr.miss td {
  background: #f8d5d8;
}

td.source {
  padding-left: 15px;
  line-height: 15px;
  white-space: pre;
  font: 12px monaco, monospace;
}

code .comment { color: #ddd }
code .init { color: #2F6FAD }
code .string { color: #5890AD }
code .keyword { color: #8A6343 }
code .number { color: #2F6FAD }
</style></head><body><div id="coverage"><h1 id="overview">Coverage</h1><div id="menu"><li><a href="#overview">overview</a></li><li><span class="cov high">89</span><a href="#/Users/mk2/git/node-hbase-client/lib/client.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">client.js</span></a></li><li><span class="cov high">90</span><a href="#/Users/mk2/git/node-hbase-client/lib/connection.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">connection.js</span></a></li><li><span class="cov medium">70</span><a href="#/Users/mk2/git/node-hbase-client/lib/data_input_buffer.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">data_input_buffer.js</span></a></li><li><span class="cov high">96</span><a href="#/Users/mk2/git/node-hbase-client/lib/data_input_stream.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">data_input_stream.js</span></a></li><li><span class="cov high">92</span><a href="#/Users/mk2/git/node-hbase-client/lib/data_output_buffer.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">data_output_buffer.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/data_output_stream.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">data_output_stream.js</span></a></li><li><span class="cov high">87</span><a href="#/Users/mk2/git/node-hbase-client/lib/delete.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">delete.js</span></a></li><li><span class="cov high">85</span><a href="#/Users/mk2/git/node-hbase-client/lib/errors.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">errors.js</span></a></li><li><span class="cov high">86</span><a href="#/Users/mk2/git/node-hbase-client/lib/get.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">get.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/hconstants.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">hconstants.js</span></a></li><li><span class="cov medium">55</span><a href="#/Users/mk2/git/node-hbase-client/lib/hregion_info.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">hregion_info.js</span></a></li><li><span class="cov high">94</span><a href="#/Users/mk2/git/node-hbase-client/lib/hregion_location.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">hregion_location.js</span></a></li><li><span class="cov high">91</span><a href="#/Users/mk2/git/node-hbase-client/lib/io/hbase_object_writable.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/io/</span><span class="basename">hbase_object_writable.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/io/version_writable.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/io/</span><span class="basename">version_writable.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/ipc/invocation.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/ipc/</span><span class="basename">invocation.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/ipc/response_flag.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/ipc/</span><span class="basename">response_flag.js</span></a></li><li><span class="cov high">77</span><a href="#/Users/mk2/git/node-hbase-client/lib/keyvalue.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">keyvalue.js</span></a></li><li><span class="cov low">44</span><a href="#/Users/mk2/git/node-hbase-client/lib/operation_with_attributes.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">operation_with_attributes.js</span></a></li><li><span class="cov high">96</span><a href="#/Users/mk2/git/node-hbase-client/lib/put.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">put.js</span></a></li><li><span class="cov high">90</span><a href="#/Users/mk2/git/node-hbase-client/lib/result.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">result.js</span></a></li><li><span class="cov high">76</span><a href="#/Users/mk2/git/node-hbase-client/lib/scan.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">scan.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/scanner.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">scanner.js</span></a></li><li><span class="cov high">100</span><a href="#/Users/mk2/git/node-hbase-client/lib/text.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">text.js</span></a></li><li><span class="cov medium">73</span><a href="#/Users/mk2/git/node-hbase-client/lib/time_range.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">time_range.js</span></a></li><li><span class="cov high">89</span><a href="#/Users/mk2/git/node-hbase-client/lib/util/bytes.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/util/</span><span class="basename">bytes.js</span></a></li><li><span class="cov high">95</span><a href="#/Users/mk2/git/node-hbase-client/lib/writable_utils.js"><span class="dirname">/Users/mk2/git/node-hbase-client/lib/</span><span class="basename">writable_utils.js</span></a></li><a id="logo" href="http://visionmedia.github.com/mocha/">m</a></div><div id="stats" class="high"><div class="percentage">85%</div><div class="sloc">2153</div><div class="hits">1832</div><div class="misses">321</div></div><div id="files"><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/client.js">/Users/mk2/git/node-hbase-client/lib/client.js</h2><div id="stats" class="high"><div class="percentage">89%</div><div class="sloc">384</div><div class="hits">345</div><div class="misses">39</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/client.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var debug = require('debug')('hbase:client');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var EventEmitter = require('events').EventEmitter;</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var HRegionInfo = require('./hregion_info');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var HRegionLocation = require('./hregion_location');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var ZooKeeperWatcher = require('zookeeper-watcher');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var EventEmitter = require('events').EventEmitter;</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var DataOutputBuffer = require('./data_output_buffer');</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">var DataInputBuffer = require('./data_input_buffer');</td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">var Connection = require('./connection');</td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">var errors = require('./errors');</td></tr><tr class="hit"><td class="line">26</td><td class="hits">1</td><td class="source">var TableNotFoundException = errors.TableNotFoundException;</td></tr><tr class="hit"><td class="line">27</td><td class="hits">1</td><td class="source">var IOException = errors.IOException;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">1</td><td class="source">var Get = require('./get');</td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">var Put = require('./put');</td></tr><tr class="hit"><td class="line">30</td><td class="hits">1</td><td class="source">var Delete = require('./delete');</td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">var Scanner = require('./scanner');</td></tr><tr class="hit"><td class="line">32</td><td class="hits">1</td><td class="source">var Scan = require('./scan');</td></tr><tr class="hit"><td class="line">33</td><td class="hits">1</td><td class="source">var utility = require('utility');</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> * This character is used as separator between server hostname, port and</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> * startcode.</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">39</td><td class="hits">1</td><td class="source">var SERVERNAME_SEPARATOR = &quot;,&quot;;</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">41</td><td class="hits">1</td><td class="source">function Client(options) {</td></tr><tr class="hit"><td class="line">42</td><td class="hits">1</td><td class="source">  if (!(this instanceof Client)) {</td></tr><tr class="miss"><td class="line">43</td><td class="hits">0</td><td class="source">    return new Client(options);</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">45</td><td class="hits">1</td><td class="source">  EventEmitter.call(this);</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">47</td><td class="hits">1</td><td class="source">  this.in = null;</td></tr><tr class="hit"><td class="line">48</td><td class="hits">1</td><td class="source">  this.out = null;</td></tr><tr class="hit"><td class="line">49</td><td class="hits">1</td><td class="source">  this.socket = null;</td></tr><tr class="hit"><td class="line">50</td><td class="hits">1</td><td class="source">  this.zk = new ZooKeeperWatcher({</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">    hosts: options.zookeeperHosts,</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">    root: options.zookeeperRoot,</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">    logger: options.logger,</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  });</td></tr><tr class="hit"><td class="line">55</td><td class="hits">1</td><td class="source">  this.logger = options.logger;</td></tr><tr class="hit"><td class="line">56</td><td class="hits">1</td><td class="source">  this.zkStart = 'init';</td></tr><tr class="hit"><td class="line">57</td><td class="hits">1</td><td class="source">  this.numLocateRegionRetries = options.numLocateRegionRetries || 10;</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  // tablename: [region1, region2, ...],</td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">  this.cachedRegionLocations = {};</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  // {hostname:port: server, ...}</td></tr><tr class="hit"><td class="line">61</td><td class="hits">1</td><td class="source">  this.servers = {};</td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">  this.serversLength = 0;</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  // The presence of a server in the map implies it's likely that there is an</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  // entry in cachedRegionLocations that map to this server; but the absence</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  // of a server in this map guarentees that there is no entry in cache that</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  // maps to the absent server.</td></tr><tr class="hit"><td class="line">68</td><td class="hits">1</td><td class="source">  this.cachedServers = {};</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  // region cache prefetch is enabled by default. this set contains all</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  // tables whose region cache prefetch are disabled.</td></tr><tr class="hit"><td class="line">72</td><td class="hits">1</td><td class="source">  this.regionCachePrefetchDisabledTables = {};</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">74</td><td class="hits">1</td><td class="source">  this.prefetchRegionLimit = options.prefetchRegionLimit || HConstants.DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT;</td></tr><tr class="hit"><td class="line">75</td><td class="hits">1</td><td class="source">  this.numRetries = options.numRetries || HConstants.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER;</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">77</td><td class="hits">1</td><td class="source">  this.ensureZookeeperTrackers(utility.noop);</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">80</td><td class="hits">1</td><td class="source">util.inherits(Client, EventEmitter);</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">82</td><td class="hits">1</td><td class="source">Client.create = function (options) {</td></tr><tr class="hit"><td class="line">83</td><td class="hits">1</td><td class="source">  return new Client(options);</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">// The metadata attached to each piece of data has the</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">// format:</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">//   &lt;magic&gt; 1-byte constant</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">//   &lt;id length&gt; 4-byte big-endian integer (length of next field)</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">//   &lt;id&gt; identifier corresponding uniquely to this process</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">// It is prepended to the data supplied by the user.</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">// the magic number is to be backward compatible</td></tr><tr class="hit"><td class="line">95</td><td class="hits">1</td><td class="source">var MAGIC = 255;</td></tr><tr class="hit"><td class="line">96</td><td class="hits">1</td><td class="source">var MAGIC_SIZE = Bytes.SIZEOF_BYTE;</td></tr><tr class="hit"><td class="line">97</td><td class="hits">1</td><td class="source">var ID_LENGTH_OFFSET = MAGIC_SIZE;</td></tr><tr class="hit"><td class="line">98</td><td class="hits">1</td><td class="source">var ID_LENGTH_SIZE = Bytes.SIZEOF_INT;</td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">function removeMetaData(data) {</td></tr><tr class="hit"><td class="line">100</td><td class="hits">1</td><td class="source">  if (data === null || data.length === 0) {</td></tr><tr class="miss"><td class="line">101</td><td class="hits">0</td><td class="source">    return data;</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  // check the magic data; to be backward compatible</td></tr><tr class="hit"><td class="line">104</td><td class="hits">1</td><td class="source">  var magic = data[0];</td></tr><tr class="hit"><td class="line">105</td><td class="hits">1</td><td class="source">  if (magic !== MAGIC) {</td></tr><tr class="miss"><td class="line">106</td><td class="hits">0</td><td class="source">    return data;</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">109</td><td class="hits">1</td><td class="source">  var idLength = Bytes.toInt(data, ID_LENGTH_OFFSET);</td></tr><tr class="hit"><td class="line">110</td><td class="hits">1</td><td class="source">  var dataLength = data.length - MAGIC_SIZE - ID_LENGTH_SIZE - idLength;</td></tr><tr class="hit"><td class="line">111</td><td class="hits">1</td><td class="source">  var dataOffset = MAGIC_SIZE + ID_LENGTH_SIZE + idLength;</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">113</td><td class="hits">1</td><td class="source">  return data.slice(dataOffset, dataOffset + dataLength);</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">}</td></tr><tr class="hit"><td class="line">115</td><td class="hits">1</td><td class="source">Client.removeMetaData = removeMetaData;</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> * Extracts certain cells from a given row.</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> * @param get The object that specifies what data to fetch and from which row.</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> * @return The data coming from the specified row, if it exists.  If the row</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> * specified doesn't exist, the {@link Result} instance returned won't</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> * contain any {@link KeyValue}, as indicated by {@link Result#isEmpty()}.</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> * @throws IOException if a remote or network exception occurs.</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> * @since 0.20.0</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">126</td><td class="hits">1</td><td class="source">Client.prototype.get = function (tableName, get, callback) {</td></tr><tr class="hit"><td class="line">127</td><td class="hits">46</td><td class="source">  this._action('get', tableName, get, callback);</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">130</td><td class="hits">1</td><td class="source">Client.prototype.put = function (tableName, put, callback) {</td></tr><tr class="hit"><td class="line">131</td><td class="hits">14</td><td class="source">  this._action('put', tableName, put, callback);</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">134</td><td class="hits">1</td><td class="source">Client.prototype.delete = function (tableName, del, callback) {</td></tr><tr class="hit"><td class="line">135</td><td class="hits">6</td><td class="source">  this._action('delete', tableName, del, callback);</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">139</td><td class="hits">1</td><td class="source">Client.prototype.getScanner = function (tableName, scan, callback) {</td></tr><tr class="hit"><td class="line">140</td><td class="hits">12</td><td class="source">  this._action('openScanner', tableName, scan, function (err, scannerId, server) {</td></tr><tr class="hit"><td class="line">141</td><td class="hits">12</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">142</td><td class="hits">0</td><td class="source">      return callback(err);</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">144</td><td class="hits">12</td><td class="source">    var scanner = new Scanner(server, scannerId);</td></tr><tr class="hit"><td class="line">145</td><td class="hits">12</td><td class="source">    callback(null, scanner);</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">149</td><td class="hits">1</td><td class="source">var _CACHE_TABLES = {};</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">151</td><td class="hits">1</td><td class="source">Client.prototype._action = function (method, tableName, obj, callback) {</td></tr><tr class="hit"><td class="line">152</td><td class="hits">78</td><td class="source">  if (!Buffer.isBuffer(tableName)) {</td></tr><tr class="hit"><td class="line">153</td><td class="hits">66</td><td class="source">    tableName = _CACHE_TABLES[tableName] || new Buffer(tableName);</td></tr><tr class="hit"><td class="line">154</td><td class="hits">66</td><td class="source">    _CACHE_TABLES[tableName] = tableName;</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">156</td><td class="hits">78</td><td class="source">  var row = obj.getRow();</td></tr><tr class="hit"><td class="line">157</td><td class="hits">78</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">158</td><td class="hits">78</td><td class="source">  self.locateRegion(tableName, row, true, function (err, location) {</td></tr><tr class="hit"><td class="line">159</td><td class="hits">78</td><td class="source">    if (err || !location) {</td></tr><tr class="miss"><td class="line">160</td><td class="hits">0</td><td class="source">      return callback(err);</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">163</td><td class="hits">78</td><td class="source">    self.getRegionConnection(location.getHostname(), location.getPort(), function (err, server) {</td></tr><tr class="hit"><td class="line">164</td><td class="hits">78</td><td class="source">      if (err) {</td></tr><tr class="miss"><td class="line">165</td><td class="hits">0</td><td class="source">        return callback(err);</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">168</td><td class="hits">78</td><td class="source">      server[method](location.getRegionInfo().getRegionName(), obj, function (err, value) {</td></tr><tr class="hit"><td class="line">169</td><td class="hits">78</td><td class="source">        callback(err, value, server);</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">      });</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">176</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source"> * Get a row with columns.</td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source"> * @param {String|Buffer} tableName</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source"> * @param {String|Buffer} row</td></tr><tr><td class="line">181</td><td class="hits"></td><td class="source"> * @param {Array} columns, column name, format: 'family:qualifier'.</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source"> *   e.g.: `['cf1:name', 'cf2:age', 'cf1:title']`</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source"> * @param {Function(err, data)} callback</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">185</td><td class="hits">1</td><td class="source">Client.prototype.getRow = function (tableName, row, columns, callback) {</td></tr><tr class="hit"><td class="line">186</td><td class="hits">17</td><td class="source">  var get = new Get(row);</td></tr><tr class="hit"><td class="line">187</td><td class="hits">17</td><td class="source">  if (columns) {</td></tr><tr class="hit"><td class="line">188</td><td class="hits">17</td><td class="source">    for (var i = 0; i &lt; columns.length; i++) {</td></tr><tr class="hit"><td class="line">189</td><td class="hits">33</td><td class="source">      var col = columns[i].split(':');</td></tr><tr class="hit"><td class="line">190</td><td class="hits">33</td><td class="source">      get.addColumn(col[0], col[1]);</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">193</td><td class="hits">17</td><td class="source">  this.get(tableName, get, function (err, result) {</td></tr><tr class="hit"><td class="line">194</td><td class="hits">17</td><td class="source">    if (err || !result) {</td></tr><tr class="hit"><td class="line">195</td><td class="hits">1</td><td class="source">      return callback(err, result);</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">197</td><td class="hits">16</td><td class="source">    var r = null;</td></tr><tr class="hit"><td class="line">198</td><td class="hits">16</td><td class="source">    var kvs = result.raw();</td></tr><tr class="hit"><td class="line">199</td><td class="hits">16</td><td class="source">    if (kvs.length &gt; 0) {</td></tr><tr class="hit"><td class="line">200</td><td class="hits">8</td><td class="source">      r = {};</td></tr><tr class="hit"><td class="line">201</td><td class="hits">8</td><td class="source">      for (var i = 0; i &lt; kvs.length; i++) {</td></tr><tr class="hit"><td class="line">202</td><td class="hits">15</td><td class="source">        var kv = kvs[i];</td></tr><tr class="hit"><td class="line">203</td><td class="hits">15</td><td class="source">        r[kv.getFamily().toString() + ':' + kv.getQualifier().toString()] = kv.getValue();</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">206</td><td class="hits">16</td><td class="source">    callback(null, r);</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source"> * Put a row to table.</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source"> * @param {String|Buffer} tableName</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source"> * @param {String|Buffer} row</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source"> * @param {Object} data, e.g.: `{'f1:name': 'foo', 'f1:age': '18'}`</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source"> * @param {Function(err)} callback</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">218</td><td class="hits">1</td><td class="source">Client.prototype.putRow = function (tableName, row, data, callback) {</td></tr><tr class="hit"><td class="line">219</td><td class="hits">9</td><td class="source">  var put = new Put(row);</td></tr><tr class="hit"><td class="line">220</td><td class="hits">9</td><td class="source">  for (var k in data) {</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source">    // 'f:q'</td></tr><tr class="hit"><td class="line">222</td><td class="hits">18</td><td class="source">    var col = k.split(':');</td></tr><tr class="hit"><td class="line">223</td><td class="hits">18</td><td class="source">    put.add(col[0], col[1], data[k]);</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">225</td><td class="hits">9</td><td class="source">  this.put(tableName, put, callback);</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source"> * Delete a row from table.</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source"> * @param {String|Buffer} tableName</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source"> * @param {String|Buffer} row</td></tr><tr><td class="line">233</td><td class="hits"></td><td class="source"> * @param {Function(err)} callback</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">235</td><td class="hits">1</td><td class="source">Client.prototype.deleteRow = function (tableName, row, callback) {</td></tr><tr class="hit"><td class="line">236</td><td class="hits">4</td><td class="source">  var del = new Delete(row);</td></tr><tr class="hit"><td class="line">237</td><td class="hits">4</td><td class="source">  this.delete(tableName, del, callback);</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">240</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source"> * Find the location of the region of &lt;i&gt;tableName&lt;/i&gt; that &lt;i&gt;row&lt;/i&gt;</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source"> * lives in.</td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">244</td><td class="hits"></td><td class="source"> * @param {Buffer|String} tableName, name of the table &lt;i&gt;row&lt;/i&gt; is in</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source"> * @param {Buffer|String} row, row key you're trying to find the region of</td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source"> * @param {Boolean} useCache</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source"> * @param {Function(err, location)} callback</td></tr><tr><td class="line">248</td><td class="hits"></td><td class="source"> *  - {HRegionLocation} location, that describes where to find the region in question</td></tr><tr><td class="line">249</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">250</td><td class="hits">1</td><td class="source">Client.prototype.locateRegion = function (tableName, row, useCache, callback) {</td></tr><tr class="hit"><td class="line">251</td><td class="hits">201</td><td class="source">  if (typeof useCache === 'function') {</td></tr><tr class="hit"><td class="line">252</td><td class="hits">1</td><td class="source">    callback = useCache;</td></tr><tr class="hit"><td class="line">253</td><td class="hits">1</td><td class="source">    useCache = true;</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">255</td><td class="hits">201</td><td class="source">  if (!Buffer.isBuffer(tableName)) {</td></tr><tr class="miss"><td class="line">256</td><td class="hits">0</td><td class="source">    tableName = Bytes.toBytes(tableName);</td></tr><tr><td class="line">257</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">258</td><td class="hits">201</td><td class="source">  if (row === null) {</td></tr><tr class="hit"><td class="line">259</td><td class="hits">2</td><td class="source">    row = new Buffer(0);</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">261</td><td class="hits">201</td><td class="source">  if (!Buffer.isBuffer(row)) {</td></tr><tr class="miss"><td class="line">262</td><td class="hits">0</td><td class="source">    row = Bytes.toBytes(row);</td></tr><tr><td class="line">263</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">264</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">265</td><td class="hits">201</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">266</td><td class="hits">201</td><td class="source">  self.ensureZookeeperTrackers(function (err) {</td></tr><tr><td class="line">267</td><td class="hits"></td><td class="source">    // TODO: handle err</td></tr><tr class="hit"><td class="line">268</td><td class="hits">201</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">269</td><td class="hits">0</td><td class="source">      return callback(err);</td></tr><tr><td class="line">270</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">271</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">272</td><td class="hits">201</td><td class="source">    if (Bytes.equals(tableName, HConstants.ROOT_TABLE_NAME)) {</td></tr><tr class="hit"><td class="line">273</td><td class="hits">40</td><td class="source">      var servername = self.rootServerName;</td></tr><tr><td class="line">274</td><td class="hits"></td><td class="source">      // debug('Got Root Server: %j', servername);</td></tr><tr class="hit"><td class="line">275</td><td class="hits">40</td><td class="source">      callback(null, new HRegionLocation(HRegionInfo.ROOT_REGIONINFO, servername.hostname, servername.port));</td></tr><tr class="hit"><td class="line">276</td><td class="hits">161</td><td class="source">    } else if (Bytes.equals(tableName, HConstants.META_TABLE_NAME)) {</td></tr><tr class="hit"><td class="line">277</td><td class="hits">27</td><td class="source">      self.locateRegionInMeta(HConstants.ROOT_TABLE_NAME, tableName, row, useCache, callback);</td></tr><tr><td class="line">278</td><td class="hits"></td><td class="source">    } else {</td></tr><tr><td class="line">279</td><td class="hits"></td><td class="source">      // Region not in the cache - have to go to the meta RS</td></tr><tr class="hit"><td class="line">280</td><td class="hits">134</td><td class="source">      self.locateRegionInMeta(HConstants.META_TABLE_NAME, tableName, row, useCache, callback);</td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">282</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">284</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">285</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source"> * Find the location of the region of &lt;i&gt;tableName&lt;/i&gt; that &lt;i&gt;row&lt;/i&gt;</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source"> * lives in, ignoring any value that might be in the cache.</td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source"> * @param tableName name of the table &lt;i&gt;row&lt;/i&gt; is in</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source"> * @param row row key you're trying to find the region of</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source"> * @return HRegionLocation that describes where to find the region in</td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source"> * question</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source"> * @throws IOException if a remote or network exception occurs</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">295</td><td class="hits">1</td><td class="source">Client.prototype.relocateRegion = function (tableName, row, callback) {</td></tr><tr class="hit"><td class="line">296</td><td class="hits">12</td><td class="source">  this.locateRegion(tableName, row, false, callback);</td></tr><tr><td class="line">297</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">298</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">299</td><td class="hits">1</td><td class="source">Client.prototype.ensureZookeeperTrackers = function (callback) {</td></tr><tr class="hit"><td class="line">300</td><td class="hits">202</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">301</td><td class="hits">202</td><td class="source">  if (self.zkStart === 'done') {</td></tr><tr class="hit"><td class="line">302</td><td class="hits">200</td><td class="source">    return callback();</td></tr><tr><td class="line">303</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">305</td><td class="hits">2</td><td class="source">  self.once('ready', callback);</td></tr><tr><td class="line">306</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">307</td><td class="hits">2</td><td class="source">  if (self.zkStart === 'starting') {</td></tr><tr class="hit"><td class="line">308</td><td class="hits">1</td><td class="source">    return;</td></tr><tr><td class="line">309</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">310</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">311</td><td class="hits">1</td><td class="source">  var rootPath = '/root-region-server';</td></tr><tr class="hit"><td class="line">312</td><td class="hits">1</td><td class="source">  self.zkStart = 'starting';</td></tr><tr class="hit"><td class="line">313</td><td class="hits">1</td><td class="source">  self.zk.once('connected', function (err) {</td></tr><tr class="hit"><td class="line">314</td><td class="hits">1</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">315</td><td class="hits">0</td><td class="source">      self.zkStart = 'error';</td></tr><tr class="miss"><td class="line">316</td><td class="hits">0</td><td class="source">      return self.emit('ready', err);</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">318</td><td class="hits">1</td><td class="source">    self.zk.unWatch(rootPath);</td></tr><tr><td class="line">319</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">320</td><td class="hits">1</td><td class="source">    self.zk.watch(rootPath, function (err, value, zstat) {</td></tr><tr class="hit"><td class="line">321</td><td class="hits">1</td><td class="source">      if (err) {</td></tr><tr class="miss"><td class="line">322</td><td class="hits">0</td><td class="source">        self.zkStart = 'error';</td></tr><tr class="miss"><td class="line">323</td><td class="hits">0</td><td class="source">        return self.emit('ready', err);</td></tr><tr><td class="line">324</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">325</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">326</td><td class="hits">1</td><td class="source">      self.zkStart = 'done';</td></tr><tr class="hit"><td class="line">327</td><td class="hits">1</td><td class="source">      self.rootServerName = self.createServerName(value);</td></tr><tr class="hit"><td class="line">328</td><td class="hits">1</td><td class="source">      debug('zookeeper Start, got root %j', self.rootServerName);</td></tr><tr><td class="line">329</td><td class="hits"></td><td class="source">      // console.log('root-region-server value is %j', self.rootServerName);</td></tr><tr><td class="line">330</td><td class="hits"></td><td class="source">      // TODO: not emit ready when path change</td></tr><tr class="hit"><td class="line">331</td><td class="hits">1</td><td class="source">      self.emit('ready');</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">334</td><td class="hits"></td><td class="source">  // self.zk.start();</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">336</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">337</td><td class="hits">1</td><td class="source">Client.prototype._storeRegionInfo = function (regionInfoRow) {</td></tr><tr class="hit"><td class="line">338</td><td class="hits">194</td><td class="source">  var value = regionInfoRow.getValue(HConstants.CATALOG_FAMILY, HConstants.REGIONINFO_QUALIFIER);</td></tr><tr class="hit"><td class="line">339</td><td class="hits">194</td><td class="source">  if (!value || value.length === 0) {</td></tr><tr class="miss"><td class="line">340</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">341</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source">  // convert the row result into the HRegionLocation we need!</td></tr><tr class="hit"><td class="line">344</td><td class="hits">194</td><td class="source">  var io = new DataInputBuffer(value);</td></tr><tr class="hit"><td class="line">345</td><td class="hits">194</td><td class="source">  var regionInfo = new HRegionInfo();</td></tr><tr class="hit"><td class="line">346</td><td class="hits">194</td><td class="source">  regionInfo.readFields(io);</td></tr><tr><td class="line">347</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">348</td><td class="hits">194</td><td class="source">  value = regionInfoRow.getValue(HConstants.CATALOG_FAMILY, HConstants.SERVER_QUALIFIER);</td></tr><tr class="hit"><td class="line">349</td><td class="hits">194</td><td class="source">  var hostAndPort = &quot;&quot;;</td></tr><tr class="hit"><td class="line">350</td><td class="hits">194</td><td class="source">  if (value !== null) {</td></tr><tr class="hit"><td class="line">351</td><td class="hits">194</td><td class="source">    hostAndPort = Bytes.toString(value);</td></tr><tr><td class="line">352</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">353</td><td class="hits"></td><td class="source">  // if (!hostAndPort) {</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source">  //   return callback(new errors.NoServerForRegionException(&quot;No server address listed &quot; + </td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source">  //     &quot;in &quot; + Bytes.toString(parentTable) + &quot; for region &quot; + </td></tr><tr><td class="line">356</td><td class="hits"></td><td class="source">  //     regionInfo.getRegionNameAsString() + &quot; containing row &quot; + Bytes.toStringBinary(row)));</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source">  // }</td></tr><tr class="hit"><td class="line">358</td><td class="hits">194</td><td class="source">  if (!hostAndPort) {</td></tr><tr class="miss"><td class="line">359</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">361</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">362</td><td class="hits"></td><td class="source">  // Instantiate the location</td></tr><tr class="hit"><td class="line">363</td><td class="hits">194</td><td class="source">  var item = hostAndPort.split(':');</td></tr><tr class="hit"><td class="line">364</td><td class="hits">194</td><td class="source">  var hostname = item[0];</td></tr><tr class="hit"><td class="line">365</td><td class="hits">194</td><td class="source">  var port = parseInt(item[1], 10);</td></tr><tr class="hit"><td class="line">366</td><td class="hits">194</td><td class="source">  if (debug.enabled) {</td></tr><tr class="miss"><td class="line">367</td><td class="hits">0</td><td class="source">    debug('_storeRegionInfo [%s:%s] %s', hostname, port, regionInfo.toString());</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">369</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">370</td><td class="hits">194</td><td class="source">  var location = new HRegionLocation(regionInfo, hostname, port);</td></tr><tr class="hit"><td class="line">371</td><td class="hits">194</td><td class="source">  return location;</td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">375</td><td class="hits"></td><td class="source">  * Search one of the meta tables (-ROOT- or .META.) for the HRegionLocation</td></tr><tr><td class="line">376</td><td class="hits"></td><td class="source">  * info that contains the table and row we're seeking.</td></tr><tr><td class="line">377</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">378</td><td class="hits">1</td><td class="source">Client.prototype.locateRegionInMeta = function (parentTable, tableName, row, useCache, callback, tries) {</td></tr><tr class="hit"><td class="line">379</td><td class="hits">173</td><td class="source">  var location;</td></tr><tr><td class="line">380</td><td class="hits"></td><td class="source">  // If we are supposed to be using the cache, look in the cache to see if</td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source">  // we already have the region.</td></tr><tr class="hit"><td class="line">382</td><td class="hits">173</td><td class="source">  if (useCache) {</td></tr><tr class="hit"><td class="line">383</td><td class="hits">145</td><td class="source">    location = this.getCachedLocation(tableName, row);</td></tr><tr class="hit"><td class="line">384</td><td class="hits">145</td><td class="source">    if (location) {</td></tr><tr class="hit"><td class="line">385</td><td class="hits">132</td><td class="source">      return callback(null, location);</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">389</td><td class="hits"></td><td class="source">  // build the key of the meta region we should be looking for.</td></tr><tr><td class="line">390</td><td class="hits"></td><td class="source">  // the extra 9's on the end are necessary to allow &quot;exact&quot; matches</td></tr><tr><td class="line">391</td><td class="hits"></td><td class="source">  // without knowing the precise region names.</td></tr><tr class="hit"><td class="line">392</td><td class="hits">41</td><td class="source">  var metaKey = HRegionInfo.createRegionName(tableName, row, HConstants.NINES, false);</td></tr><tr><td class="line">393</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">394</td><td class="hits">41</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">395</td><td class="hits">41</td><td class="source">  var metaLocation = null;</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source">  // locate the root or meta region</td></tr><tr class="hit"><td class="line">397</td><td class="hits">41</td><td class="source">  self.locateRegion(parentTable, metaKey, false, function (err, metaLocation) {</td></tr><tr class="hit"><td class="line">398</td><td class="hits">41</td><td class="source">    if (err) {</td></tr><tr class="hit"><td class="line">399</td><td class="hits">1</td><td class="source">      return callback(err);</td></tr><tr><td class="line">400</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">402</td><td class="hits">40</td><td class="source">    if (!metaLocation) {</td></tr><tr><td class="line">403</td><td class="hits"></td><td class="source">      // TODO: retries</td></tr><tr class="miss"><td class="line">404</td><td class="hits">0</td><td class="source">      return callback();</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">407</td><td class="hits">40</td><td class="source">    if (debug.enabled) {</td></tr><tr class="miss"><td class="line">408</td><td class="hits">0</td><td class="source">      debug('locateRegion %s from %s, got %s', </td></tr><tr><td class="line">409</td><td class="hits"></td><td class="source">        tableName.toString(), parentTable.toString(), metaLocation.getHostnamePort());</td></tr><tr><td class="line">410</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">412</td><td class="hits">40</td><td class="source">    self.getRegionConnection(metaLocation.getHostname(), metaLocation.getPort(), function (err, server) {</td></tr><tr class="hit"><td class="line">413</td><td class="hits">40</td><td class="source">      if (err) {</td></tr><tr class="miss"><td class="line">414</td><td class="hits">0</td><td class="source">        return callback(err);</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">416</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">417</td><td class="hits"></td><td class="source">      // Check the cache again for a hit in case some other thread made the</td></tr><tr><td class="line">418</td><td class="hits"></td><td class="source">      // same query while we were waiting on the lock. If not supposed to</td></tr><tr><td class="line">419</td><td class="hits"></td><td class="source">      // be using the cache, delete any existing cached location so it won't</td></tr><tr><td class="line">420</td><td class="hits"></td><td class="source">      // interfere.</td></tr><tr><td class="line">421</td><td class="hits"></td><td class="source">      </td></tr><tr class="hit"><td class="line">422</td><td class="hits">40</td><td class="source">      var location = null;</td></tr><tr class="hit"><td class="line">423</td><td class="hits">40</td><td class="source">      if (useCache) {</td></tr><tr class="hit"><td class="line">424</td><td class="hits">13</td><td class="source">        location = self.getCachedLocation(tableName, row);</td></tr><tr class="hit"><td class="line">425</td><td class="hits">13</td><td class="source">        if (location) {</td></tr><tr class="hit"><td class="line">426</td><td class="hits">2</td><td class="source">          return callback(null, location);</td></tr><tr><td class="line">427</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">428</td><td class="hits"></td><td class="source">      } else {</td></tr><tr class="hit"><td class="line">429</td><td class="hits">27</td><td class="source">        self.deleteCachedLocation(tableName, row);</td></tr><tr><td class="line">430</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">431</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">432</td><td class="hits"></td><td class="source">      // Query the root or meta region for the location of the meta region</td></tr><tr class="hit"><td class="line">433</td><td class="hits">38</td><td class="source">      server.getClosestRowBefore(metaLocation.getRegionInfo().getRegionName(), metaKey, HConstants.CATALOG_FAMILY, </td></tr><tr><td class="line">434</td><td class="hits"></td><td class="source">      function (err, regionInfoRow) {</td></tr><tr class="hit"><td class="line">435</td><td class="hits">38</td><td class="source">        if (err) {</td></tr><tr class="hit"><td class="line">436</td><td class="hits">13</td><td class="source">          var errName = err.name.toLowerCase();</td></tr><tr class="hit"><td class="line">437</td><td class="hits">13</td><td class="source">          var errMsg = err.message.toLowerCase();</td></tr><tr><td class="line">438</td><td class="hits"></td><td class="source">          // Only relocate the parent region if necessary</td></tr><tr class="hit"><td class="line">439</td><td class="hits">13</td><td class="source">          if (errName.indexOf('offline') || errMsg.indexOf('offline') || </td></tr><tr><td class="line">440</td><td class="hits"></td><td class="source">              errName.indexOf('noserver') || errMsg.indexOf('noserver') ||</td></tr><tr><td class="line">441</td><td class="hits"></td><td class="source">              errName.indexOf('notserving') || errMsg.indexOf('notserving')) {</td></tr><tr class="hit"><td class="line">442</td><td class="hits">13</td><td class="source">            self.logger.warn(err.stack);</td></tr><tr><td class="line">443</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">444</td><td class="hits">13</td><td class="source">            tries = tries || 0;</td></tr><tr class="hit"><td class="line">445</td><td class="hits">13</td><td class="source">            if (tries &gt; self.numRetries) {</td></tr><tr class="hit"><td class="line">446</td><td class="hits">1</td><td class="source">              return callback(err);</td></tr><tr><td class="line">447</td><td class="hits"></td><td class="source">            }</td></tr><tr class="hit"><td class="line">448</td><td class="hits">12</td><td class="source">            tries++;</td></tr><tr><td class="line">449</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">450</td><td class="hits">12</td><td class="source">            self.logger.warn('[' + new Date() + '] [WARNNING] %d retries to locateRegion: %s', tries, metaKey.toString());</td></tr><tr class="hit"><td class="line">451</td><td class="hits">12</td><td class="source">            self.relocateRegion(parentTable, metaKey, function (err) {</td></tr><tr class="hit"><td class="line">452</td><td class="hits">12</td><td class="source">              if (err) {</td></tr><tr class="miss"><td class="line">453</td><td class="hits">0</td><td class="source">                return callback(err);</td></tr><tr><td class="line">454</td><td class="hits"></td><td class="source">              }</td></tr><tr><td class="line">455</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">456</td><td class="hits">12</td><td class="source">              self.clearRegionCache(tableName);</td></tr><tr><td class="line">457</td><td class="hits"></td><td class="source">              // try again</td></tr><tr class="hit"><td class="line">458</td><td class="hits">12</td><td class="source">              self.locateRegionInMeta(parentTable, tableName, row, false, callback, tries);</td></tr><tr><td class="line">459</td><td class="hits"></td><td class="source">            });</td></tr><tr class="hit"><td class="line">460</td><td class="hits">12</td><td class="source">            return;</td></tr><tr><td class="line">461</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">462</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">463</td><td class="hits">0</td><td class="source">          return callback(err);</td></tr><tr><td class="line">464</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">465</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">466</td><td class="hits">25</td><td class="source">        if (regionInfoRow === null) {</td></tr><tr class="hit"><td class="line">467</td><td class="hits">1</td><td class="source">          return callback(new TableNotFoundException(&quot;Table '&quot; + Bytes.toString(tableName) + &quot;' was not found&quot;));</td></tr><tr><td class="line">468</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">469</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">470</td><td class="hits">24</td><td class="source">        var location = self._storeRegionInfo(regionInfoRow);</td></tr><tr><td class="line">471</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">472</td><td class="hits">24</td><td class="source">        if (!location) {</td></tr><tr class="miss"><td class="line">473</td><td class="hits">0</td><td class="source">          return callback(new IOException(&quot;HRegionInfo was null or empty in &quot; + </td></tr><tr><td class="line">474</td><td class="hits"></td><td class="source">            Bytes.toString(parentTable) + &quot;, row=&quot; + regionInfoRow.toString()));</td></tr><tr><td class="line">475</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">476</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">477</td><td class="hits">24</td><td class="source">        var regionInfo = location.regionInfo;</td></tr><tr><td class="line">478</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">479</td><td class="hits"></td><td class="source">        // possible we got a region of a different table...</td></tr><tr class="hit"><td class="line">480</td><td class="hits">24</td><td class="source">        if (!Bytes.equals(regionInfo.getTableName(), tableName)) {</td></tr><tr class="miss"><td class="line">481</td><td class="hits">0</td><td class="source">          return callback(new TableNotFoundException(&quot;Table '&quot; + Bytes.toString(tableName) + </td></tr><tr><td class="line">482</td><td class="hits"></td><td class="source">            &quot;' was not found, got: &quot; + Bytes.toString(regionInfo.getTableName()) + &quot;.&quot;));</td></tr><tr><td class="line">483</td><td class="hits"></td><td class="source">        }</td></tr><tr class="hit"><td class="line">484</td><td class="hits">24</td><td class="source">        if (regionInfo.isSplit()) {</td></tr><tr class="miss"><td class="line">485</td><td class="hits">0</td><td class="source">          return callback(new errors.RegionOfflineException(&quot;the only available region for&quot; + </td></tr><tr><td class="line">486</td><td class="hits"></td><td class="source">            &quot; the required row is a split parent,&quot; + </td></tr><tr><td class="line">487</td><td class="hits"></td><td class="source">            &quot; the daughters should be online soon: &quot; + regionInfo.getRegionNameAsString()));</td></tr><tr><td class="line">488</td><td class="hits"></td><td class="source">        }</td></tr><tr class="hit"><td class="line">489</td><td class="hits">24</td><td class="source">        if (regionInfo.isOffline()) {</td></tr><tr class="miss"><td class="line">490</td><td class="hits">0</td><td class="source">          return callback(new errors.RegionOfflineException(</td></tr><tr><td class="line">491</td><td class="hits"></td><td class="source">            &quot;the region is offline, could be caused by a disable table call: &quot; + </td></tr><tr><td class="line">492</td><td class="hits"></td><td class="source">            regionInfo.getRegionNameAsString()));</td></tr><tr><td class="line">493</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">494</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">495</td><td class="hits"></td><td class="source">        // if (!hostAndPort) {</td></tr><tr><td class="line">496</td><td class="hits"></td><td class="source">        //   return callback(new errors.NoServerForRegionException(&quot;No server address listed &quot; + </td></tr><tr><td class="line">497</td><td class="hits"></td><td class="source">        //     &quot;in &quot; + Bytes.toString(parentTable) + &quot; for region &quot; + </td></tr><tr><td class="line">498</td><td class="hits"></td><td class="source">        //     regionInfo.getRegionNameAsString() + &quot; containing row &quot; + Bytes.toStringBinary(row)));</td></tr><tr><td class="line">499</td><td class="hits"></td><td class="source">        // }</td></tr><tr><td class="line">500</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">501</td><td class="hits">24</td><td class="source">        self.cacheLocation(tableName, location);</td></tr><tr><td class="line">502</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">503</td><td class="hits"></td><td class="source">        // If the parent table is META, we may want to pre-fetch some</td></tr><tr><td class="line">504</td><td class="hits"></td><td class="source">        // region info into the global region cache for this table.</td></tr><tr class="hit"><td class="line">505</td><td class="hits">24</td><td class="source">        if (Bytes.equals(parentTable, HConstants.META_TABLE_NAME)) {</td></tr><tr class="hit"><td class="line">506</td><td class="hits">10</td><td class="source">          self.prefetchRegionCache(tableName, regionInfo.startKey, function (err, count) {</td></tr><tr><td class="line">507</td><td class="hits"></td><td class="source">          // self.prefetchRegionCache(tableName, HConstants.EMPTY_START_ROW, function (err, count) {</td></tr><tr class="hit"><td class="line">508</td><td class="hits">10</td><td class="source">            self.logger.warn('[%s, startRow:%s] prefetchRegionCache %d locations', tableName.toString(), regionInfo.startKey, count);</td></tr><tr class="hit"><td class="line">509</td><td class="hits">10</td><td class="source">            if (err) {</td></tr><tr class="miss"><td class="line">510</td><td class="hits">0</td><td class="source">              self.logger.warn('[prefetchRegionCache] error: %s', err.stack);</td></tr><tr><td class="line">511</td><td class="hits"></td><td class="source">            }</td></tr><tr><td class="line">512</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">513</td><td class="hits">10</td><td class="source">            callback(null, location);</td></tr><tr><td class="line">514</td><td class="hits"></td><td class="source">          });</td></tr><tr><td class="line">515</td><td class="hits"></td><td class="source">        } else {</td></tr><tr class="hit"><td class="line">516</td><td class="hits">14</td><td class="source">          callback(null, location);</td></tr><tr><td class="line">517</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">518</td><td class="hits"></td><td class="source">        </td></tr><tr><td class="line">519</td><td class="hits"></td><td class="source">      });</td></tr><tr><td class="line">520</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">521</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">522</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">523</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">524</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">525</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">526</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">527</td><td class="hits"></td><td class="source"> * Get region connection.</td></tr><tr><td class="line">528</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">529</td><td class="hits"></td><td class="source"> * @param {String} hostname</td></tr><tr><td class="line">530</td><td class="hits"></td><td class="source"> * @param {Number} port</td></tr><tr><td class="line">531</td><td class="hits"></td><td class="source"> * @param {Function(err, server)} callback</td></tr><tr><td class="line">532</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">533</td><td class="hits">1</td><td class="source">Client.prototype.getRegionConnection = function (hostname, port, callback) {</td></tr><tr class="hit"><td class="line">534</td><td class="hits">118</td><td class="source">  var server;</td></tr><tr class="hit"><td class="line">535</td><td class="hits">118</td><td class="source">  var rsName = hostname + ':' + port;</td></tr><tr class="hit"><td class="line">536</td><td class="hits">118</td><td class="source">  var self = this;</td></tr><tr><td class="line">537</td><td class="hits"></td><td class="source">  // See if we already have a connection (common case)</td></tr><tr class="hit"><td class="line">538</td><td class="hits">118</td><td class="source">  server = self.servers[rsName];</td></tr><tr class="hit"><td class="line">539</td><td class="hits">118</td><td class="source">  var readyEvent = 'getRegionConnection:' + rsName + ':ready';</td></tr><tr class="hit"><td class="line">540</td><td class="hits">118</td><td class="source">  if (server &amp;&amp; server.state === 'ready') {</td></tr><tr class="hit"><td class="line">541</td><td class="hits">107</td><td class="source">    debug('getRegionConnection from cache(%d), %s', self.serversLength, rsName);</td></tr><tr class="hit"><td class="line">542</td><td class="hits">107</td><td class="source">    return callback(null, server);</td></tr><tr><td class="line">543</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">544</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">545</td><td class="hits"></td><td class="source">  // debug('watting `%s` event', readyEvent);</td></tr><tr class="hit"><td class="line">546</td><td class="hits">11</td><td class="source">  self.once(readyEvent, callback);</td></tr><tr><td class="line">547</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">548</td><td class="hits">11</td><td class="source">  if (server) {</td></tr><tr class="hit"><td class="line">549</td><td class="hits">1</td><td class="source">    return;</td></tr><tr><td class="line">550</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">551</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">552</td><td class="hits">10</td><td class="source">  server = new Connection({</td></tr><tr><td class="line">553</td><td class="hits"></td><td class="source">    host: hostname,</td></tr><tr><td class="line">554</td><td class="hits"></td><td class="source">    port: port,</td></tr><tr><td class="line">555</td><td class="hits"></td><td class="source">    rpcTimeout: self.rpcTimeout,</td></tr><tr><td class="line">556</td><td class="hits"></td><td class="source">    logger: self.logger,</td></tr><tr><td class="line">557</td><td class="hits"></td><td class="source">  });</td></tr><tr class="hit"><td class="line">558</td><td class="hits">10</td><td class="source">  server.state = 'connecting';</td></tr><tr><td class="line">559</td><td class="hits"></td><td class="source">  // cache server</td></tr><tr class="hit"><td class="line">560</td><td class="hits">10</td><td class="source">  self.servers[rsName] = server;</td></tr><tr class="hit"><td class="line">561</td><td class="hits">10</td><td class="source">  self.serversLength++;</td></tr><tr><td class="line">562</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">563</td><td class="hits">10</td><td class="source">  server.on('connect', function () {</td></tr><tr><td class="line">564</td><td class="hits"></td><td class="source">    // should getProtocolVersion() first to check version</td></tr><tr class="hit"><td class="line">565</td><td class="hits">10</td><td class="source">    server.getProtocolVersion(null, null, function (err, version) {</td></tr><tr class="hit"><td class="line">566</td><td class="hits">10</td><td class="source">      server.state = 'ready';</td></tr><tr><td class="line">567</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">568</td><td class="hits">10</td><td class="source">      if (err) {</td></tr><tr class="miss"><td class="line">569</td><td class="hits">0</td><td class="source">        return self.emit(readyEvent, err);</td></tr><tr><td class="line">570</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">571</td><td class="hits">10</td><td class="source">      version = version.toNumber();</td></tr><tr class="hit"><td class="line">572</td><td class="hits">10</td><td class="source">      debug('Protocol: %s, %s emit', version, readyEvent);</td></tr><tr><td class="line">573</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">574</td><td class="hits">10</td><td class="source">      self.emit(readyEvent, null, server);</td></tr><tr><td class="line">575</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">576</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">577</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">578</td><td class="hits">10</td><td class="source">  server.once('close', function () {</td></tr><tr class="hit"><td class="line">579</td><td class="hits">6</td><td class="source">    delete self.servers[rsName];</td></tr><tr class="hit"><td class="line">580</td><td class="hits">6</td><td class="source">    self.serversLength--;</td></tr><tr><td class="line">581</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">582</td><td class="hits"></td><td class="source">    // clean relation regions cache</td></tr><tr class="hit"><td class="line">583</td><td class="hits">6</td><td class="source">    self.clearCachedLocationForServer(rsName);</td></tr><tr><td class="line">584</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">585</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">586</td><td class="hits"></td><td class="source">  // TODO: handle `timeout` event </td></tr><tr><td class="line">587</td><td class="hits"></td><td class="source">  // http://nodejs.org/docs/v0.8.23/api/net.html#net_socket_settimeout_timeout_callback</td></tr><tr><td class="line">588</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">589</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">590</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">591</td><td class="hits"></td><td class="source"> * Delete a cached location</td></tr><tr><td class="line">592</td><td class="hits"></td><td class="source"> * @param tableName tableName</td></tr><tr><td class="line">593</td><td class="hits"></td><td class="source"> * @param row</td></tr><tr><td class="line">594</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">595</td><td class="hits">1</td><td class="source">Client.prototype.deleteCachedLocation = function (tableName, row) {</td></tr><tr class="hit"><td class="line">596</td><td class="hits">27</td><td class="source">  var key = Bytes.mapKey(tableName);</td></tr><tr class="hit"><td class="line">597</td><td class="hits">27</td><td class="source">  var tableLocations = this.cachedRegionLocations[key];</td></tr><tr class="hit"><td class="line">598</td><td class="hits">27</td><td class="source">  if (!tableLocations || !tableLocations.length) {</td></tr><tr class="hit"><td class="line">599</td><td class="hits">19</td><td class="source">    return;</td></tr><tr><td class="line">600</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">601</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">602</td><td class="hits"></td><td class="source">  // start to examine the cache. we can only do cache actions</td></tr><tr><td class="line">603</td><td class="hits"></td><td class="source">  // if there's something in the cache for this table.</td></tr><tr class="hit"><td class="line">604</td><td class="hits">8</td><td class="source">  var needs = [];</td></tr><tr class="hit"><td class="line">605</td><td class="hits">8</td><td class="source">  for (var i = 0; i &lt; tableLocations.length; i++) {</td></tr><tr class="hit"><td class="line">606</td><td class="hits">8</td><td class="source">    var location = tableLocations[i];</td></tr><tr class="hit"><td class="line">607</td><td class="hits">8</td><td class="source">    var r = Bytes.compareTo(row, location.regionInfo.startKey);</td></tr><tr class="hit"><td class="line">608</td><td class="hits">8</td><td class="source">    if (r &lt; 0) {</td></tr><tr class="miss"><td class="line">609</td><td class="hits">0</td><td class="source">      needs.push(location);</td></tr><tr class="miss"><td class="line">610</td><td class="hits">0</td><td class="source">      continue;</td></tr><tr><td class="line">611</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">612</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">613</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">614</td><td class="hits">8</td><td class="source">  this.cachedRegionLocations[key] = needs;</td></tr><tr><td class="line">615</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">616</td><td class="hits"></td><td class="source">  // if (!tableLocations.isEmpty()) {</td></tr><tr><td class="line">617</td><td class="hits"></td><td class="source">  //   HRegionLocation rl = getCachedLocation(tableName, row);</td></tr><tr><td class="line">618</td><td class="hits"></td><td class="source">  //   if (rl != null) {</td></tr><tr><td class="line">619</td><td class="hits"></td><td class="source">  //     tableLocations.remove(rl.getRegionInfo().getStartKey());</td></tr><tr><td class="line">620</td><td class="hits"></td><td class="source">  //     if (LOG.isDebugEnabled()) {</td></tr><tr><td class="line">621</td><td class="hits"></td><td class="source">  //       LOG.debug(&quot;Removed &quot; + rl.getRegionInfo().getRegionNameAsString() + &quot; for tableName=&quot;</td></tr><tr><td class="line">622</td><td class="hits"></td><td class="source">  //           + Bytes.toString(tableName) + &quot; from cache &quot; + &quot;because of &quot; + Bytes.toStringBinary(row));</td></tr><tr><td class="line">623</td><td class="hits"></td><td class="source">  //     }</td></tr><tr><td class="line">624</td><td class="hits"></td><td class="source">  //   }</td></tr><tr><td class="line">625</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">626</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">627</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">628</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">629</td><td class="hits"></td><td class="source"> * Search the cache for a location that fits our table and row key.</td></tr><tr><td class="line">630</td><td class="hits"></td><td class="source"> * Return null if no suitable region is located. TODO: synchronization note</td></tr><tr><td class="line">631</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">632</td><td class="hits"></td><td class="source"> * &lt;p&gt;TODO: This method during writing consumes 15% of CPU doing lookup</td></tr><tr><td class="line">633</td><td class="hits"></td><td class="source"> * into the Soft Reference SortedMap.  Improve.</td></tr><tr><td class="line">634</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">635</td><td class="hits"></td><td class="source"> * @param tableName</td></tr><tr><td class="line">636</td><td class="hits"></td><td class="source"> * @param row</td></tr><tr><td class="line">637</td><td class="hits"></td><td class="source"> * @return Null or region location found in cache.</td></tr><tr><td class="line">638</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">639</td><td class="hits">1</td><td class="source">Client.prototype.getCachedLocation = function (tableName, row) {</td></tr><tr class="hit"><td class="line">640</td><td class="hits">158</td><td class="source">  var tableLocations = this.getTableLocations(tableName);</td></tr><tr><td class="line">641</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">642</td><td class="hits"></td><td class="source">  // start to examine the cache. we can only do cache actions</td></tr><tr><td class="line">643</td><td class="hits"></td><td class="source">  // if there's something in the cache for this table.</td></tr><tr class="hit"><td class="line">644</td><td class="hits">158</td><td class="source">  if (!tableLocations.length) {</td></tr><tr class="hit"><td class="line">645</td><td class="hits">14</td><td class="source">    return null;</td></tr><tr><td class="line">646</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">647</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">648</td><td class="hits">144</td><td class="source">  for (var i = 0; i &lt; tableLocations.length; i++) {</td></tr><tr class="hit"><td class="line">649</td><td class="hits">1122</td><td class="source">    var location = tableLocations[i];</td></tr><tr class="hit"><td class="line">650</td><td class="hits">1122</td><td class="source">    var startKey = location.regionInfo.startKey;</td></tr><tr class="hit"><td class="line">651</td><td class="hits">1122</td><td class="source">    var endKey = location.regionInfo.endKey;</td></tr><tr class="hit"><td class="line">652</td><td class="hits">1122</td><td class="source">    var r = Bytes.compareTo(row, startKey);</td></tr><tr class="hit"><td class="line">653</td><td class="hits">1122</td><td class="source">    if (r &gt;= 0) {</td></tr><tr class="hit"><td class="line">654</td><td class="hits">697</td><td class="source">      if (endKey.length === 0 || Bytes.compareTo(endKey, row) &gt; 0) {</td></tr><tr class="hit"><td class="line">655</td><td class="hits">134</td><td class="source">        if (debug.enabled) {</td></tr><tr class="miss"><td class="line">656</td><td class="hits">0</td><td class="source">          debug('getCachedLocation hit(%d: %d): get location(%s)', </td></tr><tr><td class="line">657</td><td class="hits"></td><td class="source">            tableLocations.length, i, location.toString());</td></tr><tr><td class="line">658</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">659</td><td class="hits"></td><td class="source">        </td></tr><tr class="hit"><td class="line">660</td><td class="hits">134</td><td class="source">        return location;</td></tr><tr><td class="line">661</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">662</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">663</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">664</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">665</td><td class="hits">10</td><td class="source">  debug('getCachedLocation miss(%d)', tableLocations.length);</td></tr><tr class="hit"><td class="line">666</td><td class="hits">10</td><td class="source">  return null;</td></tr><tr><td class="line">667</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">668</td><td class="hits"></td><td class="source">  // var possibleRegion = tableLocations.get(row);</td></tr><tr><td class="line">669</td><td class="hits"></td><td class="source">  // if (possibleRegion !== null) {</td></tr><tr><td class="line">670</td><td class="hits"></td><td class="source">  //   return possibleRegion;</td></tr><tr><td class="line">671</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">672</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">673</td><td class="hits"></td><td class="source">  // possibleRegion = tableLocations.lowerValueByKey(row);</td></tr><tr><td class="line">674</td><td class="hits"></td><td class="source">  // if (possibleRegion === null) {</td></tr><tr><td class="line">675</td><td class="hits"></td><td class="source">  //   return null;</td></tr><tr><td class="line">676</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">677</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">678</td><td class="hits"></td><td class="source">  // // make sure that the end key is greater than the row we're looking</td></tr><tr><td class="line">679</td><td class="hits"></td><td class="source">  // // for, otherwise the row actually belongs in the next region, not</td></tr><tr><td class="line">680</td><td class="hits"></td><td class="source">  // // this one. the exception case is when the endkey is</td></tr><tr><td class="line">681</td><td class="hits"></td><td class="source">  // // HConstants.EMPTY_END_ROW, signifying that the region we're</td></tr><tr><td class="line">682</td><td class="hits"></td><td class="source">  // // checking is actually the last region in the table.</td></tr><tr><td class="line">683</td><td class="hits"></td><td class="source">  // var endKey = possibleRegion.getRegionInfo().getEndKey();</td></tr><tr><td class="line">684</td><td class="hits"></td><td class="source">  // if (Bytes.equals(endKey, HConstants.EMPTY_END_ROW)</td></tr><tr><td class="line">685</td><td class="hits"></td><td class="source">  //     || KeyValue.getRowComparator(tableName).compareRows(endKey, 0, endKey.length, row, 0, row.length) &gt; 0) {</td></tr><tr><td class="line">686</td><td class="hits"></td><td class="source">  //   return possibleRegion;</td></tr><tr><td class="line">687</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">688</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">689</td><td class="hits"></td><td class="source">  // // Passed all the way through, so we got nothin - complete cache miss</td></tr><tr><td class="line">690</td><td class="hits"></td><td class="source">  // return null;</td></tr><tr><td class="line">691</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">692</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">693</td><td class="hits">1</td><td class="source">Client.prototype.createServerName = function (data) {</td></tr><tr class="hit"><td class="line">694</td><td class="hits">1</td><td class="source">  data = removeMetaData(data);</td></tr><tr class="hit"><td class="line">695</td><td class="hits">1</td><td class="source">  var servername = Bytes.toString(data);</td></tr><tr class="hit"><td class="line">696</td><td class="hits">1</td><td class="source">  var items = servername.split(SERVERNAME_SEPARATOR);</td></tr><tr class="hit"><td class="line">697</td><td class="hits">1</td><td class="source">  return {</td></tr><tr><td class="line">698</td><td class="hits"></td><td class="source">    hostname: items[0],</td></tr><tr><td class="line">699</td><td class="hits"></td><td class="source">    port: parseInt(items[1], 10),</td></tr><tr><td class="line">700</td><td class="hits"></td><td class="source">    startcode: Number(items[2]),</td></tr><tr><td class="line">701</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">702</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">703</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">704</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">705</td><td class="hits"></td><td class="source"> * Delete all cached entries of a table that maps to a specific location.</td></tr><tr><td class="line">706</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">707</td><td class="hits"></td><td class="source"> * @param hostnamePort</td></tr><tr><td class="line">708</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">709</td><td class="hits">1</td><td class="source">Client.prototype.clearCachedLocationForServer = function (hostnamePort) {</td></tr><tr class="hit"><td class="line">710</td><td class="hits">6</td><td class="source">  var deletedCount = 0;</td></tr><tr class="hit"><td class="line">711</td><td class="hits">6</td><td class="source">  if (!this.cachedServers[hostnamePort]) {</td></tr><tr class="hit"><td class="line">712</td><td class="hits">2</td><td class="source">    return;</td></tr><tr><td class="line">713</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">714</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">715</td><td class="hits">4</td><td class="source">  for (var key in this.cachedRegionLocations) {</td></tr><tr class="hit"><td class="line">716</td><td class="hits">16</td><td class="source">    var locations = this.cachedRegionLocations[key];</td></tr><tr class="hit"><td class="line">717</td><td class="hits">16</td><td class="source">    var needs = [];</td></tr><tr class="hit"><td class="line">718</td><td class="hits">16</td><td class="source">    var deleted = false;</td></tr><tr class="hit"><td class="line">719</td><td class="hits">16</td><td class="source">    for (var i = 0; i &lt; locations.length; i++) {</td></tr><tr class="hit"><td class="line">720</td><td class="hits">103</td><td class="source">      var location = locations[i];</td></tr><tr class="hit"><td class="line">721</td><td class="hits">103</td><td class="source">      if (location.getHostnamePort() === hostnamePort) {</td></tr><tr class="hit"><td class="line">722</td><td class="hits">28</td><td class="source">        deletedCount++;</td></tr><tr class="hit"><td class="line">723</td><td class="hits">28</td><td class="source">        deleted = true;</td></tr><tr><td class="line">724</td><td class="hits"></td><td class="source">      } else {</td></tr><tr class="hit"><td class="line">725</td><td class="hits">75</td><td class="source">        needs.push(location);</td></tr><tr><td class="line">726</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">727</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">728</td><td class="hits">16</td><td class="source">    if (deleted) {</td></tr><tr class="hit"><td class="line">729</td><td class="hits">8</td><td class="source">      this.cachedRegionLocations[key] = needs;</td></tr><tr><td class="line">730</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">731</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">732</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">733</td><td class="hits">4</td><td class="source">  delete this.cachedServers[hostnamePort];</td></tr><tr class="hit"><td class="line">734</td><td class="hits">4</td><td class="source">  this.logger.warn(&quot;Removed %d cached region locations that map to `%s`&quot;, deletedCount, hostnamePort);</td></tr><tr><td class="line">735</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">736</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">737</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">738</td><td class="hits"></td><td class="source"> * @param tableName</td></tr><tr><td class="line">739</td><td class="hits"></td><td class="source"> * @return Map of cached locations for passed &lt;code&gt;tableName&lt;/code&gt;</td></tr><tr><td class="line">740</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">741</td><td class="hits">1</td><td class="source">Client.prototype.getTableLocations = function (tableName) {</td></tr><tr><td class="line">742</td><td class="hits"></td><td class="source">  // find the map of cached locations for this table</td></tr><tr class="hit"><td class="line">743</td><td class="hits">285</td><td class="source">  var key = tableName.__key;</td></tr><tr class="hit"><td class="line">744</td><td class="hits">285</td><td class="source">  if (!key) {</td></tr><tr class="hit"><td class="line">745</td><td class="hits">38</td><td class="source">    key = tableName.__key = Bytes.mapKey(tableName);</td></tr><tr><td class="line">746</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">747</td><td class="hits">285</td><td class="source">  var result = this.cachedRegionLocations[key];</td></tr><tr class="hit"><td class="line">748</td><td class="hits">285</td><td class="source">  if (!result) {</td></tr><tr class="hit"><td class="line">749</td><td class="hits">4</td><td class="source">    this.cachedRegionLocations[key] = result = [];</td></tr><tr><td class="line">750</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">751</td><td class="hits">285</td><td class="source">  return result;</td></tr><tr><td class="line">752</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">753</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">754</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">755</td><td class="hits"></td><td class="source"> * Put a newly discovered HRegionLocation into the cache.</td></tr><tr><td class="line">756</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">757</td><td class="hits">1</td><td class="source">Client.prototype.cacheLocation = function (tableName, location) {</td></tr><tr><td class="line">758</td><td class="hits"></td><td class="source">  // TODO: remove location when it split and offline</td></tr><tr class="hit"><td class="line">759</td><td class="hits">127</td><td class="source">  var tableLocations = this.getTableLocations(tableName);</td></tr><tr class="hit"><td class="line">760</td><td class="hits">127</td><td class="source">  for (var i = 0; i &lt; tableLocations.length; i++) {</td></tr><tr class="hit"><td class="line">761</td><td class="hits">1395</td><td class="source">    var o = tableLocations[i];</td></tr><tr class="hit"><td class="line">762</td><td class="hits">1395</td><td class="source">    if (location.regionInfo.compareTo(o.regionInfo) === 0) {</td></tr><tr><td class="line">763</td><td class="hits"></td><td class="source">      // if location exists, do not cache it.</td></tr><tr class="hit"><td class="line">764</td><td class="hits">57</td><td class="source">      return;</td></tr><tr><td class="line">765</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">766</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">767</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">768</td><td class="hits">70</td><td class="source">  this.cachedServers[location.getHostnamePort()] = true;</td></tr><tr class="hit"><td class="line">769</td><td class="hits">70</td><td class="source">  tableLocations.push(location);</td></tr><tr><td class="line">770</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">771</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">772</td><td class="hits">1</td><td class="source">Client.prototype.clearRegionCache = function (tableName) {</td></tr><tr class="hit"><td class="line">773</td><td class="hits">12</td><td class="source">  if (tableName) {</td></tr><tr class="hit"><td class="line">774</td><td class="hits">12</td><td class="source">    var key = tableName.__key;</td></tr><tr class="hit"><td class="line">775</td><td class="hits">12</td><td class="source">    if (!key) {</td></tr><tr class="miss"><td class="line">776</td><td class="hits">0</td><td class="source">      key = tableName.__key = Bytes.mapKey(tableName);</td></tr><tr><td class="line">777</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">778</td><td class="hits">12</td><td class="source">    if (debug.enabled) {</td></tr><tr class="miss"><td class="line">779</td><td class="hits">0</td><td class="source">      debug('clearRegionCache %s: %d', </td></tr><tr><td class="line">780</td><td class="hits"></td><td class="source">        tableName.toString(), this.cachedRegionLocations[key] ? this.cachedRegionLocations[key].length : 0);</td></tr><tr><td class="line">781</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">782</td><td class="hits">12</td><td class="source">    this.cachedRegionLocations[key] = [];</td></tr><tr><td class="line">783</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">784</td><td class="hits">0</td><td class="source">    this.cachedRegionLocations = {};</td></tr><tr><td class="line">785</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">786</td><td class="hits">12</td><td class="source">  this.cachedServers = {};</td></tr><tr><td class="line">787</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">788</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">789</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">790</td><td class="hits"></td><td class="source"> * Search .META. for the HRegionLocation info that contains the table and</td></tr><tr><td class="line">791</td><td class="hits"></td><td class="source"> * row we're seeking. It will prefetch certain number of regions info and</td></tr><tr><td class="line">792</td><td class="hits"></td><td class="source"> * save them to the global region cache.</td></tr><tr><td class="line">793</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">794</td><td class="hits">1</td><td class="source">Client.prototype.prefetchRegionCache = function (tableName, row, callback) {</td></tr><tr><td class="line">795</td><td class="hits"></td><td class="source">  // Implement a new visitor for MetaScanner, and use it to walk through</td></tr><tr><td class="line">796</td><td class="hits"></td><td class="source">  // the .META.</td></tr><tr class="hit"><td class="line">797</td><td class="hits">10</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">798</td><td class="hits">10</td><td class="source">  var startRow = HRegionInfo.createRegionName(tableName, row, HConstants.ZEROES, false);</td></tr><tr class="hit"><td class="line">799</td><td class="hits">10</td><td class="source">  var scan = new Scan(startRow);</td></tr><tr class="hit"><td class="line">800</td><td class="hits">10</td><td class="source">  scan.addFamily(HConstants.CATALOG_FAMILY);</td></tr><tr class="hit"><td class="line">801</td><td class="hits">10</td><td class="source">  self.getScanner(HConstants.META_TABLE_NAME, scan, function (err, scanner) {</td></tr><tr class="hit"><td class="line">802</td><td class="hits">10</td><td class="source">    var count = 0;</td></tr><tr class="hit"><td class="line">803</td><td class="hits">10</td><td class="source">    var done = function (error) {</td></tr><tr class="hit"><td class="line">804</td><td class="hits">10</td><td class="source">      if (scanner) {</td></tr><tr class="hit"><td class="line">805</td><td class="hits">10</td><td class="source">        scanner.close(function () {</td></tr><tr class="hit"><td class="line">806</td><td class="hits">10</td><td class="source">          callback(error, count);</td></tr><tr><td class="line">807</td><td class="hits"></td><td class="source">        });</td></tr><tr><td class="line">808</td><td class="hits"></td><td class="source">      } else {</td></tr><tr class="miss"><td class="line">809</td><td class="hits">0</td><td class="source">        callback(error, count);</td></tr><tr><td class="line">810</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">811</td><td class="hits"></td><td class="source">    };</td></tr><tr><td class="line">812</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">813</td><td class="hits">10</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">814</td><td class="hits">0</td><td class="source">      return done(err);</td></tr><tr><td class="line">815</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">816</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">817</td><td class="hits">10</td><td class="source">    var next = function (numberOfRows) {</td></tr><tr class="hit"><td class="line">818</td><td class="hits">17</td><td class="source">      scanner.next(numberOfRows, function (err, rows) {</td></tr><tr class="hit"><td class="line">819</td><td class="hits">17</td><td class="source">        if (err) {</td></tr><tr class="miss"><td class="line">820</td><td class="hits">0</td><td class="source">          return done(err);</td></tr><tr><td class="line">821</td><td class="hits"></td><td class="source">        }</td></tr><tr class="hit"><td class="line">822</td><td class="hits">17</td><td class="source">        if (!rows || rows.length === 0) {</td></tr><tr class="miss"><td class="line">823</td><td class="hits">0</td><td class="source">          return done();</td></tr><tr><td class="line">824</td><td class="hits"></td><td class="source">        }</td></tr><tr class="hit"><td class="line">825</td><td class="hits">17</td><td class="source">        var closed = false;</td></tr><tr class="hit"><td class="line">826</td><td class="hits">17</td><td class="source">        rows.forEach(function (regionInfoRow) {</td></tr><tr class="hit"><td class="line">827</td><td class="hits">170</td><td class="source">          var location = self._storeRegionInfo(regionInfoRow);</td></tr><tr class="hit"><td class="line">828</td><td class="hits">170</td><td class="source">          if (!Bytes.equals(location.regionInfo.tableName, tableName)) {</td></tr><tr class="hit"><td class="line">829</td><td class="hits">67</td><td class="source">            closed = true;</td></tr><tr class="hit"><td class="line">830</td><td class="hits">67</td><td class="source">            return false;</td></tr><tr><td class="line">831</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">832</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">833</td><td class="hits">103</td><td class="source">          var regionInfo = location.regionInfo;</td></tr><tr><td class="line">834</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">835</td><td class="hits">103</td><td class="source">          if (regionInfo.isSplit()) {</td></tr><tr class="miss"><td class="line">836</td><td class="hits">0</td><td class="source">            return;</td></tr><tr><td class="line">837</td><td class="hits"></td><td class="source">          }</td></tr><tr class="hit"><td class="line">838</td><td class="hits">103</td><td class="source">          if (regionInfo.isOffline()) {</td></tr><tr class="miss"><td class="line">839</td><td class="hits">0</td><td class="source">            return;</td></tr><tr><td class="line">840</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">841</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">842</td><td class="hits">103</td><td class="source">          count++;</td></tr><tr class="hit"><td class="line">843</td><td class="hits">103</td><td class="source">          self.cacheLocation(tableName, location);</td></tr><tr><td class="line">844</td><td class="hits"></td><td class="source">        });</td></tr><tr><td class="line">845</td><td class="hits"></td><td class="source">        </td></tr><tr class="hit"><td class="line">846</td><td class="hits">17</td><td class="source">        if (closed) {</td></tr><tr class="hit"><td class="line">847</td><td class="hits">10</td><td class="source">          return done();</td></tr><tr><td class="line">848</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">849</td><td class="hits"></td><td class="source">        </td></tr><tr class="hit"><td class="line">850</td><td class="hits">7</td><td class="source">        next(numberOfRows);</td></tr><tr><td class="line">851</td><td class="hits"></td><td class="source">      });</td></tr><tr><td class="line">852</td><td class="hits"></td><td class="source">    };</td></tr><tr class="hit"><td class="line">853</td><td class="hits">10</td><td class="source">    next(10);</td></tr><tr><td class="line">854</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">855</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">856</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">857</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">858</td><td class="hits">1</td><td class="source">module.exports = Client;</td></tr><tr><td class="line">859</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/connection.js">/Users/mk2/git/node-hbase-client/lib/connection.js</h2><div id="stats" class="high"><div class="percentage">90%</div><div class="sloc">239</div><div class="hits">217</div><div class="misses">22</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/connection.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var debug = require('debug')('hbase:connection');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Readable = require('readable-stream').Readable;</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var EventEmitter = require('events').EventEmitter;</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var utility = require('utility');</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var net = require('net');</td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">var Text = require('./text');</td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">var ResponseFlag = require('./ipc/response_flag');</td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">var DataInputBuffer = require('./data_input_buffer');</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">var DataOutputBuffer = require('./data_output_buffer');</td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">var DataInputStream = require('./data_input_stream');</td></tr><tr class="hit"><td class="line">26</td><td class="hits">1</td><td class="source">var DataOutputStream = require('./data_output_stream');</td></tr><tr class="hit"><td class="line">27</td><td class="hits">1</td><td class="source">var HbaseObjectWritable = require('./io/hbase_object_writable');</td></tr><tr class="hit"><td class="line">28</td><td class="hits">1</td><td class="source">var Invocation = require('./ipc/invocation');</td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr class="hit"><td class="line">30</td><td class="hits">1</td><td class="source">var errors = require('./errors');</td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">var RemoteException = errors.RemoteException;</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">33</td><td class="hits">1</td><td class="source">var HEADER = new Buffer(&quot;hrpc&quot;, &quot;utf8&quot;);</td></tr><tr class="hit"><td class="line">34</td><td class="hits">1</td><td class="source">var CURRENT_VERSION = 3;</td></tr><tr class="hit"><td class="line">35</td><td class="hits">1</td><td class="source">var PING_CALL_ID = -1;</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> * The IPC connection header sent by the client to the server</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> * on connection establishment.</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> * Create a new {@link ConnectionHeader} with the given &lt;code&gt;protocol&lt;/code&gt;</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> * and {@link User}.</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> * @param protocol protocol used for communication between the IPC client</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> *                 and the server</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> * @param user {@link User} of the client communicating with</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> *            the server</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">48</td><td class="hits">1</td><td class="source">function ConnectionHeader(protocol, user) {</td></tr><tr class="hit"><td class="line">49</td><td class="hits">17</td><td class="source">  this.protocol = protocol;</td></tr><tr class="hit"><td class="line">50</td><td class="hits">17</td><td class="source">  this.user = user;</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">53</td><td class="hits">1</td><td class="source">ConnectionHeader.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">54</td><td class="hits">17</td><td class="source">  debug('ConnectionHeader: write %s', this.protocol);</td></tr><tr class="hit"><td class="line">55</td><td class="hits">17</td><td class="source">  Text.writeString(out, this.protocol || '');</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">},</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">ConnectionHeader.prototype.getProtocol = function () {</td></tr><tr class="miss"><td class="line">59</td><td class="hits">0</td><td class="source">  return this.protocol;</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">ConnectionHeader.prototype.getUser = function () {</td></tr><tr class="miss"><td class="line">63</td><td class="hits">0</td><td class="source">  return null;</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">66</td><td class="hits">1</td><td class="source">ConnectionHeader.prototype.toString = function () {</td></tr><tr class="miss"><td class="line">67</td><td class="hits">0</td><td class="source">  return this.protocol;</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">70</td><td class="hits">1</td><td class="source">var _Connection_id = 0;</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">/** Thread that reads responses and notifies callers.  Each connection owns a</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> * socket connected to a remote address.  Calls are multiplexed through this</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> * socket: responses may be delivered out of order. */</td></tr><tr class="hit"><td class="line">75</td><td class="hits">1</td><td class="source">function Connection(options) {</td></tr><tr class="hit"><td class="line">76</td><td class="hits">17</td><td class="source">  EventEmitter.call(this);</td></tr><tr class="hit"><td class="line">77</td><td class="hits">17</td><td class="source">  this.id = _Connection_id++;</td></tr><tr class="hit"><td class="line">78</td><td class="hits">17</td><td class="source">  this.header = null; // connection header</td></tr><tr class="hit"><td class="line">79</td><td class="hits">17</td><td class="source">  this.socket = null; // connected socket</td></tr><tr class="hit"><td class="line">80</td><td class="hits">17</td><td class="source">  this.in;</td></tr><tr class="hit"><td class="line">81</td><td class="hits">17</td><td class="source">  this.out;</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">83</td><td class="hits">17</td><td class="source">  this.tcpNoDelay = false; // nodelay not or</td></tr><tr class="hit"><td class="line">84</td><td class="hits">17</td><td class="source">  this.tcpKeepAlive = true;</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  // currently active calls</td></tr><tr class="hit"><td class="line">87</td><td class="hits">17</td><td class="source">  this.calls = {};</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">89</td><td class="hits">17</td><td class="source">  this.address = {host: options.host, port: options.port};</td></tr><tr class="hit"><td class="line">90</td><td class="hits">17</td><td class="source">  this.hostnamePort = options.host + ':' + options.port;</td></tr><tr class="hit"><td class="line">91</td><td class="hits">17</td><td class="source">  this.name = 'Connection(' + this.hostnamePort + ')#' + this.id;</td></tr><tr class="hit"><td class="line">92</td><td class="hits">17</td><td class="source">  var protocol = options.protocol || HConstants.PROTOCOL;</td></tr><tr class="hit"><td class="line">93</td><td class="hits">17</td><td class="source">  this.rpcTimeout = options.rpcTimeout || HConstants.DEFAULT_HBASE_RPC_TIMEOUT;</td></tr><tr class="hit"><td class="line">94</td><td class="hits">17</td><td class="source">  this.logger = options.logger || console;</td></tr><tr class="hit"><td class="line">95</td><td class="hits">17</td><td class="source">  this.header = new ConnectionHeader(protocol, options.ticket);</td></tr><tr class="hit"><td class="line">96</td><td class="hits">17</td><td class="source">  this.setupIOstreams();</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">util.inherits(Connection, EventEmitter);</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">101</td><td class="hits">1</td><td class="source">Connection.prototype.setupConnection = function () {</td></tr><tr class="hit"><td class="line">102</td><td class="hits">17</td><td class="source">  var ioFailures = 0;</td></tr><tr class="hit"><td class="line">103</td><td class="hits">17</td><td class="source">  var timeoutFailures = 0;</td></tr><tr class="hit"><td class="line">104</td><td class="hits">17</td><td class="source">  this.socket = net.connect(this.address);</td></tr><tr class="hit"><td class="line">105</td><td class="hits">17</td><td class="source">  this.socketReadable = this.socket;</td></tr><tr class="hit"><td class="line">106</td><td class="hits">17</td><td class="source">  if (typeof this.socketReadable.read !== 'function') {</td></tr><tr class="hit"><td class="line">107</td><td class="hits">17</td><td class="source">    this.socketReadable = new Readable();</td></tr><tr class="hit"><td class="line">108</td><td class="hits">17</td><td class="source">    this.socketReadable.wrap(this.socket);</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">    // ignore error event</td></tr><tr class="hit"><td class="line">110</td><td class="hits">17</td><td class="source">    this.socketReadable.on('error', utility.noop);</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">112</td><td class="hits">17</td><td class="source">  this.socket.setNoDelay(this.tcpNoDelay);</td></tr><tr class="hit"><td class="line">113</td><td class="hits">17</td><td class="source">  this.socket.setKeepAlive(this.tcpKeepAlive);</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">  // if (this.remoteId.rpcTimeout &gt; 0) {</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  //   this.pingInterval = this.remoteId.rpcTimeout;</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  // this.socket.setTimeout(this.pingInterval);</td></tr><tr class="hit"><td class="line">118</td><td class="hits">17</td><td class="source">  this.socket.on('timeout', this.emit.bind(this, 'timeout'));</td></tr><tr class="hit"><td class="line">119</td><td class="hits">17</td><td class="source">  this.socket.on('close', this._handleClose.bind(this));</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">  // when error, response all calls error</td></tr><tr class="hit"><td class="line">122</td><td class="hits">17</td><td class="source">  this.socket.on('error', this._handleError.bind(this));</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">125</td><td class="hits">1</td><td class="source">Connection.prototype._cleanupCalls = function (err) {</td></tr><tr class="hit"><td class="line">126</td><td class="hits">14</td><td class="source">  var count = 0;</td></tr><tr class="hit"><td class="line">127</td><td class="hits">14</td><td class="source">  var calls = this.calls;</td></tr><tr class="hit"><td class="line">128</td><td class="hits">14</td><td class="source">  this.calls = {}; // should reset calls before traverse it.</td></tr><tr class="hit"><td class="line">129</td><td class="hits">14</td><td class="source">  for (var id in calls) {</td></tr><tr class="hit"><td class="line">130</td><td class="hits">9</td><td class="source">    var call = calls[id];</td></tr><tr class="hit"><td class="line">131</td><td class="hits">9</td><td class="source">    call.setException(err);</td></tr><tr class="hit"><td class="line">132</td><td class="hits">9</td><td class="source">    count++;</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">  // this.calls = {};</td></tr><tr class="hit"><td class="line">135</td><td class="hits">14</td><td class="source">  debug('conn#%d: clenaup %d calls, send &quot;%s:%s&quot; response.', this.id, count, err.name, err.message);</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">138</td><td class="hits">1</td><td class="source">Connection.prototype._handleClose = function () {</td></tr><tr class="hit"><td class="line">139</td><td class="hits">14</td><td class="source">  this.closed = true;</td></tr><tr class="hit"><td class="line">140</td><td class="hits">14</td><td class="source">  this.emit('close'); // let client close first.</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">142</td><td class="hits">14</td><td class="source">  var address = this.address;</td></tr><tr class="hit"><td class="line">143</td><td class="hits">14</td><td class="source">  var msg = '[' + new Date() + '] [WARNNING] connection#' + this.id + ' ' + address.host + ':' + address.port + ' closed.';</td></tr><tr class="hit"><td class="line">144</td><td class="hits">14</td><td class="source">  debug(msg);</td></tr><tr class="hit"><td class="line">145</td><td class="hits">14</td><td class="source">  this.logger.warn(msg);</td></tr><tr class="hit"><td class="line">146</td><td class="hits">14</td><td class="source">  var err = this._closeError || new errors.ConnectionClosedException(msg);</td></tr><tr class="hit"><td class="line">147</td><td class="hits">14</td><td class="source">  this._cleanupCalls(err);</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">150</td><td class="hits">1</td><td class="source">Connection.prototype._handleError = function (err) {</td></tr><tr class="miss"><td class="line">151</td><td class="hits">0</td><td class="source">  this._cleanupCalls(err);</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source">/** Connect to the server and set up the I/O streams. It then sends</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source"> * a header to the server and starts</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source"> * the connection thread that waits for responses.</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source"> * @throws java.io.IOException e</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">159</td><td class="hits">1</td><td class="source">Connection.prototype.setupIOstreams = function () {</td></tr><tr class="hit"><td class="line">160</td><td class="hits">17</td><td class="source">  debug(&quot;Connecting to %s&quot;, this.name);</td></tr><tr class="hit"><td class="line">161</td><td class="hits">17</td><td class="source">  this.setupConnection();</td></tr><tr class="hit"><td class="line">162</td><td class="hits">17</td><td class="source">  this.in = new DataInputStream(this.socketReadable);</td></tr><tr class="hit"><td class="line">163</td><td class="hits">17</td><td class="source">  this.out = new DataOutputStream(this.socket);</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">165</td><td class="hits">17</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">166</td><td class="hits">17</td><td class="source">  this.socket.on('connect', function () {</td></tr><tr class="hit"><td class="line">167</td><td class="hits">17</td><td class="source">    self.writeHeader();</td></tr><tr class="hit"><td class="line">168</td><td class="hits">17</td><td class="source">    self._nextResponse();</td></tr><tr class="hit"><td class="line">169</td><td class="hits">17</td><td class="source">    self.emit('connect');</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source">/* Write the header for each connection</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source"> * Out is not synchronized because only the first thread does this.</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">176</td><td class="hits">1</td><td class="source">Connection.prototype.writeHeader = function () {</td></tr><tr class="hit"><td class="line">177</td><td class="hits">17</td><td class="source">  this.out.write(HEADER);</td></tr><tr class="hit"><td class="line">178</td><td class="hits">17</td><td class="source">  this.out.writeByte(CURRENT_VERSION);</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">  //When there are more fields we can have ConnectionHeader Writable.</td></tr><tr class="hit"><td class="line">180</td><td class="hits">17</td><td class="source">  var buf = new DataOutputBuffer();</td></tr><tr class="hit"><td class="line">181</td><td class="hits">17</td><td class="source">  this.header.write(buf);</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">183</td><td class="hits">17</td><td class="source">  var bufLen = buf.getLength();</td></tr><tr class="hit"><td class="line">184</td><td class="hits">17</td><td class="source">  this.out.writeInt(bufLen);</td></tr><tr class="hit"><td class="line">185</td><td class="hits">17</td><td class="source">  this.out.write(buf.getData());</td></tr><tr><td class="line">186</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">187</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source">/* Initiates a call by sending the parameter to the remote server.</td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source"> * Note: this is not called from the Connection thread, but by other</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source"> * threads.</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">192</td><td class="hits">1</td><td class="source">Connection.prototype.sendParam = function (call) {</td></tr><tr><td class="line">193</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">  // For serializing the data to be written.</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">196</td><td class="hits">208</td><td class="source">  debug(this.name + &quot; sending #&quot; + call.id);</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">198</td><td class="hits">208</td><td class="source">  var d = new DataOutputBuffer();</td></tr><tr class="hit"><td class="line">199</td><td class="hits">208</td><td class="source">  d.writeInt(0); // placeholder for data length</td></tr><tr class="hit"><td class="line">200</td><td class="hits">208</td><td class="source">  d.writeInt(call.id);</td></tr><tr class="hit"><td class="line">201</td><td class="hits">208</td><td class="source">  call.param.write(d);</td></tr><tr class="hit"><td class="line">202</td><td class="hits">208</td><td class="source">  var data = d.getData();</td></tr><tr class="hit"><td class="line">203</td><td class="hits">208</td><td class="source">  var dataLength = d.getLength();</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">  // fill in the placeholder</td></tr><tr class="hit"><td class="line">206</td><td class="hits">208</td><td class="source">  Bytes.putInt(data, 0, dataLength - 4);</td></tr><tr class="hit"><td class="line">207</td><td class="hits">208</td><td class="source">  this.out.write(data, 0, dataLength);</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">210</td><td class="hits">1</td><td class="source">Connection.prototype._close = function (err) {</td></tr><tr class="hit"><td class="line">211</td><td class="hits">6</td><td class="source">  this.closed = true;</td></tr><tr class="hit"><td class="line">212</td><td class="hits">6</td><td class="source">  this._closeError = err;</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  // TODO: end or close?</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">  // this.socket.end();</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">  // var address = this.remoteId.getAddress();</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">  // var msg = 'socket ' + address.host + ':' + address.port + ' destroy()';</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">  // console.warn(msg);</td></tr><tr class="hit"><td class="line">218</td><td class="hits">6</td><td class="source">  this.socket.destroy();</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">220</td><td class="hits">1</td><td class="source">Connection.prototype.close = Connection.prototype._close;</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">222</td><td class="hits">1</td><td class="source">Connection.prototype._nextResponse = function () {</td></tr><tr class="hit"><td class="line">223</td><td class="hits">214</td><td class="source">  var self = this;</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">  // See HBaseServer.Call.setResponse for where we write out the response.</td></tr><tr><td class="line">225</td><td class="hits"></td><td class="source">  // It writes the call.id (int), a flag byte, then optionally the length</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source">  // of the response (int) followed by data.</td></tr><tr class="hit"><td class="line">227</td><td class="hits">214</td><td class="source">  self.in.readFields([</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">    {name: 'id', method: 'readInt'},</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">    {name: 'flag', method: 'readByte'},</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">    {name: 'size', method: 'readInt'},</td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source">  ], function (err, data) {</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">233</td><td class="hits">197</td><td class="source">    if (!data.hasOwnProperty('id') || !data.hasOwnProperty('flag') || !data.hasOwnProperty('size')) {</td></tr><tr class="miss"><td class="line">234</td><td class="hits">0</td><td class="source">      self.logger.warn('[ERROR] [%s] data format wrong: %j', new Date(), data);</td></tr><tr class="miss"><td class="line">235</td><td class="hits">0</td><td class="source">      err = new RemoteException('RemoteException', 'data packet wrong, data: ' + JSON.stringify(data));</td></tr><tr class="miss"><td class="line">236</td><td class="hits">0</td><td class="source">      self._close();</td></tr><tr class="miss"><td class="line">237</td><td class="hits">0</td><td class="source">      return;</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">240</td><td class="hits"></td><td class="source">    // Read the call id.</td></tr><tr class="hit"><td class="line">241</td><td class="hits">197</td><td class="source">    var id = data &amp;&amp; data.id;</td></tr><tr class="hit"><td class="line">242</td><td class="hits">197</td><td class="source">    var size = data.size - 9; // remove header size, Int, Byte, Int, 9 bytes</td></tr><tr class="hit"><td class="line">243</td><td class="hits">197</td><td class="source">    debug('receiveResponse: got call#%s response from %s, flag: %s, size: %s', id, self.name, data.flag, data.size);</td></tr><tr class="hit"><td class="line">244</td><td class="hits">197</td><td class="source">    var call = self.calls[id];</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">246</td><td class="hits">197</td><td class="source">    if (!call) {</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source">      // timeout remove</td></tr><tr class="miss"><td class="line">248</td><td class="hits">0</td><td class="source">      debug('[WARNNING] [%s] call#%s not exists, data: %j', new Date(), id, data);</td></tr><tr><td class="line">249</td><td class="hits"></td><td class="source">    } else {</td></tr><tr class="hit"><td class="line">250</td><td class="hits">197</td><td class="source">      delete self.calls[id];</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">    </td></tr><tr class="hit"><td class="line">253</td><td class="hits">197</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">254</td><td class="hits">0</td><td class="source">      call &amp;&amp; call.setException(err);</td></tr><tr class="miss"><td class="line">255</td><td class="hits">0</td><td class="source">      err.connection = self.name;</td></tr><tr class="miss"><td class="line">256</td><td class="hits">0</td><td class="source">      self._close();</td></tr><tr class="miss"><td class="line">257</td><td class="hits">0</td><td class="source">      return;</td></tr><tr><td class="line">258</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">    // Read the flag byte</td></tr><tr class="hit"><td class="line">261</td><td class="hits">197</td><td class="source">    var flag = data.flag;</td></tr><tr class="hit"><td class="line">262</td><td class="hits">197</td><td class="source">    var isError = ResponseFlag.isError(flag);</td></tr><tr class="hit"><td class="line">263</td><td class="hits">197</td><td class="source">    if (typeof flag !== 'number' || !ResponseFlag.isLength(flag)) {</td></tr><tr class="miss"><td class="line">264</td><td class="hits">0</td><td class="source">      err = new RemoteException('RemoteException', 'missing data length packet, flag: ' + flag);</td></tr><tr class="miss"><td class="line">265</td><td class="hits">0</td><td class="source">      err.connection = self.name;</td></tr><tr class="miss"><td class="line">266</td><td class="hits">0</td><td class="source">      call &amp;&amp; call.setException(err);</td></tr><tr class="miss"><td class="line">267</td><td class="hits">0</td><td class="source">      self._close();</td></tr><tr class="miss"><td class="line">268</td><td class="hits">0</td><td class="source">      return;</td></tr><tr><td class="line">269</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">270</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">271</td><td class="hits">197</td><td class="source">    self.in.readBytes(size, function (err, buf) {</td></tr><tr class="hit"><td class="line">272</td><td class="hits">197</td><td class="source">      var io = new DataInputBuffer(buf);</td></tr><tr><td class="line">273</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">274</td><td class="hits">197</td><td class="source">      var state = io.readInt(); // Read the state.  Currently unused.</td></tr><tr class="hit"><td class="line">275</td><td class="hits">197</td><td class="source">      if (isError) {</td></tr><tr class="hit"><td class="line">276</td><td class="hits">2</td><td class="source">        err = new RemoteException(io.readString(), io.readString());</td></tr><tr class="hit"><td class="line">277</td><td class="hits">2</td><td class="source">        err.connection = self.name;</td></tr><tr class="hit"><td class="line">278</td><td class="hits">2</td><td class="source">        call &amp;&amp; call.setException(err);</td></tr><tr class="hit"><td class="line">279</td><td class="hits">2</td><td class="source">        if (err.name === 'org.apache.hadoop.hbase.NotServingRegionException') {</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source">          // close the connection</td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source">          // TODO: reconnect</td></tr><tr class="hit"><td class="line">282</td><td class="hits">1</td><td class="source">          self._close(err);</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">284</td><td class="hits"></td><td class="source">      } else {</td></tr><tr class="hit"><td class="line">285</td><td class="hits">195</td><td class="source">        var obj = HbaseObjectWritable.readFields(io);</td></tr><tr class="hit"><td class="line">286</td><td class="hits">195</td><td class="source">        debug('call#%s got %s instance', id, obj.declaredClass);</td></tr><tr class="hit"><td class="line">287</td><td class="hits">195</td><td class="source">        call &amp;&amp; call.setValue(obj.instance);</td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source">      // RangeError: Maximum call stack size exceeded</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source">      // self._nextResponse();</td></tr><tr class="hit"><td class="line">292</td><td class="hits">197</td><td class="source">      process.nextTick(self._nextResponse.bind(self));</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">296</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">297</td><td class="hits"></td><td class="source">  </td></tr><tr><td class="line">298</td><td class="hits"></td><td class="source">// impl HRegionInterface</td></tr><tr class="hit"><td class="line">299</td><td class="hits">1</td><td class="source">Connection.prototype.call = function (method, parameters, rpcTimeout, callback) {</td></tr><tr class="hit"><td class="line">300</td><td class="hits">210</td><td class="source">  if (typeof rpcTimeout === 'function') {</td></tr><tr class="hit"><td class="line">301</td><td class="hits">201</td><td class="source">    callback = rpcTimeout;</td></tr><tr class="hit"><td class="line">302</td><td class="hits">201</td><td class="source">    rpcTimeout = null;</td></tr><tr><td class="line">303</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">304</td><td class="hits">210</td><td class="source">  rpcTimeout = rpcTimeout || this.rpcTimeout;</td></tr><tr class="hit"><td class="line">305</td><td class="hits">210</td><td class="source">  var param = new Invocation(method, parameters);</td></tr><tr class="hit"><td class="line">306</td><td class="hits">210</td><td class="source">  var call = new Call(param, rpcTimeout);</td></tr><tr class="hit"><td class="line">307</td><td class="hits">210</td><td class="source">  this.calls[call.id] = call;</td></tr><tr class="hit"><td class="line">308</td><td class="hits">210</td><td class="source">  call.on('done', callback); // TODO: handle MAX Number error response, should close the connection.</td></tr><tr><td class="line">309</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">310</td><td class="hits">210</td><td class="source">  if (this.closed) {</td></tr><tr class="hit"><td class="line">311</td><td class="hits">2</td><td class="source">    return this._handleClose();</td></tr><tr><td class="line">312</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">313</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">314</td><td class="hits">208</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">315</td><td class="hits">208</td><td class="source">  call.on('timeout', function () {</td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source">    // remove the call</td></tr><tr class="hit"><td class="line">317</td><td class="hits">4</td><td class="source">    delete self.calls[call.id];</td></tr><tr><td class="line">318</td><td class="hits"></td><td class="source">  });</td></tr><tr class="hit"><td class="line">319</td><td class="hits">208</td><td class="source">  this.sendParam(call);</td></tr><tr><td class="line">320</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">321</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">323</td><td class="hits"></td><td class="source"> * Return all the data for the row that matches &lt;i&gt;row&lt;/i&gt; exactly,</td></tr><tr><td class="line">324</td><td class="hits"></td><td class="source"> * or the one that immediately preceeds it.</td></tr><tr><td class="line">325</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">326</td><td class="hits"></td><td class="source"> * @param regionName region name</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source"> * @param row row key</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source"> * @param family Column family to look for row in.</td></tr><tr><td class="line">329</td><td class="hits"></td><td class="source"> * @return map of values</td></tr><tr><td class="line">330</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">331</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">332</td><td class="hits">1</td><td class="source">Connection.prototype.getClosestRowBefore = function (regionName, row, family, rpcTimeout, callback) {</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source">  // debug('getClosestRowBefore(`%s`, `%s`, `%s`)', regionName, row, family);</td></tr><tr class="hit"><td class="line">334</td><td class="hits">26</td><td class="source">  this.call('getClosestRowBefore', [regionName, row, family], rpcTimeout, callback);</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">336</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">337</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">338</td><td class="hits"></td><td class="source"> * Return protocol version corresponding to protocol interface.</td></tr><tr><td class="line">339</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">340</td><td class="hits"></td><td class="source"> * @param protocol The classname of the protocol interface</td></tr><tr><td class="line">341</td><td class="hits"></td><td class="source"> * @param clientVersion The version of the protocol that the client speaks</td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source"> * @return the version that the server will speak</td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source"> * @throws IOException if any IO error occurs</td></tr><tr><td class="line">344</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">345</td><td class="hits">1</td><td class="source">Connection.prototype.getProtocolVersion = function (protocol, clientVersion, rpcTimeout, callback) {</td></tr><tr class="hit"><td class="line">346</td><td class="hits">41</td><td class="source">  protocol = protocol || HConstants.PROTOCOL;</td></tr><tr class="hit"><td class="line">347</td><td class="hits">41</td><td class="source">  clientVersion = clientVersion || HConstants.CLIENT_VERSION;</td></tr><tr class="hit"><td class="line">348</td><td class="hits">41</td><td class="source">  if (!(clientVersion instanceof Long)) {</td></tr><tr class="miss"><td class="line">349</td><td class="hits">0</td><td class="source">    clientVersion = Long.fromNumber(clientVersion);</td></tr><tr><td class="line">350</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">351</td><td class="hits">41</td><td class="source">  this.call('getProtocolVersion', [protocol, clientVersion], rpcTimeout, callback);</td></tr><tr><td class="line">352</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">353</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source"> * Perform Get operation.</td></tr><tr><td class="line">356</td><td class="hits"></td><td class="source"> * @param regionName name of region to get from</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source"> * @param get Get operation</td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source"> * @return Result</td></tr><tr><td class="line">359</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">361</td><td class="hits">1</td><td class="source">Connection.prototype.get = function (regionName, get, callback) {</td></tr><tr class="hit"><td class="line">362</td><td class="hits">46</td><td class="source">  this.call('get', [regionName, get], callback);</td></tr><tr><td class="line">363</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">364</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">365</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">366</td><td class="hits"></td><td class="source"> * Put data into the specified region</td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source"> * @param regionName region name</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source"> * @param put the data to be put</td></tr><tr><td class="line">369</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">370</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">371</td><td class="hits">1</td><td class="source">Connection.prototype.put = function (regionName, put, callback) {</td></tr><tr class="hit"><td class="line">372</td><td class="hits">14</td><td class="source">  this.call('put', [regionName, put], callback);</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">375</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">376</td><td class="hits"></td><td class="source"> * Delete data from the specified region</td></tr><tr><td class="line">377</td><td class="hits"></td><td class="source"> * @param regionName region name</td></tr><tr><td class="line">378</td><td class="hits"></td><td class="source"> * @param put the data to be put</td></tr><tr><td class="line">379</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">380</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">381</td><td class="hits">1</td><td class="source">Connection.prototype.delete = function (regionName, del, callback) {</td></tr><tr class="hit"><td class="line">382</td><td class="hits">6</td><td class="source">  this.call('delete', [regionName, del], callback);</td></tr><tr><td class="line">383</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">384</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">385</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source"> * Opens a remote scanner with a RowFilter.</td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source"> * @param regionName name of region to scan</td></tr><tr><td class="line">389</td><td class="hits"></td><td class="source"> * @param scan configured scan object</td></tr><tr><td class="line">390</td><td class="hits"></td><td class="source"> * @return scannerId scanner identifier used in other calls</td></tr><tr><td class="line">391</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">393</td><td class="hits">1</td><td class="source">Connection.prototype.openScanner = function (regionName, scan, callback) {</td></tr><tr class="hit"><td class="line">394</td><td class="hits">12</td><td class="source">  this.call('openScanner', [regionName, scan], callback);</td></tr><tr><td class="line">395</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">397</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">398</td><td class="hits"></td><td class="source"> * Get the next set of values</td></tr><tr><td class="line">399</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">400</td><td class="hits"></td><td class="source"> * @param scannerId clientId passed to openScanner</td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source"> * @return map of values; returns null if no results.</td></tr><tr><td class="line">402</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">403</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">404</td><td class="hits"></td><td class="source">// Connection.prototype.next = function (scannerId, callback) {</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source">//   this.call('next', [scannerId], callback);</td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source">// };</td></tr><tr><td class="line">407</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">408</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">409</td><td class="hits"></td><td class="source"> * Get the next set of values</td></tr><tr><td class="line">410</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source"> * @param scannerId clientId passed to openScanner</td></tr><tr><td class="line">412</td><td class="hits"></td><td class="source"> * @param [numberOfRows] the number of rows to fetch</td></tr><tr><td class="line">413</td><td class="hits"></td><td class="source"> * @return Array of Results (map of values); array is empty if done with this</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source"> * region and null if we are NOT to go to the next region (happens when a</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source"> * filter rules that the scan is done).</td></tr><tr><td class="line">416</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">417</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">418</td><td class="hits">1</td><td class="source">Connection.prototype.nextResult = function (scannerId, numberOfRows, callback) {</td></tr><tr class="hit"><td class="line">419</td><td class="hits">53</td><td class="source">  if (typeof numberOfRows === 'function') {</td></tr><tr class="hit"><td class="line">420</td><td class="hits">32</td><td class="source">    callback = numberOfRows;</td></tr><tr class="hit"><td class="line">421</td><td class="hits">32</td><td class="source">    numberOfRows = null;</td></tr><tr><td class="line">422</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">423</td><td class="hits">53</td><td class="source">  var params = [scannerId];</td></tr><tr class="hit"><td class="line">424</td><td class="hits">53</td><td class="source">  if (numberOfRows) {</td></tr><tr class="hit"><td class="line">425</td><td class="hits">21</td><td class="source">    params.push(numberOfRows);</td></tr><tr><td class="line">426</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">427</td><td class="hits">53</td><td class="source">  this.call('next', params, callback);</td></tr><tr><td class="line">428</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">429</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">430</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">431</td><td class="hits"></td><td class="source"> * Close a scanner</td></tr><tr><td class="line">432</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">433</td><td class="hits"></td><td class="source"> * @param scannerId the scanner id returned by openScanner</td></tr><tr><td class="line">434</td><td class="hits"></td><td class="source"> * @throws IOException e</td></tr><tr><td class="line">435</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">436</td><td class="hits">1</td><td class="source">Connection.prototype.closeScanner = function (scannerId, callback) {</td></tr><tr class="hit"><td class="line">437</td><td class="hits">12</td><td class="source">  this.call('close', [scannerId], callback);</td></tr><tr><td class="line">438</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">439</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">440</td><td class="hits">1</td><td class="source">Connection.Call_Counter = 0;</td></tr><tr><td class="line">441</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">442</td><td class="hits"></td><td class="source">/** A call waiting for a value. */</td></tr><tr class="hit"><td class="line">443</td><td class="hits">1</td><td class="source">function Call(param, timeout) {</td></tr><tr class="hit"><td class="line">444</td><td class="hits">210</td><td class="source">  EventEmitter.call(this);</td></tr><tr class="hit"><td class="line">445</td><td class="hits">210</td><td class="source">  this.id = Connection.Call_Counter++; // call id</td></tr><tr class="hit"><td class="line">446</td><td class="hits">210</td><td class="source">  this.param = param; // parameter</td></tr><tr class="hit"><td class="line">447</td><td class="hits">210</td><td class="source">  this.value = null; // value, null if error</td></tr><tr class="hit"><td class="line">448</td><td class="hits">210</td><td class="source">  this.error = null; // exception, null if value</td></tr><tr class="hit"><td class="line">449</td><td class="hits">210</td><td class="source">  this.done = false; // true when call is done</td></tr><tr class="hit"><td class="line">450</td><td class="hits">210</td><td class="source">  this.startTime = Date.now();</td></tr><tr><td class="line">451</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">452</td><td class="hits">210</td><td class="source">  this.timeout = timeout;</td></tr><tr class="hit"><td class="line">453</td><td class="hits">210</td><td class="source">  if (timeout &amp;&amp; timeout &gt; 0) {</td></tr><tr class="hit"><td class="line">454</td><td class="hits">210</td><td class="source">    this.timer = setTimeout(this._handleTimeout.bind(this), timeout);</td></tr><tr><td class="line">455</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">456</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">457</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">458</td><td class="hits">1</td><td class="source">util.inherits(Call, EventEmitter);</td></tr><tr><td class="line">459</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">460</td><td class="hits">1</td><td class="source">Call.prototype._handleTimeout = function () {</td></tr><tr class="hit"><td class="line">461</td><td class="hits">4</td><td class="source">  var err = new errors.RemoteCallTimeoutException(this.timeout + ' ms timeout');</td></tr><tr class="hit"><td class="line">462</td><td class="hits">4</td><td class="source">  this.setException(err);</td></tr><tr class="hit"><td class="line">463</td><td class="hits">4</td><td class="source">  this.emit('timeout');</td></tr><tr><td class="line">464</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">465</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">466</td><td class="hits"></td><td class="source">/** Indicate when the call is complete and the</td></tr><tr><td class="line">467</td><td class="hits"></td><td class="source"> * value or error are available.  Notifies by default.  */</td></tr><tr class="hit"><td class="line">468</td><td class="hits">1</td><td class="source">Call.prototype.callComplete = function () {</td></tr><tr class="hit"><td class="line">469</td><td class="hits">210</td><td class="source">  if (this.timer) {</td></tr><tr class="hit"><td class="line">470</td><td class="hits">210</td><td class="source">    clearTimeout(this.timer);</td></tr><tr><td class="line">471</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">472</td><td class="hits">210</td><td class="source">  if (this.done) {</td></tr><tr><td class="line">473</td><td class="hits"></td><td class="source">    // if done before, do not emit done again</td></tr><tr class="miss"><td class="line">474</td><td class="hits">0</td><td class="source">    return;</td></tr><tr><td class="line">475</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">476</td><td class="hits">210</td><td class="source">  this.done = true;</td></tr><tr class="hit"><td class="line">477</td><td class="hits">210</td><td class="source">  if (debug.enabled) {</td></tr><tr class="miss"><td class="line">478</td><td class="hits">0</td><td class="source">    debug('call#%d use %d ms', this.id, Date.now() - this.startTime);</td></tr><tr><td class="line">479</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">480</td><td class="hits">210</td><td class="source">  this.emit('done', this.error, this.value);</td></tr><tr><td class="line">481</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">482</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">483</td><td class="hits"></td><td class="source">/** Set the exception when there is an error.</td></tr><tr><td class="line">484</td><td class="hits"></td><td class="source"> * Notify the caller the call is done.</td></tr><tr><td class="line">485</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">486</td><td class="hits"></td><td class="source"> * @param error exception thrown by the call; either local or remote</td></tr><tr><td class="line">487</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">488</td><td class="hits">1</td><td class="source">Call.prototype.setException = function (err) {</td></tr><tr class="hit"><td class="line">489</td><td class="hits">15</td><td class="source">  debug('call#%s error: %s', this.id, err.message);</td></tr><tr class="hit"><td class="line">490</td><td class="hits">15</td><td class="source">  this.error = err;</td></tr><tr class="hit"><td class="line">491</td><td class="hits">15</td><td class="source">  this.callComplete();</td></tr><tr><td class="line">492</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">493</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">494</td><td class="hits"></td><td class="source">/** Set the return value when there is no error.</td></tr><tr><td class="line">495</td><td class="hits"></td><td class="source"> * Notify the caller the call is done.</td></tr><tr><td class="line">496</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">497</td><td class="hits"></td><td class="source"> * @param value return value of the call.</td></tr><tr><td class="line">498</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">499</td><td class="hits">1</td><td class="source">Call.prototype.setValue = function (value) {</td></tr><tr class="hit"><td class="line">500</td><td class="hits">195</td><td class="source">  this.value = value;</td></tr><tr class="hit"><td class="line">501</td><td class="hits">195</td><td class="source">  this.callComplete();</td></tr><tr><td class="line">502</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">503</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">504</td><td class="hits">1</td><td class="source">Call.prototype.getStartTime = function () {</td></tr><tr class="miss"><td class="line">505</td><td class="hits">0</td><td class="source">  return this.startTime;</td></tr><tr><td class="line">506</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">507</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">508</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">509</td><td class="hits">1</td><td class="source">module.exports = Connection;</td></tr><tr><td class="line">510</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/data_input_buffer.js">/Users/mk2/git/node-hbase-client/lib/data_input_buffer.js</h2><div id="stats" class="medium"><div class="percentage">70%</div><div class="sloc">50</div><div class="hits">35</div><div class="misses">15</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/data_input_buffer.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var DataInputStream = require('./data_input_stream');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var NegativeArraySizeException = require('./errors').NegativeArraySizeException;</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">function InputBuffer(buf) {</td></tr><tr class="hit"><td class="line">18</td><td class="hits">482</td><td class="source">  this.buf = buf;</td></tr><tr class="hit"><td class="line">19</td><td class="hits">482</td><td class="source">  this.offset = 0;</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">InputBuffer.prototype.read = function (size) {</td></tr><tr class="hit"><td class="line">23</td><td class="hits">5845</td><td class="source">  var offset = this.offset;</td></tr><tr class="hit"><td class="line">24</td><td class="hits">5845</td><td class="source">  var end = offset + size;</td></tr><tr class="hit"><td class="line">25</td><td class="hits">5845</td><td class="source">  this.offset = end;</td></tr><tr class="hit"><td class="line">26</td><td class="hits">5845</td><td class="source">  return this.buf.slice(offset, end);</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">function DataInputBuffer(buf) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">482</td><td class="source">  this.in = new InputBuffer(buf);</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">}</td></tr><tr class="hit"><td class="line">32</td><td class="hits">1</td><td class="source">util.inherits(DataInputBuffer, DataInputStream);</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> * Read a String as a Network Int n, followed by n Bytes</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> * Alternative to 16 bit read/writeUTF.</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> * Encoding standard is... ?</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">39</td><td class="hits">1</td><td class="source">DataInputBuffer.prototype.readString = function () {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">4</td><td class="source">  var length = this.readInt();</td></tr><tr class="hit"><td class="line">41</td><td class="hits">4</td><td class="source">  if (length === -1) {</td></tr><tr class="miss"><td class="line">42</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">45</td><td class="hits">4</td><td class="source">  return this.read(length).toString('utf8');</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">/** Read a UTF8 encoded string from in equal to Text.readString()</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">50</td><td class="hits">1</td><td class="source">DataInputBuffer.prototype.readVString = function () {</td></tr><tr class="miss"><td class="line">51</td><td class="hits">0</td><td class="source">  var length = this.readVInt();</td></tr><tr class="miss"><td class="line">52</td><td class="hits">0</td><td class="source">  return this.read(length).toString('utf8');</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> * Given the first byte of a vint/vlong, determine the sign</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> * @param value the first byte</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> * @return is the value negative</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">61</td><td class="hits">1</td><td class="source">DataInputBuffer.isNegativeVInt = function (value) {</td></tr><tr class="miss"><td class="line">62</td><td class="hits">0</td><td class="source">  return value &lt; -120 || (value &gt;= -112 &amp;&amp; value &lt; 0);</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * Parse the first byte of a vint/vlong to determine the number of bytes</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * @param value the first byte of the vint/vlong</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * @return the total number of bytes (1 to 9)</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">71</td><td class="hits">1</td><td class="source">DataInputBuffer.decodeVIntSize = function (value) {</td></tr><tr class="hit"><td class="line">72</td><td class="hits">1402</td><td class="source">  if (value &gt;= -112) {</td></tr><tr class="hit"><td class="line">73</td><td class="hits">1402</td><td class="source">    return 1;</td></tr><tr class="miss"><td class="line">74</td><td class="hits">0</td><td class="source">  } else if (value &lt; -120) {</td></tr><tr class="miss"><td class="line">75</td><td class="hits">0</td><td class="source">    return -119 - value;</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">77</td><td class="hits">0</td><td class="source">  return -111 - value;</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> * Reads a zero-compressed encoded long from input stream and returns it.</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> * @return deserialized long from stream.</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">85</td><td class="hits">1</td><td class="source">DataInputBuffer.prototype.readVLong = function () {</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  // TODO: support Long</td></tr><tr class="hit"><td class="line">87</td><td class="hits">1402</td><td class="source">  var firstByte = this.readByte();</td></tr><tr class="hit"><td class="line">88</td><td class="hits">1402</td><td class="source">  var len = DataInputBuffer.decodeVIntSize(firstByte);</td></tr><tr class="hit"><td class="line">89</td><td class="hits">1402</td><td class="source">  if (len === 1) {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1402</td><td class="source">    return firstByte;</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">92</td><td class="hits">0</td><td class="source">  var size = len - 1;</td></tr><tr class="miss"><td class="line">93</td><td class="hits">0</td><td class="source">  var buf = this.read(size);</td></tr><tr class="miss"><td class="line">94</td><td class="hits">0</td><td class="source">  var i = 0;</td></tr><tr class="miss"><td class="line">95</td><td class="hits">0</td><td class="source">  for (var idx = 0; idx &lt; size; idx++) {</td></tr><tr class="miss"><td class="line">96</td><td class="hits">0</td><td class="source">    var b = buf[idx];</td></tr><tr class="miss"><td class="line">97</td><td class="hits">0</td><td class="source">    i = i &lt;&lt; 8;</td></tr><tr class="miss"><td class="line">98</td><td class="hits">0</td><td class="source">    i = i | (b &amp; 0xFF);</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">100</td><td class="hits">0</td><td class="source">  return DataInputBuffer.isNegativeVInt(firstByte) ? (i ^ -1) : i;</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> * Reads a zero-compressed encoded integer from input stream and returns it.</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> * @return deserialized integer from stream.</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1</td><td class="source">DataInputBuffer.prototype.readVInt = function () {</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1402</td><td class="source">  return this.readVLong();</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> * Read byte-array written with a WritableableUtils.vint prefix.</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> * @return byte array read off `this.in`.</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">117</td><td class="hits">1</td><td class="source">DataInputBuffer.prototype.readByteArray = function () {</td></tr><tr class="hit"><td class="line">118</td><td class="hits">1077</td><td class="source">  var len = this.readVInt();</td></tr><tr class="hit"><td class="line">119</td><td class="hits">1077</td><td class="source">  return this.in.read(len);</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">123</td><td class="hits">1</td><td class="source">module.exports = DataInputBuffer;</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/data_input_stream.js">/Users/mk2/git/node-hbase-client/lib/data_input_stream.js</h2><div id="stats" class="high"><div class="percentage">96%</div><div class="sloc">55</div><div class="hits">53</div><div class="misses">2</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/data_input_stream.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var debug = require('debug')('hbase:data_input_stream');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Readable = require('readable-stream').Readable;</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">function DataInputStream(io) {</td></tr><tr class="hit"><td class="line">19</td><td class="hits">58</td><td class="source">  this.in = io;</td></tr><tr class="hit"><td class="line">20</td><td class="hits">58</td><td class="source">  if (typeof io.read !== 'function') {</td></tr><tr class="hit"><td class="line">21</td><td class="hits">41</td><td class="source">    this.in = new Readable();</td></tr><tr class="hit"><td class="line">22</td><td class="hits">41</td><td class="source">    this.in.wrap(io);</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">24</td><td class="hits">58</td><td class="source">  this.bytearr = new Buffer(80);</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">27</td><td class="hits">1</td><td class="source">DataInputStream.prototype.read = function (b, callback) {</td></tr><tr class="hit"><td class="line">28</td><td class="hits">723</td><td class="source">  return this.in.read(b, 0, b.length);</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readBytes = function (size, callback) {</td></tr><tr class="hit"><td class="line">32</td><td class="hits">269</td><td class="source">  var buf = this.in.read(size);</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  // debug('readBytes: %d size, Got %s', size, buf ? 'Buffer' : null);</td></tr><tr class="hit"><td class="line">34</td><td class="hits">269</td><td class="source">  if (buf === null) {</td></tr><tr class="hit"><td class="line">35</td><td class="hits">72</td><td class="source">    return this.in.once('readable', this.readBytes.bind(this, size, callback));</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">37</td><td class="hits">197</td><td class="source">  callback(null, buf);</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">40</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readFields = function (fields, callback, startIndex) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">467</td><td class="source">  var self = this;</td></tr><tr class="hit"><td class="line">42</td><td class="hits">467</td><td class="source">  var lastError = null;</td></tr><tr class="hit"><td class="line">43</td><td class="hits">467</td><td class="source">  var data = {};</td></tr><tr class="hit"><td class="line">44</td><td class="hits">467</td><td class="source">  var next = function (index) {</td></tr><tr class="hit"><td class="line">45</td><td class="hits">1099</td><td class="source">    if (index === fields.length) {</td></tr><tr class="hit"><td class="line">46</td><td class="hits">238</td><td class="source">      return callback(lastError, data);</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">48</td><td class="hits">861</td><td class="source">    var field = fields[index];</td></tr><tr class="hit"><td class="line">49</td><td class="hits">861</td><td class="source">    var nextIndex = index + 1;</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">51</td><td class="hits">861</td><td class="source">    var value = self[field.method]();</td></tr><tr class="hit"><td class="line">52</td><td class="hits">861</td><td class="source">    debug('readFields: %s index %d, name: %s, got %s', field.method, index, field.name, value);</td></tr><tr class="hit"><td class="line">53</td><td class="hits">861</td><td class="source">    if (value === null) {</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">      // TODO: listeners too much</td></tr><tr class="hit"><td class="line">55</td><td class="hits">229</td><td class="source">      return self.in.once('readable', self.readFields.bind(self, fields, callback, index));</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">57</td><td class="hits">632</td><td class="source">    data[field.name] = value;</td></tr><tr class="hit"><td class="line">58</td><td class="hits">632</td><td class="source">    next(nextIndex);</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  };</td></tr><tr class="hit"><td class="line">60</td><td class="hits">467</td><td class="source">  startIndex = startIndex || 0;</td></tr><tr class="hit"><td class="line">61</td><td class="hits">467</td><td class="source">  next(startIndex);</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * See the general contract of the &lt;code&gt;readFully&lt;/code&gt;</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * Bytes</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * for this operation are read from the contained</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> * input stream.</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> * @param      len   the number of bytes to read.</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">74</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readFully = function (len, callback) {</td></tr><tr class="hit"><td class="line">75</td><td class="hits">23</td><td class="source">  var buf = this.in.read(len);</td></tr><tr class="hit"><td class="line">76</td><td class="hits">23</td><td class="source">  if (buf === null) {</td></tr><tr class="miss"><td class="line">77</td><td class="hits">0</td><td class="source">    return this.in.once('readable', this.readFully.bind(this, len, callback));</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">79</td><td class="hits">23</td><td class="source">  callback(null, buf);</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> * See the general contract of the &lt;code&gt;readBoolean&lt;/code&gt;</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> * Bytes for this operation are read from the contained</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> * input stream.</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * @return     the &lt;code&gt;boolean&lt;/code&gt; value read.</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readBoolean = function () {</td></tr><tr class="hit"><td class="line">92</td><td class="hits">552</td><td class="source">  var buf = this.in.read(1);</td></tr><tr class="hit"><td class="line">93</td><td class="hits">552</td><td class="source">  return buf ? buf[0] !== 0 : null;</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> * See the general contract of the &lt;code&gt;readByte&lt;/code&gt;</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * Bytes</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> * for this operation are read from the contained</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> * input stream.</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> * @return     the next byte of this input stream as a signed 8-bit</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> *             &lt;code&gt;byte&lt;/code&gt;.</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">107</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readByte = function () {</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1972</td><td class="source">  var buf = this.in.read(1);</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1972</td><td class="source">  return buf ? buf.readInt8(0) : null;</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> * See the general contract of the &lt;code&gt;readInt&lt;/code&gt;</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> * Bytes</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> * for this operation are read from the contained</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> * input stream.</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> * @return     the next four bytes of this input stream, interpreted as an</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> *             &lt;code&gt;int&lt;/code&gt;.</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">123</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readInt = function () {</td></tr><tr class="hit"><td class="line">124</td><td class="hits">2046</td><td class="source">  var buf = this.in.read(4);</td></tr><tr class="hit"><td class="line">125</td><td class="hits">2046</td><td class="source">  return buf ? buf.readInt32BE(0) : null;</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> * See the general contract of the &lt;code&gt;readLong&lt;/code&gt;</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> * method of &lt;code&gt;DataInput&lt;/code&gt;.</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> * Bytes</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> * for this operation are read from the contained</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> * input stream.</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> * @return     the next eight bytes of this input stream, interpreted as a</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> *             &lt;code&gt;long&lt;/code&gt;.</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">139</td><td class="hits">1</td><td class="source">DataInputStream.prototype.readLong = function () {</td></tr><tr class="hit"><td class="line">140</td><td class="hits">332</td><td class="source">  var buf = this.in.read(8);</td></tr><tr class="hit"><td class="line">141</td><td class="hits">332</td><td class="source">  if (buf === null) {</td></tr><tr class="miss"><td class="line">142</td><td class="hits">0</td><td class="source">    return buf;</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">144</td><td class="hits">332</td><td class="source">  return WritableUtils.toLong(buf);</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">148</td><td class="hits">1</td><td class="source">module.exports = DataInputStream;</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/data_output_buffer.js">/Users/mk2/git/node-hbase-client/lib/data_output_buffer.js</h2><div id="stats" class="high"><div class="percentage">92%</div><div class="sloc">27</div><div class="hits">25</div><div class="misses">2</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/data_output_buffer.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var DataOutputStream = require('./data_output_stream');</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">function DataBuffer() {</td></tr><tr class="hit"><td class="line">20</td><td class="hits">424</td><td class="source">  this.datas = [];</td></tr><tr class="hit"><td class="line">21</td><td class="hits">424</td><td class="source">  this.length = 0;</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">DataBuffer.prototype.write = function (b) {</td></tr><tr class="hit"><td class="line">25</td><td class="hits">4296</td><td class="source">  this.datas.push(b);</td></tr><tr class="hit"><td class="line">26</td><td class="hits">4296</td><td class="source">  this.length += b.length;</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">function DataOutputBuffer() {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">424</td><td class="source">  this.buf = new DataBuffer();</td></tr><tr class="hit"><td class="line">31</td><td class="hits">424</td><td class="source">  DataOutputBuffer.super_.call(this, this.buf, this.constructor);</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">}</td></tr><tr class="hit"><td class="line">33</td><td class="hits">1</td><td class="source">util.inherits(DataOutputBuffer, DataOutputStream);</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">35</td><td class="hits">1</td><td class="source">DataOutputBuffer.prototype.getData = function () {</td></tr><tr class="hit"><td class="line">36</td><td class="hits">424</td><td class="source">  return Buffer.concat(this.buf.datas, this.buf.length);</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">39</td><td class="hits">1</td><td class="source">DataOutputBuffer.prototype.getLength = function () {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">225</td><td class="source">  return this.buf.length;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">43</td><td class="hits">1</td><td class="source">DataOutputBuffer.prototype.writeString = function (s) {</td></tr><tr class="hit"><td class="line">44</td><td class="hits">8</td><td class="source">  if (!s) {</td></tr><tr class="miss"><td class="line">45</td><td class="hits">0</td><td class="source">    return this.writeInt(-1);</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">47</td><td class="hits">8</td><td class="source">  if (typeof s === 'string') {</td></tr><tr class="miss"><td class="line">48</td><td class="hits">0</td><td class="source">    s = new Buffer(s, 'utf8');</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">50</td><td class="hits">8</td><td class="source">  this.writeInt(s.length);</td></tr><tr class="hit"><td class="line">51</td><td class="hits">8</td><td class="source">  return this.write(s);</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">55</td><td class="hits">1</td><td class="source">module.exports = DataOutputBuffer;</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/data_output_stream.js">/Users/mk2/git/node-hbase-client/lib/data_output_stream.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">47</div><div class="hits">47</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/data_output_stream.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">function DataOutputStream(out) {</td></tr><tr class="hit"><td class="line">17</td><td class="hits">441</td><td class="source">  this.out = out;</td></tr><tr class="hit"><td class="line">18</td><td class="hits">441</td><td class="source">  this.written = 0;</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.incCount = function (size) {</td></tr><tr class="hit"><td class="line">22</td><td class="hits">4572</td><td class="source">  this.written += size;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.write = function (b, offset, length) {</td></tr><tr class="hit"><td class="line">26</td><td class="hits">4572</td><td class="source">  length = length === undefined ? b.length : length;</td></tr><tr class="hit"><td class="line">27</td><td class="hits">4572</td><td class="source">  if (offset !== undefined) {</td></tr><tr class="hit"><td class="line">28</td><td class="hits">670</td><td class="source">    b = b.slice(offset, offset + length);</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">31</td><td class="hits">4572</td><td class="source">  this.out.write(b);</td></tr><tr class="hit"><td class="line">32</td><td class="hits">4572</td><td class="source">  this.incCount(length);</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> * Writes out a &lt;code&gt;byte&lt;/code&gt; to the underlying output stream as </td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> * a 1-byte value. If no exception is thrown, the counter </td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;1&lt;/code&gt;.</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> * @param      v   a &lt;code&gt;byte&lt;/code&gt; value to be written.</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">42</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeByte = function (v) {</td></tr><tr class="hit"><td class="line">43</td><td class="hits">1586</td><td class="source">  if (!Buffer.isBuffer(v)) {</td></tr><tr class="hit"><td class="line">44</td><td class="hits">1586</td><td class="source">    v = new Buffer([v]);</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">46</td><td class="hits">1586</td><td class="source">  this.write(v);</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> * Writes a &lt;code&gt;boolean&lt;/code&gt; to the underlying output stream as </td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> * a 1-byte value. The value &lt;code&gt;true&lt;/code&gt; is written out as the </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> * value &lt;code&gt;(byte)1&lt;/code&gt;; the value &lt;code&gt;false&lt;/code&gt; is </td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> * written out as the value &lt;code&gt;(byte)0&lt;/code&gt;. If no exception is </td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> * thrown, the counter &lt;code&gt;written&lt;/code&gt; is incremented by </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> * &lt;code&gt;1&lt;/code&gt;.</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> * @param      v   a &lt;code&gt;boolean&lt;/code&gt; value to be written.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeBoolean = function (v) {</td></tr><tr class="hit"><td class="line">60</td><td class="hits">271</td><td class="source">  this.writeByte(v ? 1 : 0);</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * Writes a &lt;code&gt;short&lt;/code&gt; to the underlying output stream as two</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * bytes, high byte first. If no exception is thrown, the counter </td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * @param      v   a &lt;code&gt;short&lt;/code&gt; to be written.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">70</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeShort = function (v) {</td></tr><tr class="hit"><td class="line">71</td><td class="hits">20</td><td class="source">  this.writeChar(v);</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> * Writes a &lt;code&gt;char&lt;/code&gt; to the underlying output stream as a </td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> * 2-byte value, high byte first. If no exception is thrown, the </td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> * counter &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;2&lt;/code&gt;.</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> * @param      v   a &lt;code&gt;char&lt;/code&gt; value to be written.</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeChar = function (v) {</td></tr><tr class="hit"><td class="line">82</td><td class="hits">40</td><td class="source">  var buf = new Buffer(2);</td></tr><tr class="hit"><td class="line">83</td><td class="hits">40</td><td class="source">  buf.writeInt16BE(v, 0, true);</td></tr><tr class="hit"><td class="line">84</td><td class="hits">40</td><td class="source">  this.write(buf);</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * Writes an &lt;code&gt;int&lt;/code&gt; to the underlying output stream as four</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * bytes, high byte first. If no exception is thrown, the counter </td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;4&lt;/code&gt;.</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> * @param      v   an &lt;code&gt;int&lt;/code&gt; to be written.</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">94</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeInt = function (v) {</td></tr><tr class="hit"><td class="line">95</td><td class="hits">1322</td><td class="source">  var buf = new Buffer(4);</td></tr><tr class="hit"><td class="line">96</td><td class="hits">1322</td><td class="source">  buf.writeInt32BE(v, 0);</td></tr><tr class="hit"><td class="line">97</td><td class="hits">1322</td><td class="source">  this.write(buf);</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">100</td><td class="hits">1</td><td class="source">var ZERO_LONG_BUFFER = new Buffer([0, 0, 0, 0, 0, 0, 0, 0]);</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">102</td><td class="hits">1</td><td class="source">var MAX_INT32 = 4294967295;</td></tr><tr class="hit"><td class="line">103</td><td class="hits">1</td><td class="source">var MIN_INT32 = -4294967296;</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">// var MAX_NUMBER = 9007199254740992;</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source"> * Writes a &lt;code&gt;long&lt;/code&gt; to the underlying output stream as eight</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> * bytes, high byte first. In no exception is thrown, the counter </td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source"> * &lt;code&gt;written&lt;/code&gt; is incremented by &lt;code&gt;8&lt;/code&gt;.</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> * @param      v   a &lt;code&gt;long&lt;/code&gt; to be written.</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">113</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeLong = function (v) {</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">  // In Javascript, numbers are 64 bit floating point values. </td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  // The largest integer (magnitude) is 253, or Math.pow(2,53), or 9007199254740992.</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  // Bitwise Operators: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  // v should below MAX_INT32.</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">  //</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">  // 32 -Math.pow(2,31) ~ Math.pow(2,31)-1  -21474836482147483647,</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">  //  js 64 2147483647 </td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">  // ,32321()</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">  // </td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">  // 3231 32</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">  </td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">  // java code</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">  // writeBuffer[0] = v &gt;&gt;&gt; 56;</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">  // writeBuffer[1] = v &gt;&gt;&gt; 48;</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">  // writeBuffer[2] = v &gt;&gt;&gt; 40;</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">  // writeBuffer[3] = v &gt;&gt;&gt; 32;</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">  // writeBuffer[4] = v &gt;&gt;&gt; 24;</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">  // writeBuffer[5] = v &gt;&gt;&gt; 16;</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">  // writeBuffer[6] = v &gt;&gt;&gt;  8;</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source">  // writeBuffer[7] = v &gt;&gt;&gt;  0;</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">135</td><td class="hits">623</td><td class="source">  if (v === 0) {</td></tr><tr class="hit"><td class="line">136</td><td class="hits">107</td><td class="source">    this.write(ZERO_LONG_BUFFER);</td></tr><tr class="hit"><td class="line">137</td><td class="hits">107</td><td class="source">    return;</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">140</td><td class="hits">516</td><td class="source">  this.write(WritableUtils.toLongBytes(v));</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">143</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeBytes = function (bytes) {</td></tr><tr class="hit"><td class="line">144</td><td class="hits">23</td><td class="source">  this.write(bytes);</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source"> * Writes a string to the specified DataOutput using</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> * &lt;a href=&quot;DataInput.html#modified-utf-8&quot;&gt;modified UTF-8&lt;/a&gt;</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> * encoding in a machine-independent manner. </td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> * First, two bytes are written to out as if by the &lt;code&gt;writeShort&lt;/code&gt;</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> * method giving the number of bytes to follow. This value is the number of</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source"> * bytes actually written out, not the length of the string. Following the</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source"> * length, each character of the string is output, in sequence, using the</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source"> * modified UTF-8 encoding for the character. If no exception is thrown, the</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source"> * counter &lt;code&gt;written&lt;/code&gt; is incremented by the total number of </td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source"> * bytes written to the output stream. This will be at least two </td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> * plus the length of &lt;code&gt;str&lt;/code&gt;, and at most two plus </td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> * thrice the length of &lt;code&gt;str&lt;/code&gt;.</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source"> * @param      str   a string to be written.</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source"> * @return     The number of bytes written out.</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">165</td><td class="hits">1</td><td class="source">DataOutputStream.prototype.writeUTF = function (str) {</td></tr><tr class="hit"><td class="line">166</td><td class="hits">210</td><td class="source">  var buf = new Buffer(str);</td></tr><tr class="hit"><td class="line">167</td><td class="hits">210</td><td class="source">  var data = new Buffer(buf.length + 2);</td></tr><tr class="hit"><td class="line">168</td><td class="hits">210</td><td class="source">  data.writeInt16BE(buf.length, 0);</td></tr><tr class="hit"><td class="line">169</td><td class="hits">210</td><td class="source">  buf.copy(data, 2);</td></tr><tr class="hit"><td class="line">170</td><td class="hits">210</td><td class="source">  this.write(data);</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">174</td><td class="hits">1</td><td class="source">module.exports = DataOutputStream;</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/delete.js">/Users/mk2/git/node-hbase-client/lib/delete.js</h2><div id="stats" class="high"><div class="percentage">87%</div><div class="sloc">72</div><div class="hits">63</div><div class="misses">9</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/delete.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 tangyao&lt;tangyao@alibaba-inc.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">'use strict';</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">9</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">10</td><td class="hits">1</td><td class="source">var errors = require('./errors');</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">var KeyValue = require('./keyvalue');</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var OperationWithAttributes = require('./operation_with_attributes');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var DELETE_VERSION = 3;</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> * Create a Delete operation for the specified row and timestamp, using</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> * an optional row lock.&lt;p&gt;</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * If no further operations are done, this will delete all columns in all</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * families of the specified row with a timestamp less than or equal to the</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * specified timestamp.&lt;p&gt;</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> * This timestamp is ONLY used for a delete row operation.  If specifying</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> * families or columns, you must specify each timestamp individually.</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> * @param {byte []} row row key</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> * @param {long} timestamp maximum version timestamp (only for delete row)</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> * @param {RowLock} rowLock previously acquired row lock, or null</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">32</td><td class="hits">1</td><td class="source">function Delete(row, timestamp, rowLock) {</td></tr><tr class="hit"><td class="line">33</td><td class="hits">6</td><td class="source">  OperationWithAttributes.call(this);</td></tr><tr class="hit"><td class="line">34</td><td class="hits">6</td><td class="source">  if (row &amp;&amp; !Buffer.isBuffer(row)) {</td></tr><tr class="hit"><td class="line">35</td><td class="hits">6</td><td class="source">    row = Bytes.toBytes(row);</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">37</td><td class="hits">6</td><td class="source">  if (row === null || row.length &gt; HConstants.MAX_ROW_LENGTH) {</td></tr><tr class="miss"><td class="line">38</td><td class="hits">0</td><td class="source">    throw new errors.IllegalArgumentException(&quot;Row key is invalid&quot;);</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">40</td><td class="hits">6</td><td class="source">  this.row = row;</td></tr><tr class="hit"><td class="line">41</td><td class="hits">6</td><td class="source">  this.ts = timestamp || HConstants.LATEST_TIMESTAMP;</td></tr><tr class="hit"><td class="line">42</td><td class="hits">6</td><td class="source">  this.lockId = -1;</td></tr><tr class="hit"><td class="line">43</td><td class="hits">6</td><td class="source">  if (rowLock != null) {</td></tr><tr class="miss"><td class="line">44</td><td class="hits">0</td><td class="source">    this.lockId = rowLock.getLockId();</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">46</td><td class="hits">6</td><td class="source">  this.familyMap = {};</td></tr><tr class="hit"><td class="line">47</td><td class="hits">6</td><td class="source">  this.writeToWAL = true;</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">50</td><td class="hits">1</td><td class="source">util.inherits(Delete, OperationWithAttributes);</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">52</td><td class="hits">1</td><td class="source">Delete.prototype.getRow = function () {</td></tr><tr class="hit"><td class="line">53</td><td class="hits">6</td><td class="source">  return this.row;</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> * Set the timestamp of the delete.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> * @param {long} timestamp</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">61</td><td class="hits">1</td><td class="source">Delete.prototype.setTimestamp = function (timestamp) {</td></tr><tr class="miss"><td class="line">62</td><td class="hits">0</td><td class="source">  this.ts = timestamp;</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * Delete all versions of the specified column with a timestamp less than</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * or equal to the specified timestamp.</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * @param {byte []} family family name</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * @param {byte []} qualifier column qualifier</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> * @param {long} timestamp maximum version timestamp</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">73</td><td class="hits">1</td><td class="source">Delete.prototype.deleteColumns = function (family, qualifier, timestamp) {</td></tr><tr class="hit"><td class="line">74</td><td class="hits">1</td><td class="source">  if (family !== null &amp;&amp; !Buffer.isBuffer(family)) {</td></tr><tr class="hit"><td class="line">75</td><td class="hits">1</td><td class="source">    family = Bytes.toBytes(family);</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">77</td><td class="hits">1</td><td class="source">  if (qualifier !== null &amp;&amp; !Buffer.isBuffer(qualifier)) {</td></tr><tr class="hit"><td class="line">78</td><td class="hits">1</td><td class="source">    qualifier = Bytes.toBytes(qualifier);</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">80</td><td class="hits">1</td><td class="source">  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">  var list = this.familyMap[family];</td></tr><tr class="hit"><td class="line">82</td><td class="hits">1</td><td class="source">  if (!list) {</td></tr><tr class="hit"><td class="line">83</td><td class="hits">1</td><td class="source">    list = this.familyMap[family] = [];</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">85</td><td class="hits">1</td><td class="source">  list.push(KeyValue.createKeyValue(this.row, family, qualifier, timestamp, KeyValue.Type.DeleteColumn));</td></tr><tr class="hit"><td class="line">86</td><td class="hits">1</td><td class="source">  return this;</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> * Delete the latest version of the specified column.</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> * This is an expensive call in that on the server-side, it first does a</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> * get to find the latest versions timestamp.  Then it adds a delete using</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> * the fetched cells timestamp.</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> * @param {byte []} family family name</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> * @param {byte []} qualifier column qualifier</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> * @param {long} timestamp version timestamp</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">Delete.prototype.deleteColumn = function (family, qualifier, timestamp) {</td></tr><tr class="hit"><td class="line">100</td><td class="hits">1</td><td class="source">  if (family !== null &amp;&amp; !Buffer.isBuffer(family)) {</td></tr><tr class="hit"><td class="line">101</td><td class="hits">1</td><td class="source">    family = Bytes.toBytes(family);</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">103</td><td class="hits">1</td><td class="source">  if (qualifier !== null &amp;&amp; !Buffer.isBuffer(qualifier)) {</td></tr><tr class="hit"><td class="line">104</td><td class="hits">1</td><td class="source">    qualifier = Bytes.toBytes(qualifier);</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">106</td><td class="hits">1</td><td class="source">  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;</td></tr><tr class="hit"><td class="line">107</td><td class="hits">1</td><td class="source">  var list = this.familyMap[family];</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1</td><td class="source">  if(!list) {</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1</td><td class="source">    list = this.familyMap[family] = [];</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">111</td><td class="hits">1</td><td class="source">  list.push(KeyValue.createKeyValue(this.row, family, qualifier, timestamp, KeyValue.Type.Delete));</td></tr><tr class="hit"><td class="line">112</td><td class="hits">1</td><td class="source">  return this;</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> * Delete all columns of the specified family with a timestamp less than</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> * or equal to the specified timestamp.</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> * Overrides previous calls to deleteColumn and deleteColumns for the</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> * specified family.</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> * @param {byte []} family family name</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> * @param {long} timestamp maximum version timestamp</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">125</td><td class="hits">1</td><td class="source">Delete.prototype.deleteFamily = function (family, timestamp) {</td></tr><tr class="miss"><td class="line">126</td><td class="hits">0</td><td class="source">  if (family !== null &amp;&amp; !Buffer.isBuffer(family)) {</td></tr><tr class="miss"><td class="line">127</td><td class="hits">0</td><td class="source">    family = Bytes.toBytes(family);</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">129</td><td class="hits">0</td><td class="source">  timestamp = timestamp || HConstants.LATEST_TIMESTAMP;</td></tr><tr class="miss"><td class="line">130</td><td class="hits">0</td><td class="source">  var list = this.familyMap[family] = [];</td></tr><tr class="miss"><td class="line">131</td><td class="hits">0</td><td class="source">  list.add(KeyValue.createKeyValue(this.row, family, null, timestamp, KeyValue.Type.DeleteFamily));</td></tr><tr class="miss"><td class="line">132</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> * Advanced use only.</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> * Add an existing delete marker to this Delete object.</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> * @param {KeyValue} kv An existing KeyValue of type &quot;delete&quot;.</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> * @throws IOException</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">142</td><td class="hits">1</td><td class="source">Delete.prototype.addDeleteMarker = function (kv) {</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">  // TODO: </td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">146</td><td class="hits">1</td><td class="source">Delete.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">147</td><td class="hits">6</td><td class="source">  out.writeByte(DELETE_VERSION);</td></tr><tr class="hit"><td class="line">148</td><td class="hits">6</td><td class="source">  Bytes.writeByteArray(out, this.row);</td></tr><tr class="hit"><td class="line">149</td><td class="hits">6</td><td class="source">  out.writeLong(this.ts);</td></tr><tr class="hit"><td class="line">150</td><td class="hits">6</td><td class="source">  out.writeLong(this.lockId);</td></tr><tr class="hit"><td class="line">151</td><td class="hits">6</td><td class="source">  out.writeBoolean(this.writeToWAL);</td></tr><tr class="hit"><td class="line">152</td><td class="hits">6</td><td class="source">  out.writeInt(Object.keys(this.familyMap).length);</td></tr><tr class="hit"><td class="line">153</td><td class="hits">6</td><td class="source">  for (var family in this.familyMap) {</td></tr><tr class="hit"><td class="line">154</td><td class="hits">2</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(family));</td></tr><tr class="hit"><td class="line">155</td><td class="hits">2</td><td class="source">    var keys = this.familyMap[family];</td></tr><tr class="hit"><td class="line">156</td><td class="hits">2</td><td class="source">    out.writeInt(keys.length);</td></tr><tr class="hit"><td class="line">157</td><td class="hits">2</td><td class="source">    for (var j = 0; j &lt; keys.length; j++) {</td></tr><tr class="hit"><td class="line">158</td><td class="hits">2</td><td class="source">      var kv = keys[j];</td></tr><tr class="hit"><td class="line">159</td><td class="hits">2</td><td class="source">      kv.write(out);</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">162</td><td class="hits">6</td><td class="source">  this.writeAttributes(out);</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">165</td><td class="hits">1</td><td class="source">module.exports = Delete;</td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/errors.js">/Users/mk2/git/node-hbase-client/lib/errors.js</h2><div id="stats" class="high"><div class="percentage">85%</div><div class="sloc">70</div><div class="hits">60</div><div class="misses">10</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/errors.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">// Create a new Abstract Error constructor</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var AbstractError = function (msg, constr) {</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">  // http://dustinsenos.com/articles/customErrorsInNode</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  // </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  // If defined, pass the constr property to V8's</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  // captureStackTrace to clean up the output</td></tr><tr class="hit"><td class="line">21</td><td class="hits">20</td><td class="source">  Error.captureStackTrace(this, constr || this);</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  // If defined, store a custom error message</td></tr><tr class="hit"><td class="line">24</td><td class="hits">20</td><td class="source">  this.message = msg || 'Error';</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">// Extend our AbstractError from Error</td></tr><tr class="hit"><td class="line">28</td><td class="hits">1</td><td class="source">util.inherits(AbstractError, Error);</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">// Give our Abstract error a name property. Helpful for logging the error later.</td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">AbstractError.prototype.name = 'AbstractError';</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">// Runtime</td></tr><tr class="hit"><td class="line">35</td><td class="hits">1</td><td class="source">var RuntimeException = function (msg) {</td></tr><tr class="miss"><td class="line">36</td><td class="hits">0</td><td class="source">  RuntimeException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">38</td><td class="hits">1</td><td class="source">util.inherits(RuntimeException, AbstractError);</td></tr><tr class="hit"><td class="line">39</td><td class="hits">1</td><td class="source">RuntimeException.prototype.name = 'RuntimeException';</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">41</td><td class="hits">1</td><td class="source">var UnsupportedOperationException = function (msg) {</td></tr><tr class="miss"><td class="line">42</td><td class="hits">0</td><td class="source">  UnsupportedOperationException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">44</td><td class="hits">1</td><td class="source">util.inherits(UnsupportedOperationException, RuntimeException);</td></tr><tr class="hit"><td class="line">45</td><td class="hits">1</td><td class="source">UnsupportedOperationException.prototype.name = 'UnsupportedOperationException';</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">// IO</td></tr><tr class="hit"><td class="line">49</td><td class="hits">1</td><td class="source">var IOException = function (msg) {</td></tr><tr class="hit"><td class="line">50</td><td class="hits">20</td><td class="source">  IOException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">52</td><td class="hits">1</td><td class="source">util.inherits(IOException, AbstractError);</td></tr><tr class="hit"><td class="line">53</td><td class="hits">1</td><td class="source">IOException.prototype.name = 'IOException';</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> * Thrown when something happens related to region handling.</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> * Subclasses have to be more specific.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">var RegionException = function (msg) {</td></tr><tr class="hit"><td class="line">60</td><td class="hits">1</td><td class="source">  RegionException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">util.inherits(RegionException, IOException);</td></tr><tr class="hit"><td class="line">63</td><td class="hits">1</td><td class="source">RegionException.prototype.name = 'RegionException';</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">/** Thrown when a table can not be located */</td></tr><tr class="hit"><td class="line">66</td><td class="hits">1</td><td class="source">var RegionOfflineException = function (msg) {</td></tr><tr class="miss"><td class="line">67</td><td class="hits">0</td><td class="source">  RegionOfflineException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">69</td><td class="hits">1</td><td class="source">util.inherits(RegionOfflineException, RegionException);</td></tr><tr class="hit"><td class="line">70</td><td class="hits">1</td><td class="source">RegionOfflineException.prototype.name = 'RegionOfflineException';</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> * Thrown when no region server can be found for a region</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">75</td><td class="hits">1</td><td class="source">var NoServerForRegionException = function (msg) {</td></tr><tr class="miss"><td class="line">76</td><td class="hits">0</td><td class="source">  NoServerForRegionException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">78</td><td class="hits">1</td><td class="source">util.inherits(NoServerForRegionException, RegionException);</td></tr><tr class="hit"><td class="line">79</td><td class="hits">1</td><td class="source">NoServerForRegionException.prototype.name = 'NoServerForRegionException';</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">var TableNotFoundException = function (msg) {</td></tr><tr class="hit"><td class="line">82</td><td class="hits">1</td><td class="source">  TableNotFoundException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">84</td><td class="hits">1</td><td class="source">util.inherits(TableNotFoundException, RegionException);</td></tr><tr class="hit"><td class="line">85</td><td class="hits">1</td><td class="source">TableNotFoundException.prototype.name = 'TableNotFoundException';</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">87</td><td class="hits">1</td><td class="source">var RegionOfflineException = function (msg) {</td></tr><tr class="miss"><td class="line">88</td><td class="hits">0</td><td class="source">  RegionOfflineException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1</td><td class="source">util.inherits(RegionOfflineException, RegionException);</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">RegionOfflineException.prototype.name = 'RegionOfflineException';</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">93</td><td class="hits">1</td><td class="source">var NoServerForRegionException = function (msg) {</td></tr><tr class="miss"><td class="line">94</td><td class="hits">0</td><td class="source">  NoServerForRegionException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">96</td><td class="hits">1</td><td class="source">util.inherits(NoServerForRegionException, RegionException);</td></tr><tr class="hit"><td class="line">97</td><td class="hits">1</td><td class="source">NoServerForRegionException.prototype.name = 'NoServerForRegionException';</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">var RemoteException = function (className, msg) {</td></tr><tr class="hit"><td class="line">100</td><td class="hits">2</td><td class="source">  RemoteException.super_.call(this, msg, this.constructor);</td></tr><tr class="hit"><td class="line">101</td><td class="hits">2</td><td class="source">  this.name = className;</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">103</td><td class="hits">1</td><td class="source">util.inherits(RemoteException, IOException);</td></tr><tr class="hit"><td class="line">104</td><td class="hits">1</td><td class="source">RemoteException.prototype.name = 'RemoteException';</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">106</td><td class="hits">1</td><td class="source">var ConnectionClosedException = function (msg) {</td></tr><tr class="hit"><td class="line">107</td><td class="hits">13</td><td class="source">  ConnectionClosedException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1</td><td class="source">util.inherits(ConnectionClosedException, IOException);</td></tr><tr class="hit"><td class="line">110</td><td class="hits">1</td><td class="source">ConnectionClosedException.prototype.name = 'ConnectionClosedException';</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">112</td><td class="hits">1</td><td class="source">var RemoteCallTimeoutException = function (msg) {</td></tr><tr class="hit"><td class="line">113</td><td class="hits">4</td><td class="source">  RemoteCallTimeoutException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">115</td><td class="hits">1</td><td class="source">util.inherits(RemoteCallTimeoutException, IOException);</td></tr><tr class="hit"><td class="line">116</td><td class="hits">1</td><td class="source">RemoteCallTimeoutException.prototype.name = 'RemoteCallTimeoutException';</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">118</td><td class="hits">1</td><td class="source">var VersionMismatchException = function (expectedVersion, foundVersion) {</td></tr><tr class="miss"><td class="line">119</td><td class="hits">0</td><td class="source">  var msg = &quot;A record version mismatch occured. Expecting v&quot; + expectedVersion + &quot;, found v&quot; + foundVersion;</td></tr><tr class="miss"><td class="line">120</td><td class="hits">0</td><td class="source">  VersionMismatchException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">122</td><td class="hits">1</td><td class="source">util.inherits(VersionMismatchException, IOException);</td></tr><tr class="hit"><td class="line">123</td><td class="hits">1</td><td class="source">VersionMismatchException.prototype.name = 'VersionMismatchException';</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">// Argument</td></tr><tr class="hit"><td class="line">127</td><td class="hits">1</td><td class="source">var IllegalArgumentException = function (msg) {</td></tr><tr class="miss"><td class="line">128</td><td class="hits">0</td><td class="source">  IllegalArgumentException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">130</td><td class="hits">1</td><td class="source">util.inherits(IllegalArgumentException, AbstractError);</td></tr><tr class="hit"><td class="line">131</td><td class="hits">1</td><td class="source">IllegalArgumentException.prototype.name = 'IllegalArgumentException';</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">133</td><td class="hits">1</td><td class="source">var NegativeArraySizeException = function (msg) {</td></tr><tr class="miss"><td class="line">134</td><td class="hits">0</td><td class="source">  NegativeArraySizeException.super_.call(this, msg, this.constructor);</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">};</td></tr><tr class="hit"><td class="line">136</td><td class="hits">1</td><td class="source">util.inherits(NegativeArraySizeException, AbstractError);</td></tr><tr class="hit"><td class="line">137</td><td class="hits">1</td><td class="source">NegativeArraySizeException.prototype.name = 'NegativeArraySizeException';</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">141</td><td class="hits">1</td><td class="source">module.exports = {</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">  AbstractError: AbstractError,</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source">  // IO</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">  IOException: IOException,</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">  RegionException: RegionException,</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">  TableNotFoundException: TableNotFoundException,</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">  RemoteException: RemoteException,</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">  VersionMismatchException: VersionMismatchException,</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">  RemoteCallTimeoutException: RemoteCallTimeoutException,</td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">  ConnectionClosedException: ConnectionClosedException,</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source">  // Runtime</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source">  RuntimeException: RuntimeException,</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">  UnsupportedOperationException: UnsupportedOperationException,</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">  IllegalArgumentException: IllegalArgumentException,</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source">  NegativeArraySizeException: NegativeArraySizeException,</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/get.js">/Users/mk2/git/node-hbase-client/lib/get.js</h2><div id="stats" class="high"><div class="percentage">86%</div><div class="sloc">100</div><div class="hits">86</div><div class="misses">14</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/get.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var HbaseObjectWritable = require('./io/hbase_object_writable');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var eventproxy = require('eventproxy');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var IOException = require('./errors').IOException;</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var TimeRange = require('./time_range');</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var OperationWithAttributes = require('./operation_with_attributes');</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var GET_VERSION = 2;</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">function Get(row, rowLock) {</td></tr><tr class="hit"><td class="line">24</td><td class="hits">52</td><td class="source">  if (!(this instanceof Get)) {</td></tr><tr class="miss"><td class="line">25</td><td class="hits">0</td><td class="source">    return new Get(row, rowLock);</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">28</td><td class="hits">52</td><td class="source">  OperationWithAttributes.call(this);</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">30</td><td class="hits">52</td><td class="source">  if (row &amp;&amp; !Buffer.isBuffer(row)) {</td></tr><tr class="hit"><td class="line">31</td><td class="hits">49</td><td class="source">    row = Bytes.toBytes(row);</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">34</td><td class="hits">52</td><td class="source">  this.row = row;</td></tr><tr class="hit"><td class="line">35</td><td class="hits">52</td><td class="source">  this.lockId = -1;</td></tr><tr class="hit"><td class="line">36</td><td class="hits">52</td><td class="source">  if (rowLock) {</td></tr><tr class="miss"><td class="line">37</td><td class="hits">0</td><td class="source">    this.lockId = rowLock.getLockId();</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">39</td><td class="hits">52</td><td class="source">  this.maxVersions = 1;</td></tr><tr class="hit"><td class="line">40</td><td class="hits">52</td><td class="source">  this.cacheBlocks = true;</td></tr><tr class="hit"><td class="line">41</td><td class="hits">52</td><td class="source">  this.filter = null;</td></tr><tr class="hit"><td class="line">42</td><td class="hits">52</td><td class="source">  this.tr = new TimeRange();</td></tr><tr class="hit"><td class="line">43</td><td class="hits">52</td><td class="source">  this.familyMap = {}; // new TreeMap&lt;byte[], NavigableSet&lt;byte[]&gt;&gt;(Bytes.BYTES_COMPARATOR);</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">46</td><td class="hits">1</td><td class="source">util.inherits(Get, OperationWithAttributes);</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> * Get all columns from the specified family.</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> * Overrides previous calls to addColumn for this family.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> * @return the Get object</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">56</td><td class="hits">1</td><td class="source">Get.prototype.addFamily = function (family) {</td></tr><tr class="miss"><td class="line">57</td><td class="hits">0</td><td class="source">  delete this.familyMap[family];</td></tr><tr class="miss"><td class="line">58</td><td class="hits">0</td><td class="source">  this.familyMap[family] = null;</td></tr><tr class="miss"><td class="line">59</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> * Get the column from the specific family with the specified qualifier.</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * Overrides previous calls to addFamily for this family.</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * @param qualifier column qualifier</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * @return the Get objec</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">71</td><td class="hits">1</td><td class="source">Get.prototype.addColumn = function (family, qualifier) {</td></tr><tr class="hit"><td class="line">72</td><td class="hits">94</td><td class="source">  var set = this.familyMap[family] || [];</td></tr><tr class="hit"><td class="line">73</td><td class="hits">94</td><td class="source">  set.push(qualifier);</td></tr><tr class="hit"><td class="line">74</td><td class="hits">94</td><td class="source">  this.familyMap[family] = set;</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  // NavigableSet&lt;byte[]&gt; set = familyMap.get(family);</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  // if (set == null) {</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">  //   set = new TreeSet&lt;byte[]&gt;(Bytes.BYTES_COMPARATOR);</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  // set.add(qualifier);</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  // familyMap.put(family, set);</td></tr><tr class="hit"><td class="line">81</td><td class="hits">94</td><td class="source">  return this;</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> * Get up to the specified number of versions of each column.</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> * @param maxVersions maximum versions for each column</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1</td><td class="source">Get.prototype.setMaxVersions = function (maxVersions) {</td></tr><tr class="hit"><td class="line">91</td><td class="hits">5</td><td class="source">  if (maxVersions &lt;= 0) {</td></tr><tr class="miss"><td class="line">92</td><td class="hits">0</td><td class="source">    maxVersions = 1;</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">94</td><td class="hits">5</td><td class="source">  this.maxVersions = maxVersions;</td></tr><tr class="hit"><td class="line">95</td><td class="hits">5</td><td class="source">  return this;</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * Get versions of columns only within the specified timestamp range,</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * [minStamp, maxStamp).</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> * @param minStamp minimum timestamp value, inclusive</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> * @param maxStamp maximum timestamp value, exclusive</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> * @return this for invocation chaining</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">106</td><td class="hits">1</td><td class="source">Get.prototype.setTimeRange = function (minStamp, maxStamp) {</td></tr><tr class="miss"><td class="line">107</td><td class="hits">0</td><td class="source">  this.tr = new TimeRange(minStamp, maxStamp);</td></tr><tr class="miss"><td class="line">108</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">111</td><td class="hits">1</td><td class="source">Get.prototype.readFields = function (io) {</td></tr><tr class="hit"><td class="line">112</td><td class="hits">3</td><td class="source">  var version = io.readByte();</td></tr><tr class="hit"><td class="line">113</td><td class="hits">3</td><td class="source">  if (version &gt; GET_VERSION) {</td></tr><tr class="miss"><td class="line">114</td><td class="hits">0</td><td class="source">    throw new IOException(&quot;unsupported version: &quot; + version);</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">116</td><td class="hits">3</td><td class="source">  this.version = version;</td></tr><tr class="hit"><td class="line">117</td><td class="hits">3</td><td class="source">  this.row = io.readByteArray();</td></tr><tr class="hit"><td class="line">118</td><td class="hits">3</td><td class="source">  this.lockId = io.readLong();</td></tr><tr class="hit"><td class="line">119</td><td class="hits">3</td><td class="source">  this.maxVersions = io.readInt();</td></tr><tr class="hit"><td class="line">120</td><td class="hits">3</td><td class="source">  var hasFilter = io.readBoolean();</td></tr><tr class="hit"><td class="line">121</td><td class="hits">3</td><td class="source">  if (hasFilter) {</td></tr><tr class="miss"><td class="line">122</td><td class="hits">0</td><td class="source">    this.filter.readFields(io);</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">124</td><td class="hits">3</td><td class="source">  this.hasFilter = hasFilter;</td></tr><tr class="hit"><td class="line">125</td><td class="hits">3</td><td class="source">  this.cacheBlocks = io.readBoolean();</td></tr><tr class="hit"><td class="line">126</td><td class="hits">3</td><td class="source">  this.tr = new TimeRange();</td></tr><tr class="hit"><td class="line">127</td><td class="hits">3</td><td class="source">  this.tr.readFields(io);</td></tr><tr class="hit"><td class="line">128</td><td class="hits">3</td><td class="source">  var familyMap = {};</td></tr><tr class="hit"><td class="line">129</td><td class="hits">3</td><td class="source">  var num = io.readInt();</td></tr><tr class="hit"><td class="line">130</td><td class="hits">3</td><td class="source">  for (var i = 0; i &lt; num; i++) {</td></tr><tr class="hit"><td class="line">131</td><td class="hits">3</td><td class="source">    var family = Bytes.toString(io.readByteArray());</td></tr><tr class="hit"><td class="line">132</td><td class="hits">3</td><td class="source">    familyMap[family] = null;</td></tr><tr class="hit"><td class="line">133</td><td class="hits">3</td><td class="source">    var hasColumns = io.readBoolean();</td></tr><tr class="hit"><td class="line">134</td><td class="hits">3</td><td class="source">    if (hasColumns) {</td></tr><tr class="hit"><td class="line">135</td><td class="hits">3</td><td class="source">      var set = [];</td></tr><tr class="hit"><td class="line">136</td><td class="hits">3</td><td class="source">      var columnNum = io.readInt();</td></tr><tr class="hit"><td class="line">137</td><td class="hits">3</td><td class="source">      for (var j = 0; j &lt; columnNum; j++) {</td></tr><tr class="hit"><td class="line">138</td><td class="hits">3</td><td class="source">        var qualifier = io.readByteArray();</td></tr><tr class="hit"><td class="line">139</td><td class="hits">3</td><td class="source">        set.push(qualifier);</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">141</td><td class="hits">3</td><td class="source">      familyMap[family] = set;</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">144</td><td class="hits">3</td><td class="source">  this.familyMap = familyMap;</td></tr><tr class="hit"><td class="line">145</td><td class="hits">3</td><td class="source">  this.readAttributes(io);</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">148</td><td class="hits">1</td><td class="source">Get.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">149</td><td class="hits">49</td><td class="source">  out.writeByte(GET_VERSION);</td></tr><tr class="hit"><td class="line">150</td><td class="hits">49</td><td class="source">  Bytes.writeByteArray(out, this.row);</td></tr><tr class="hit"><td class="line">151</td><td class="hits">49</td><td class="source">  out.writeLong(this.lockId);</td></tr><tr class="hit"><td class="line">152</td><td class="hits">49</td><td class="source">  out.writeInt(this.maxVersions);</td></tr><tr class="hit"><td class="line">153</td><td class="hits">49</td><td class="source">  if (this.filter === null) {</td></tr><tr class="hit"><td class="line">154</td><td class="hits">49</td><td class="source">    out.writeBoolean(false);</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">156</td><td class="hits">0</td><td class="source">    out.writeBoolean(true);</td></tr><tr class="miss"><td class="line">157</td><td class="hits">0</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(this.filter.getClass().getName()));</td></tr><tr class="miss"><td class="line">158</td><td class="hits">0</td><td class="source">    this.filter.write(out);</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">160</td><td class="hits">49</td><td class="source">  out.writeBoolean(this.cacheBlocks);</td></tr><tr class="hit"><td class="line">161</td><td class="hits">49</td><td class="source">  this.tr.write(out);</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source">  // out.writeInt(familyMap.size());</td></tr><tr class="hit"><td class="line">163</td><td class="hits">49</td><td class="source">  out.writeInt(Object.keys(this.familyMap).length);</td></tr><tr class="hit"><td class="line">164</td><td class="hits">49</td><td class="source">  for (var family in this.familyMap) {</td></tr><tr class="hit"><td class="line">165</td><td class="hits">49</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(family));</td></tr><tr class="hit"><td class="line">166</td><td class="hits">49</td><td class="source">    var columnSet = this.familyMap[family];</td></tr><tr class="hit"><td class="line">167</td><td class="hits">49</td><td class="source">    if (columnSet === null) {</td></tr><tr class="miss"><td class="line">168</td><td class="hits">0</td><td class="source">      out.writeBoolean(false);</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">    } else {</td></tr><tr class="hit"><td class="line">170</td><td class="hits">49</td><td class="source">      out.writeBoolean(true);</td></tr><tr class="hit"><td class="line">171</td><td class="hits">49</td><td class="source">      out.writeInt(columnSet.length);</td></tr><tr class="hit"><td class="line">172</td><td class="hits">49</td><td class="source">      for (var i = 0; i &lt; columnSet.length; i++) {</td></tr><tr class="hit"><td class="line">173</td><td class="hits">94</td><td class="source">        var qualifier = columnSet[i];</td></tr><tr class="hit"><td class="line">174</td><td class="hits">94</td><td class="source">        Bytes.writeByteArray(out, Bytes.toBytes(qualifier));</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">176</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">178</td><td class="hits">49</td><td class="source">  this.writeAttributes(out);</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">181</td><td class="hits">1</td><td class="source">Get.prototype.getRow = function () {</td></tr><tr class="hit"><td class="line">182</td><td class="hits">46</td><td class="source">  return this.row;</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">186</td><td class="hits">1</td><td class="source">HbaseObjectWritable.addToClass('Get.class', Get);</td></tr><tr class="hit"><td class="line">187</td><td class="hits">1</td><td class="source">module.exports = Get;</td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/hconstants.js">/Users/mk2/git/node-hbase-client/lib/hconstants.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">35</div><div class="hits">35</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/hconstants.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var CONST = {};</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">CONST.PROTOCOL = 'org.apache.hadoop.hbase.ipc.HRegionInterface';</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">CONST.CLIENT_VERSION = Long.fromNumber(29);</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * Timestamp to use when we want to refer to the latest cell.</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * This is the timestamp sent by clients when no timestamp is specified on</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * commit.</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">26</td><td class="hits">1</td><td class="source">CONST.LATEST_TIMESTAMP = Long.MAX_VALUE;</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> * Timestamp to use when we want to refer to the oldest cell.</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">30</td><td class="hits">1</td><td class="source">CONST.OLDEST_TIMESTAMP = Long.MIN_VALUE;</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> * LATEST_TIMESTAMP in bytes form</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">34</td><td class="hits">1</td><td class="source">CONST.LATEST_TIMESTAMP_BYTES = Bytes.toBytes(CONST.LATEST_TIMESTAMP);</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">/** The root table's name.*/</td></tr><tr class="hit"><td class="line">36</td><td class="hits">1</td><td class="source">CONST.ROOT_TABLE_NAME = Bytes.toBytes(&quot;-ROOT-&quot;);</td></tr><tr class="hit"><td class="line">37</td><td class="hits">1</td><td class="source">CONST.ROOT_TABLE_NAME.__name__ = '-ROOT-';</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">/** The META table's name. */</td></tr><tr class="hit"><td class="line">40</td><td class="hits">1</td><td class="source">CONST.META_TABLE_NAME = Bytes.toBytes(&quot;.META.&quot;);</td></tr><tr class="hit"><td class="line">41</td><td class="hits">1</td><td class="source">CONST.META_TABLE_NAME.__name__ = '.META.';</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">/** delimiter used between portions of a region name */</td></tr><tr class="hit"><td class="line">44</td><td class="hits">1</td><td class="source">CONST.META_ROW_DELIMITER = ',';</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">/** The catalog family as a string*/</td></tr><tr class="hit"><td class="line">47</td><td class="hits">1</td><td class="source">CONST.CATALOG_FAMILY_STR = &quot;info&quot;;</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">/** The catalog family */</td></tr><tr class="hit"><td class="line">50</td><td class="hits">1</td><td class="source">CONST.CATALOG_FAMILY = Bytes.toBytes(CONST.CATALOG_FAMILY_STR);</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">/** The regioninfo column qualifier */</td></tr><tr class="hit"><td class="line">53</td><td class="hits">1</td><td class="source">CONST.REGIONINFO_QUALIFIER = Bytes.toBytes(&quot;regioninfo&quot;);</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">/** The server column qualifier */</td></tr><tr class="hit"><td class="line">56</td><td class="hits">1</td><td class="source">CONST.SERVER_QUALIFIER = Bytes.toBytes(&quot;server&quot;);</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">/** The startcode column qualifier */</td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">CONST.STARTCODE_QUALIFIER = Bytes.toBytes(&quot;serverstartcode&quot;);</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">/** The lower-half split region column qualifier */</td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">CONST.SPLITA_QUALIFIER = Bytes.toBytes(&quot;splitA&quot;);</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">/** The upper-half split region column qualifier */</td></tr><tr class="hit"><td class="line">65</td><td class="hits">1</td><td class="source">CONST.SPLITB_QUALIFIER = Bytes.toBytes(&quot;splitB&quot;);</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * The meta table version column qualifier.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * We keep current version of the meta table in this column in &lt;code&gt;-ROOT-&lt;/code&gt;</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> * table: i.e. in the 'info:v' column.</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">72</td><td class="hits">1</td><td class="source">CONST.META_VERSION_QUALIFIER = Bytes.toBytes(&quot;v&quot;);</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> * The current version of the meta table.</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> * Before this the meta had HTableDescriptor serialized into the HRegionInfo;</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> * i.e. pre-hbase 0.92.  There was no META_VERSION column in the root table</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> * in this case.  The presence of a version and its value being zero indicates</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> * meta is up-to-date.</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">CONST.META_VERSION = 0;</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">/** long constant for zero */</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">// CONST.ZERO_L = Long.valueOf(0L);</td></tr><tr class="hit"><td class="line">85</td><td class="hits">1</td><td class="source">CONST.NINES = &quot;99999999999999&quot;;</td></tr><tr class="hit"><td class="line">86</td><td class="hits">1</td><td class="source">CONST.ZEROES = &quot;00000000000000&quot;;</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">// Other constants</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> * An empty instance.</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">93</td><td class="hits">1</td><td class="source">CONST.EMPTY_BYTE_ARRAY = new Buffer(0);</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> * Used by scanners, etc when they want to start at the beginning of a region</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">98</td><td class="hits">1</td><td class="source">CONST.EMPTY_START_ROW = CONST.EMPTY_BYTE_ARRAY;</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> * Last row in a table.</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">103</td><td class="hits">1</td><td class="source">CONST.EMPTY_END_ROW = CONST.EMPTY_START_ROW;</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">* Used by scanners and others when they're trying to detect the end of a</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">* table</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1</td><td class="source">CONST.LAST_ROW = CONST.EMPTY_BYTE_ARRAY;</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> * Parameter name for client prefetch limit, used as the maximum number of regions</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> * info that will be prefetched.</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">// public static String HBASE_CLIENT_PREFETCH_LIMIT = &quot;hbase.client.prefetch.limit&quot;;</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> * Default value of {@link #HBASE_CLIENT_PREFETCH_LIMIT}.</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">120</td><td class="hits">1</td><td class="source">CONST.DEFAULT_HBASE_CLIENT_PREFETCH_LIMIT = 10;</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> * Parameter name for number of rows that will be fetched when calling next on</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> * a scanner if it is not served from memory. Higher caching values will</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source"> * enable faster scanners but will eat up more memory and some calls of next</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> * may take longer and longer times when the cache is empty.</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">128</td><td class="hits">1</td><td class="source">CONST.HBASE_META_SCANNER_CACHING = &quot;hbase.meta.scanner.caching&quot;;</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> * Default value of {@link #HBASE_META_SCANNER_CACHING}.</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">133</td><td class="hits">1</td><td class="source">CONST.DEFAULT_HBASE_META_SCANNER_CACHING = 100;</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> * Parameter name for maximum retries, used as maximum for all retryable</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> * operations such as fetching of the root region from root region server,</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> * getting a cell's value, starting a row update, etc.</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">140</td><td class="hits">1</td><td class="source">CONST.DEFAULT_HBASE_CLIENT_RETRIES_NUMBER = 10;</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> * timeout for each RPC</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">145</td><td class="hits">1</td><td class="source">CONST.DEFAULT_HBASE_RPC_TIMEOUT = 60000;</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">148</td><td class="hits">1</td><td class="source">module.exports = CONST;</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/hregion_info.js">/Users/mk2/git/node-hbase-client/lib/hregion_info.js</h2><div id="stats" class="medium"><div class="percentage">55%</div><div class="sloc">200</div><div class="hits">111</div><div class="misses">89</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/hregion_info.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var IOException = require('./errors').IOException;</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var md5 = require('utility').md5;</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> * Make a region name of passed parameters.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * @param tableName</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * @param startKey Can be null</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * @param id Region id (Usually timestamp from when region was created).</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> * @param newFormat should we create the region name in the new format</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> *                  (such that it contains its encoded name?).</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> * @return Region name made of passed tableName, startKey and id</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">var createRegionName = function (tableName, startKey, id, newFormat) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">58</td><td class="source">  if (!Buffer.isBuffer(tableName)) {</td></tr><tr class="hit"><td class="line">31</td><td class="hits">2</td><td class="source">    tableName = Bytes.toBytes(tableName);</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">33</td><td class="hits">58</td><td class="source">  if (id instanceof Long || typeof id === 'number') {</td></tr><tr class="hit"><td class="line">34</td><td class="hits">3</td><td class="source">    id = id.toString();</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">36</td><td class="hits">58</td><td class="source">  if (typeof id === 'string') {</td></tr><tr class="hit"><td class="line">37</td><td class="hits">58</td><td class="source">    id = Bytes.toBytes(id);</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">39</td><td class="hits">58</td><td class="source">  var length = tableName.length + 2 + id.length + (!startKey ? 0 : startKey.length) + </td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">    (newFormat ? (HRegionInfo.MD5_HEX_LENGTH + 2) : 0);</td></tr><tr class="hit"><td class="line">41</td><td class="hits">58</td><td class="source">  var b = new Buffer(length);</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">43</td><td class="hits">58</td><td class="source">  var offset = 0;</td></tr><tr class="hit"><td class="line">44</td><td class="hits">58</td><td class="source">  tableName.copy(b, offset);</td></tr><tr class="hit"><td class="line">45</td><td class="hits">58</td><td class="source">  offset += tableName.length;</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  // System.arraycopy(tableName, 0, b, 0, offset);</td></tr><tr class="hit"><td class="line">47</td><td class="hits">58</td><td class="source">  b[offset++] = HRegionInfo.DELIMITER;</td></tr><tr class="hit"><td class="line">48</td><td class="hits">58</td><td class="source">  if (startKey &amp;&amp; startKey.length &gt; 0) {</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">    // System.arraycopy(startKey, 0, b, offset, startKey.length);</td></tr><tr class="hit"><td class="line">50</td><td class="hits">46</td><td class="source">    startKey.copy(b, offset);</td></tr><tr class="hit"><td class="line">51</td><td class="hits">46</td><td class="source">    offset += startKey.length;</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">53</td><td class="hits">58</td><td class="source">  b[offset++] = HRegionInfo.DELIMITER;</td></tr><tr class="hit"><td class="line">54</td><td class="hits">58</td><td class="source">  id.copy(b, offset);</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  // System.arraycopy(id, 0, b, offset, id.length);</td></tr><tr class="hit"><td class="line">56</td><td class="hits">58</td><td class="source">  offset += id.length;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">58</td><td class="hits">58</td><td class="source">  if (newFormat) {</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">    //</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">    // Encoded name should be built into the region name.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">    //</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">    // Use the region name thus far (namely, &lt;tablename&gt;,&lt;startKey&gt;,&lt;id&gt;)</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">    // to compute a MD5 hash to be used as the encoded name, and append</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">    // it to the byte buffer.</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">    //</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">    // var md5Hash = MD5Hash.getMD5AsHex(b, 0, offset);</td></tr><tr class="miss"><td class="line">67</td><td class="hits">0</td><td class="source">    var md5Hash = md5(b.slice(0, offset));</td></tr><tr class="miss"><td class="line">68</td><td class="hits">0</td><td class="source">    var md5HashBytes = Bytes.toBytes(md5Hash);</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">70</td><td class="hits">0</td><td class="source">    if (md5HashBytes.length !== HRegionInfo.MD5_HEX_LENGTH) {</td></tr><tr class="miss"><td class="line">71</td><td class="hits">0</td><td class="source">      console.error(&quot;MD5-hash length mismatch: Expected=&quot; + HRegionInfo.MD5_HEX_LENGTH + </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">        &quot;; Got=&quot; + md5HashBytes.length);</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">    // now append the bytes '.&lt;encodedName&gt;.' to the end</td></tr><tr class="miss"><td class="line">76</td><td class="hits">0</td><td class="source">    b[offset++] = HRegionInfo.ENC_SEPARATOR;</td></tr><tr class="miss"><td class="line">77</td><td class="hits">0</td><td class="source">    md5HashBytes.copy(b, offset);</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">    // System.arraycopy(md5HashBytes, 0, b, offset, MD5_HEX_LENGTH);</td></tr><tr class="miss"><td class="line">79</td><td class="hits">0</td><td class="source">    offset += HRegionInfo.MD5_HEX_LENGTH;</td></tr><tr class="miss"><td class="line">80</td><td class="hits">0</td><td class="source">    b[offset++] = HRegionInfo.ENC_SEPARATOR;</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">83</td><td class="hits">58</td><td class="source">  return b;</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> * HRegion information.</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * Contains HRegion id, start and end keys, a reference to this</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * HRegions' table descriptor, etc.</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">function HRegionInfo(regionId, tableName, startKey, endKey, split) {</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">   * Construct HRegionInfo with explicit parameters</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">   *</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">   * @param tableName the table descriptor</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">   * @param startKey first key in region</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">   * @param endKey end of key range</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">   * @param split true if this region has split and we have daughter regions</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">   * regions that may or may not hold references to this region.</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">   * @param regionid Region id to use.</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">   */</td></tr><tr class="hit"><td class="line">102</td><td class="hits">269</td><td class="source">  this.tableName = tableName;</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">  // This flag is in the parent of a split while the parent is still referenced</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  // by daughter regions.  We USED to set this flag when we disabled a table</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">  // but now table state is kept up in zookeeper as of 0.90.0 HBase.</td></tr><tr class="hit"><td class="line">107</td><td class="hits">269</td><td class="source">  this.offLine = false;</td></tr><tr class="hit"><td class="line">108</td><td class="hits">269</td><td class="source">  this.regionId = regionId;</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">110</td><td class="hits">269</td><td class="source">  if (!tableName) {</td></tr><tr class="hit"><td class="line">111</td><td class="hits">267</td><td class="source">    return;</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">114</td><td class="hits">2</td><td class="source">  var newFormat = true;</td></tr><tr class="hit"><td class="line">115</td><td class="hits">2</td><td class="source">  if (Bytes.equals(tableName, HConstants.ROOT_TABLE_NAME) || Bytes.equals(tableName, HConstants.META_TABLE_NAME)) {</td></tr><tr class="hit"><td class="line">116</td><td class="hits">2</td><td class="source">    newFormat = false;</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">118</td><td class="hits">2</td><td class="source">  this.regionName = createRegionName(this.tableName, startKey, this.regionId, newFormat);</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">120</td><td class="hits">2</td><td class="source">  this.regionNameStr = Bytes.toStringBinary(this.regionName);</td></tr><tr class="hit"><td class="line">121</td><td class="hits">2</td><td class="source">  this.split = split;</td></tr><tr class="hit"><td class="line">122</td><td class="hits">2</td><td class="source">  if (endKey === undefined || endKey === null) {</td></tr><tr class="hit"><td class="line">123</td><td class="hits">2</td><td class="source">    endKey = HConstants.EMPTY_END_ROW;</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">125</td><td class="hits">2</td><td class="source">  if (startKey === undefined || startKey === null) {</td></tr><tr class="hit"><td class="line">126</td><td class="hits">2</td><td class="source">    startKey = HConstants.EMPTY_START_ROW;</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">128</td><td class="hits">2</td><td class="source">  this.endKey = endKey;</td></tr><tr class="hit"><td class="line">129</td><td class="hits">2</td><td class="source">  this.startKey = startKey;</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> * The new format for a region name contains its encodedName at the end.</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> * The encoded name also serves as the directory name for the region</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source"> * in the filesystem.</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> * New region name format:</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> *    &lt;tablename&gt;,,&lt;startkey&gt;,&lt;regionIdTimestamp&gt;.&lt;encodedName&gt;.</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> * where,</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> *    &lt;encodedName&gt; is a hex version of the MD5 hash of</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> *    &lt;tablename&gt;,&lt;startkey&gt;,&lt;regionIdTimestamp&gt;</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> * The old region name format:</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> *    &lt;tablename&gt;,&lt;startkey&gt;,&lt;regionIdTimestamp&gt;</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source"> * For region names in the old format, the encoded name is a 32-bit</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> * JenkinsHash integer value (in its decimal notation, string form). </td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> *&lt;p&gt;</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source"> * **NOTE**</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> * ROOT, the first META region, and regions created by an older</td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source"> * version of HBase (0.20 or prior) will continue to use the</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> * old region name format.</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">// VERSION == 0 when HRegionInfo had an HTableDescriptor inside it.</td></tr><tr class="hit"><td class="line">156</td><td class="hits">1</td><td class="source">HRegionInfo.VERSION_PRE_092 = 0;</td></tr><tr class="hit"><td class="line">157</td><td class="hits">1</td><td class="source">HRegionInfo.VERSION = 1;</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">/** Separator used to demarcate the encodedName in a region name</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> * in the new format. See description on new format above. </td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">161</td><td class="hits">1</td><td class="source">HRegionInfo.ENC_SEPARATOR = '.'.charCodeAt(0);</td></tr><tr class="hit"><td class="line">162</td><td class="hits">1</td><td class="source">HRegionInfo.MD5_HEX_LENGTH = 32;</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">/** delimiter used between portions of a region name */</td></tr><tr class="hit"><td class="line">165</td><td class="hits">1</td><td class="source">HRegionInfo.DELIMITER = ','.charCodeAt(0);</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">168</td><td class="hits"></td><td class="source"> * Does region name contain its encoded name?</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source"> * @param regionName region name</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source"> * @return boolean indicating if this a new format region</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source"> *         name which contains its encoded name.</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">174</td><td class="hits">1</td><td class="source">HRegionInfo.hasEncodedName = function (regionName) {</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source">  // check if region name ends in ENC_SEPARATOR</td></tr><tr class="miss"><td class="line">176</td><td class="hits">0</td><td class="source">  if ((regionName.length &gt;= 1) &amp;&amp; (regionName[regionName.length - 1] === HRegionInfo.ENC_SEPARATOR)) {</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">    // region name is new format. it contains the encoded name.</td></tr><tr class="miss"><td class="line">178</td><td class="hits">0</td><td class="source">    return true;</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">180</td><td class="hits">0</td><td class="source">  return false;</td></tr><tr><td class="line">181</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source"> * @param regionName</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source"> * @return the encodedName</td></tr><tr><td class="line">186</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">187</td><td class="hits">1</td><td class="source">HRegionInfo.encodeRegionName = function (regionName) {</td></tr><tr class="miss"><td class="line">188</td><td class="hits">0</td><td class="source">  var encodedName;</td></tr><tr class="miss"><td class="line">189</td><td class="hits">0</td><td class="source">  if (HRegionInfo.hasEncodedName(regionName)) {</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">    // region is in new format:</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source">    // &lt;tableName&gt;,&lt;startKey&gt;,&lt;regionIdTimeStamp&gt;/encodedName/</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source">    // encodedName = Bytes.toString(regionName, </td></tr><tr><td class="line">193</td><td class="hits"></td><td class="source">    //   regionName.length - HRegionInfo.MD5_HEX_LENGTH - 1, </td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">    //   HRegionInfo.MD5_HEX_LENGTH);</td></tr><tr class="miss"><td class="line">195</td><td class="hits">0</td><td class="source">    var offset = regionName.length - HRegionInfo.MD5_HEX_LENGTH - 1;</td></tr><tr class="miss"><td class="line">196</td><td class="hits">0</td><td class="source">    encodedName = Bytes.toString(regionName.slice(offset, offset + HRegionInfo.MD5_HEX_LENGTH));</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">198</td><td class="hits">0</td><td class="source">    encodedName = Bytes.toString(regionName);</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">    // old format region name. ROOT and first META region also </td></tr><tr><td class="line">200</td><td class="hits"></td><td class="source">    // use this format.EncodedName is the JenkinsHash value.</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source">    // var hashVal = Math.abs(JenkinsHash.getInstance().hash(regionName, regionName.length, 0));</td></tr><tr><td class="line">202</td><td class="hits"></td><td class="source">    // encodedName = String.valueOf(hashVal);</td></tr><tr><td class="line">203</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">204</td><td class="hits">0</td><td class="source">  return encodedName;</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">206</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source"> /**</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source"> * Use logging.</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source"> * @param encodedRegionName The encoded regionname.</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source"> * @return &lt;code&gt;-ROOT-&lt;/code&gt; if passed &lt;code&gt;70236052&lt;/code&gt; or</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source"> * &lt;code&gt;.META.&lt;/code&gt; if passed &lt;/code&gt;1028785192&lt;/code&gt; else returns</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source"> * &lt;code&gt;encodedRegionName&lt;/code&gt;</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">215</td><td class="hits">1</td><td class="source">HRegionInfo.prettyPrint = function (encodedRegionName) {</td></tr><tr class="miss"><td class="line">216</td><td class="hits">0</td><td class="source">  if (encodedRegionName.equals(&quot;70236052&quot;)) {</td></tr><tr class="miss"><td class="line">217</td><td class="hits">0</td><td class="source">    return encodedRegionName + &quot;/-ROOT-&quot;;</td></tr><tr class="miss"><td class="line">218</td><td class="hits">0</td><td class="source">  } else if (encodedRegionName.equals(&quot;1028785192&quot;)) {</td></tr><tr class="miss"><td class="line">219</td><td class="hits">0</td><td class="source">    return encodedRegionName + &quot;/.META.&quot;;</td></tr><tr><td class="line">220</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">221</td><td class="hits">0</td><td class="source">  return encodedRegionName;</td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">223</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">225</td><td class="hits"></td><td class="source"> * Gets the table name from the specified region name.</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source"> * @param regionName</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source"> * @return Table name.</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">230</td><td class="hits">1</td><td class="source">HRegionInfo.getTableName = function (regionName) {</td></tr><tr class="miss"><td class="line">231</td><td class="hits">0</td><td class="source">  var offset = -1;</td></tr><tr class="miss"><td class="line">232</td><td class="hits">0</td><td class="source">  for (var i = 0; i &lt; regionName.length; i++) {</td></tr><tr class="miss"><td class="line">233</td><td class="hits">0</td><td class="source">    if (regionName[i] === HRegionInfo.DELIMITER) {</td></tr><tr class="miss"><td class="line">234</td><td class="hits">0</td><td class="source">      offset = i;</td></tr><tr class="miss"><td class="line">235</td><td class="hits">0</td><td class="source">      break;</td></tr><tr><td class="line">236</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">  // var tableName = new byte[offset];</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source">  // System.arraycopy(regionName, 0, tableName, 0, offset);</td></tr><tr class="miss"><td class="line">240</td><td class="hits">0</td><td class="source">  return regionName.slice(0, offset);</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">244</td><td class="hits"></td><td class="source"> * Separate elements of a regionName.</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source"> * @param regionName</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source"> * @return Array of byte[] containing tableName, startKey and id</td></tr><tr><td class="line">248</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">249</td><td class="hits">1</td><td class="source">HRegionInfo.parseRegionName = function (regionName) {</td></tr><tr class="miss"><td class="line">250</td><td class="hits">0</td><td class="source">  var offset = -1;</td></tr><tr class="miss"><td class="line">251</td><td class="hits">0</td><td class="source">  for (var i = 0; i &lt; regionName.length; i++) {</td></tr><tr class="miss"><td class="line">252</td><td class="hits">0</td><td class="source">    if (regionName[i] === HRegionInfo.DELIMITER) {</td></tr><tr class="miss"><td class="line">253</td><td class="hits">0</td><td class="source">      offset = i;</td></tr><tr class="miss"><td class="line">254</td><td class="hits">0</td><td class="source">      break;</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">257</td><td class="hits">0</td><td class="source">  if (offset === -1) {</td></tr><tr class="miss"><td class="line">258</td><td class="hits">0</td><td class="source">    throw new IOException(&quot;Invalid regionName format&quot;);</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">  // byte[] tableName = new byte[offset];</td></tr><tr><td class="line">261</td><td class="hits"></td><td class="source">  // System.arraycopy(regionName, 0, tableName, 0, offset);</td></tr><tr class="miss"><td class="line">262</td><td class="hits">0</td><td class="source">  var tableName = regionName.slice(0, offset);</td></tr><tr class="miss"><td class="line">263</td><td class="hits">0</td><td class="source">  offset = -1;</td></tr><tr class="miss"><td class="line">264</td><td class="hits">0</td><td class="source">  for (i = regionName.length - 1; i &gt; 0; i--) {</td></tr><tr class="miss"><td class="line">265</td><td class="hits">0</td><td class="source">    if (regionName[i] === HRegionInfo.DELIMITER) {</td></tr><tr class="miss"><td class="line">266</td><td class="hits">0</td><td class="source">      offset = i;</td></tr><tr class="miss"><td class="line">267</td><td class="hits">0</td><td class="source">      break;</td></tr><tr><td class="line">268</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">269</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">270</td><td class="hits">0</td><td class="source">  if (offset === -1) {</td></tr><tr class="miss"><td class="line">271</td><td class="hits">0</td><td class="source">    throw new IOException(&quot;Invalid regionName format&quot;);</td></tr><tr><td class="line">272</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">273</td><td class="hits">0</td><td class="source">  var startKey = HConstants.EMPTY_BYTE_ARRAY;</td></tr><tr class="miss"><td class="line">274</td><td class="hits">0</td><td class="source">  if (offset !== tableName.length + 1) {</td></tr><tr><td class="line">275</td><td class="hits"></td><td class="source">    // startKey = new byte[offset - tableName.length - 1];</td></tr><tr><td class="line">276</td><td class="hits"></td><td class="source">    // System.arraycopy(regionName, tableName.length + 1, startKey, 0, offset - tableName.length - 1);</td></tr><tr class="miss"><td class="line">277</td><td class="hits">0</td><td class="source">    startKey = regionName.slice(tableName.length + 1, offset);</td></tr><tr><td class="line">278</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">279</td><td class="hits">0</td><td class="source">  var idOffset = offset + 1;</td></tr><tr class="miss"><td class="line">280</td><td class="hits">0</td><td class="source">  var idLength = regionName.length - offset - 1;</td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source">  // var id = new byte[regionName.length - offset - 1];</td></tr><tr><td class="line">282</td><td class="hits"></td><td class="source">  // System.arraycopy(regionName, offset + 1, id, 0, regionName.length - offset - 1);</td></tr><tr class="miss"><td class="line">283</td><td class="hits">0</td><td class="source">  var id = regionName.slice(idOffset, idOffset + idLength);</td></tr><tr><td class="line">284</td><td class="hits"></td><td class="source">  // byte[][] elements = new byte[3][];</td></tr><tr><td class="line">285</td><td class="hits"></td><td class="source">  // elements[0] = tableName;</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">  // elements[1] = startKey;</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source">  // elements[2] = id;</td></tr><tr class="miss"><td class="line">288</td><td class="hits">0</td><td class="source">  return [</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source">    tableName,</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source">    startKey,</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source">    id</td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source">  ];</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">296</td><td class="hits"></td><td class="source"> * @return the regionName as an array of bytes.</td></tr><tr><td class="line">297</td><td class="hits"></td><td class="source"> * @see #getRegionNameAsString()</td></tr><tr><td class="line">298</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">299</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getRegionName = function () {</td></tr><tr class="hit"><td class="line">300</td><td class="hits">116</td><td class="source">  return this.regionName;</td></tr><tr><td class="line">301</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">302</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">303</td><td class="hits"></td><td class="source">/** @return the startKey */</td></tr><tr class="hit"><td class="line">304</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getStartKey = function () {</td></tr><tr class="miss"><td class="line">305</td><td class="hits">0</td><td class="source">  return this.startKey;</td></tr><tr><td class="line">306</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">307</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">308</td><td class="hits"></td><td class="source">/** @return the endKey */</td></tr><tr class="hit"><td class="line">309</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getEndKey = function () {</td></tr><tr class="miss"><td class="line">310</td><td class="hits">0</td><td class="source">  return this.endKey;</td></tr><tr><td class="line">311</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">312</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">313</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">314</td><td class="hits"></td><td class="source"> * Get current table name of the region</td></tr><tr><td class="line">315</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source"> * @return byte array of table name</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">318</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getTableName = function () {</td></tr><tr class="hit"><td class="line">319</td><td class="hits">25</td><td class="source">  if (!this.tableName || this.tableName.length === 0) {</td></tr><tr class="miss"><td class="line">320</td><td class="hits">0</td><td class="source">    this.tableName = HRegionInfo.getTableName(this.getRegionName());</td></tr><tr><td class="line">321</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">322</td><td class="hits">25</td><td class="source">  return this.tableName;</td></tr><tr><td class="line">323</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">324</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">325</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">326</td><td class="hits"></td><td class="source"> * Get current table name as string</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source"> * @return string representation of current table</td></tr><tr><td class="line">329</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">330</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getTableNameAsString = function () {</td></tr><tr class="miss"><td class="line">331</td><td class="hits">0</td><td class="source">  return Bytes.toString(this.getTableName());</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">334</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source"> * Returns true if the given inclusive range of rows is fully contained</td></tr><tr><td class="line">336</td><td class="hits"></td><td class="source"> * by this region. For example, if the region is foo,a,g and this is</td></tr><tr><td class="line">337</td><td class="hits"></td><td class="source"> * passed [&quot;b&quot;,&quot;c&quot;] or [&quot;a&quot;,&quot;c&quot;] it will return true, but if this is passed</td></tr><tr><td class="line">338</td><td class="hits"></td><td class="source"> * [&quot;b&quot;,&quot;z&quot;] it will return false.</td></tr><tr><td class="line">339</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">340</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.containsRange = function (rangeStartKey, rangeEndKey) {</td></tr><tr class="miss"><td class="line">341</td><td class="hits">0</td><td class="source">  var firstKeyInRange = Bytes.compareTo(rangeStartKey, this.startKey) &gt;= 0;</td></tr><tr class="miss"><td class="line">342</td><td class="hits">0</td><td class="source">  var lastKeyInRange = Bytes.compareTo(rangeEndKey, this.endKey) &lt; 0 || </td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source">    Bytes.equals(this.endKey, HConstants.EMPTY_BYTE_ARRAY);</td></tr><tr class="miss"><td class="line">344</td><td class="hits">0</td><td class="source">  return firstKeyInRange &amp;&amp; lastKeyInRange;</td></tr><tr><td class="line">345</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">346</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">347</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">348</td><td class="hits"></td><td class="source"> * Return true if the given row falls in this region.</td></tr><tr><td class="line">349</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">350</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.containsRow = function (row) {</td></tr><tr class="miss"><td class="line">351</td><td class="hits">0</td><td class="source">  return Bytes.compareTo(row, this.startKey) &gt;= 0 &amp;&amp; </td></tr><tr><td class="line">352</td><td class="hits"></td><td class="source">    (Bytes.compareTo(row, this.endKey) &lt; 0 || Bytes.equals(this.endKey, HConstants.EMPTY_BYTE_ARRAY));</td></tr><tr><td class="line">353</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source">/** @return true if this is the root region */</td></tr><tr class="hit"><td class="line">356</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isRootRegion = function () {</td></tr><tr class="miss"><td class="line">357</td><td class="hits">0</td><td class="source">  return Bytes.equals(this.tableName, HRegionInfo.ROOT_REGIONINFO.getTableName());</td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">359</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source">/** @return true if this region is from a table that is a meta table,</td></tr><tr><td class="line">361</td><td class="hits"></td><td class="source"> * either &lt;code&gt;.META.&lt;/code&gt; or &lt;code&gt;-ROOT-&lt;/code&gt;</td></tr><tr><td class="line">362</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">363</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isMetaTable = function () {</td></tr><tr class="miss"><td class="line">364</td><td class="hits">0</td><td class="source">  return this.isRootRegion() || this.isMetaRegion();</td></tr><tr><td class="line">365</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">366</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source">/** @return true if this region is a meta region */</td></tr><tr class="hit"><td class="line">368</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isMetaRegion = function () {</td></tr><tr class="miss"><td class="line">369</td><td class="hits">0</td><td class="source">  return Bytes.equals(this.tableName, HRegionInfo.FIRST_META_REGIONINFO.getTableName());</td></tr><tr><td class="line">370</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">371</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source"> * @return True if has been split and has daughters.</td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">375</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isSplit = function () {</td></tr><tr class="hit"><td class="line">376</td><td class="hits">190</td><td class="source">  return this.split;</td></tr><tr><td class="line">377</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">378</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">379</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">380</td><td class="hits"></td><td class="source"> * @param split set split status</td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">382</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.setSplit = function (split) {</td></tr><tr class="miss"><td class="line">383</td><td class="hits">0</td><td class="source">  this.split = split;</td></tr><tr><td class="line">384</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">385</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source"> * @return True if this region is offline.</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">389</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isOffline = function () {</td></tr><tr class="hit"><td class="line">390</td><td class="hits">190</td><td class="source">  return this.offLine;</td></tr><tr><td class="line">391</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">393</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">394</td><td class="hits"></td><td class="source"> * The parent of a region split is offline while split daughters hold</td></tr><tr><td class="line">395</td><td class="hits"></td><td class="source"> * references to the parent. Offlined regions are closed.</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">397</td><td class="hits"></td><td class="source"> * @param offLine Set online/offline status.</td></tr><tr><td class="line">398</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">399</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.setOffline = function (offLine) {</td></tr><tr class="miss"><td class="line">400</td><td class="hits">0</td><td class="source">  this.offLine = offLine;</td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">402</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">403</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">404</td><td class="hits"></td><td class="source"> * @return True if this is a split parent region.</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">406</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.isSplitParent = function () {</td></tr><tr class="miss"><td class="line">407</td><td class="hits">0</td><td class="source">  if (!this.isSplit()) {</td></tr><tr class="miss"><td class="line">408</td><td class="hits">0</td><td class="source">    return false;</td></tr><tr><td class="line">409</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">410</td><td class="hits">0</td><td class="source">  if (!this.isOffline()) {</td></tr><tr class="miss"><td class="line">411</td><td class="hits">0</td><td class="source">    console.warn(&quot;Region is split but NOT offline: &quot; + this.getRegionNameAsString());</td></tr><tr><td class="line">412</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">413</td><td class="hits">0</td><td class="source">  return true;</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">416</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">417</td><td class="hits"></td><td class="source"> * @see java.lang.Object#toString()</td></tr><tr><td class="line">418</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">419</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.toString = function () {</td></tr><tr class="hit"><td class="line">420</td><td class="hits">62</td><td class="source">  return &quot;{ID =&gt; &quot; + this.regionId.toString() + &quot;, NAME =&gt; '&quot; + this.regionNameStr + </td></tr><tr><td class="line">421</td><td class="hits"></td><td class="source">    &quot;', STARTKEY =&gt; '&quot; + Bytes.toStringBinary(this.startKey) + </td></tr><tr><td class="line">422</td><td class="hits"></td><td class="source">    &quot;', ENDKEY =&gt; '&quot; + Bytes.toStringBinary(this.endKey) + &quot;', &quot; +</td></tr><tr><td class="line">423</td><td class="hits"></td><td class="source">    // &quot;', ENCODED =&gt; &quot; + this.getEncodedName() + &quot;,&quot; + </td></tr><tr><td class="line">424</td><td class="hits"></td><td class="source">    (this.isOffline() ? &quot; OFFLINE =&gt; true,&quot; : &quot;&quot;) + (this.isSplit() ? &quot; SPLIT =&gt; true,&quot; : &quot;&quot;) + &quot;}&quot;;</td></tr><tr><td class="line">425</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">426</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">427</td><td class="hits"></td><td class="source">/** @return the object version number */</td></tr><tr class="hit"><td class="line">428</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.getVersion = function () {</td></tr><tr class="hit"><td class="line">429</td><td class="hits">267</td><td class="source">  return HRegionInfo.VERSION;</td></tr><tr><td class="line">430</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">431</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">432</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.readFields = function (io) {</td></tr><tr><td class="line">433</td><td class="hits"></td><td class="source">  // Read the single version byte.  We don't ask the super class do it</td></tr><tr><td class="line">434</td><td class="hits"></td><td class="source">  // because freaks out if its not the current classes' version.  This method</td></tr><tr><td class="line">435</td><td class="hits"></td><td class="source">  // can deserialize version 0 and version 1 of HRI.</td></tr><tr class="hit"><td class="line">436</td><td class="hits">267</td><td class="source">  var version = io.readByte();</td></tr><tr class="hit"><td class="line">437</td><td class="hits">267</td><td class="source">  if (version === 0) {</td></tr><tr><td class="line">438</td><td class="hits"></td><td class="source">    // This is the old HRI that carried an HTD.  Migrate it.  The below</td></tr><tr><td class="line">439</td><td class="hits"></td><td class="source">    // was copied from the old 0.90 HRI readFields.</td></tr><tr class="miss"><td class="line">440</td><td class="hits">0</td><td class="source">    this.endKey = Bytes.readByteArray(io);</td></tr><tr class="miss"><td class="line">441</td><td class="hits">0</td><td class="source">    this.offLine = io.readBoolean();</td></tr><tr class="miss"><td class="line">442</td><td class="hits">0</td><td class="source">    this.regionId = io.readLong();</td></tr><tr class="miss"><td class="line">443</td><td class="hits">0</td><td class="source">    this.regionName = Bytes.readByteArray(io);</td></tr><tr class="miss"><td class="line">444</td><td class="hits">0</td><td class="source">    this.regionNameStr = Bytes.toStringBinary(this.regionName);</td></tr><tr class="miss"><td class="line">445</td><td class="hits">0</td><td class="source">    this.split = io.readBoolean();</td></tr><tr class="miss"><td class="line">446</td><td class="hits">0</td><td class="source">    this.startKey = Bytes.readByteArray(io);</td></tr><tr><td class="line">447</td><td class="hits"></td><td class="source">    // try {</td></tr><tr><td class="line">448</td><td class="hits"></td><td class="source">    //   HTableDescriptor htd = new HTableDescriptor();</td></tr><tr><td class="line">449</td><td class="hits"></td><td class="source">    //   htd.readFields(in);</td></tr><tr><td class="line">450</td><td class="hits"></td><td class="source">    //   this.tableName = htd.getName();</td></tr><tr><td class="line">451</td><td class="hits"></td><td class="source">    // } catch (EOFException eofe) {</td></tr><tr><td class="line">452</td><td class="hits"></td><td class="source">    //   throw new IOException(&quot;HTD not found in input buffer&quot;, eofe);</td></tr><tr><td class="line">453</td><td class="hits"></td><td class="source">    // }</td></tr><tr class="miss"><td class="line">454</td><td class="hits">0</td><td class="source">    this.hashCode = io.readInt();</td></tr><tr class="hit"><td class="line">455</td><td class="hits">267</td><td class="source">  } else if (this.getVersion() === version) {</td></tr><tr class="hit"><td class="line">456</td><td class="hits">267</td><td class="source">    this.endKey = io.readByteArray();</td></tr><tr class="hit"><td class="line">457</td><td class="hits">267</td><td class="source">    this.offLine = io.readBoolean();</td></tr><tr class="hit"><td class="line">458</td><td class="hits">267</td><td class="source">    this.regionId = io.readLong();</td></tr><tr class="hit"><td class="line">459</td><td class="hits">267</td><td class="source">    this.regionName = io.readByteArray();</td></tr><tr class="hit"><td class="line">460</td><td class="hits">267</td><td class="source">    this.regionNameStr = Bytes.toStringBinary(this.regionName);</td></tr><tr class="hit"><td class="line">461</td><td class="hits">267</td><td class="source">    this.split = io.readBoolean();</td></tr><tr class="hit"><td class="line">462</td><td class="hits">267</td><td class="source">    this.startKey = io.readByteArray();</td></tr><tr class="hit"><td class="line">463</td><td class="hits">267</td><td class="source">    this.tableName = io.readByteArray();</td></tr><tr class="hit"><td class="line">464</td><td class="hits">267</td><td class="source">    this.hashCode = io.readInt();</td></tr><tr><td class="line">465</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">466</td><td class="hits">0</td><td class="source">    throw new IOException(&quot;Non-migratable/unknown version=&quot; + this.getVersion());</td></tr><tr><td class="line">467</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">468</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">469</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">470</td><td class="hits">1</td><td class="source">HRegionInfo.prototype.compareTo = function (o) {</td></tr><tr class="hit"><td class="line">471</td><td class="hits">1395</td><td class="source">  if (!o) {</td></tr><tr class="miss"><td class="line">472</td><td class="hits">0</td><td class="source">    return 1;</td></tr><tr><td class="line">473</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">474</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">475</td><td class="hits"></td><td class="source">  // Are regions of same table?</td></tr><tr class="hit"><td class="line">476</td><td class="hits">1395</td><td class="source">  var result = Bytes.compareTo(this.tableName, o.tableName);</td></tr><tr class="hit"><td class="line">477</td><td class="hits">1395</td><td class="source">  if (result !== 0) {</td></tr><tr class="miss"><td class="line">478</td><td class="hits">0</td><td class="source">    return result;</td></tr><tr><td class="line">479</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">480</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">481</td><td class="hits"></td><td class="source">  // Compare start keys.</td></tr><tr class="hit"><td class="line">482</td><td class="hits">1395</td><td class="source">  result = Bytes.compareTo(this.startKey, o.startKey);</td></tr><tr class="hit"><td class="line">483</td><td class="hits">1395</td><td class="source">  if (result !== 0) {</td></tr><tr class="hit"><td class="line">484</td><td class="hits">1338</td><td class="source">    return result;</td></tr><tr><td class="line">485</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">486</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">487</td><td class="hits"></td><td class="source">  // Compare end keys.</td></tr><tr class="hit"><td class="line">488</td><td class="hits">57</td><td class="source">  result = Bytes.compareTo(this.endKey, o.endKey);</td></tr><tr><td class="line">489</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">490</td><td class="hits">57</td><td class="source">  if (result !== 0) {</td></tr><tr class="miss"><td class="line">491</td><td class="hits">0</td><td class="source">    if (this.startKey.length !== 0 &amp;&amp; this.endKey.length === 0) {</td></tr><tr class="miss"><td class="line">492</td><td class="hits">0</td><td class="source">      return 1; // this is last region</td></tr><tr><td class="line">493</td><td class="hits"></td><td class="source">    }</td></tr><tr class="miss"><td class="line">494</td><td class="hits">0</td><td class="source">    if (o.startKey.length !== 0 &amp;&amp; o.endKey.length === 0) {</td></tr><tr class="miss"><td class="line">495</td><td class="hits">0</td><td class="source">      return -1; // o is the last region</td></tr><tr><td class="line">496</td><td class="hits"></td><td class="source">    }</td></tr><tr class="miss"><td class="line">497</td><td class="hits">0</td><td class="source">    return result;</td></tr><tr><td class="line">498</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">499</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">500</td><td class="hits"></td><td class="source">  // regionId is usually milli timestamp -- this defines older stamps</td></tr><tr><td class="line">501</td><td class="hits"></td><td class="source">  // to be &quot;smaller&quot; than newer stamps in sort order.</td></tr><tr class="hit"><td class="line">502</td><td class="hits">57</td><td class="source">  if (this.regionId.greaterThan(o.regionId)) {</td></tr><tr class="miss"><td class="line">503</td><td class="hits">0</td><td class="source">    return 1;</td></tr><tr class="hit"><td class="line">504</td><td class="hits">57</td><td class="source">  } else if (this.regionId.lessThan(o.regionId)) {</td></tr><tr class="miss"><td class="line">505</td><td class="hits">0</td><td class="source">    return -1;</td></tr><tr><td class="line">506</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">507</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">508</td><td class="hits">57</td><td class="source">  if (this.offLine === o.offLine) {</td></tr><tr class="hit"><td class="line">509</td><td class="hits">57</td><td class="source">    return 0;</td></tr><tr><td class="line">510</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">511</td><td class="hits"></td><td class="source">  </td></tr><tr class="miss"><td class="line">512</td><td class="hits">0</td><td class="source">  if (this.offLine === true) {</td></tr><tr class="miss"><td class="line">513</td><td class="hits">0</td><td class="source">    return -1;</td></tr><tr><td class="line">514</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">515</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">516</td><td class="hits">0</td><td class="source">  return 1;</td></tr><tr><td class="line">517</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">518</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">519</td><td class="hits">1</td><td class="source">HRegionInfo.createRegionName = createRegionName;</td></tr><tr><td class="line">520</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">521</td><td class="hits"></td><td class="source">/** HRegionInfo for root region */</td></tr><tr class="hit"><td class="line">522</td><td class="hits">1</td><td class="source">HRegionInfo.ROOT_REGIONINFO = new HRegionInfo(0, HConstants.ROOT_TABLE_NAME);</td></tr><tr class="hit"><td class="line">523</td><td class="hits">1</td><td class="source">HRegionInfo.ROOT_REGIONINFO.isRoot = true;</td></tr><tr><td class="line">524</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">525</td><td class="hits"></td><td class="source">/** HRegionInfo for first meta region */</td></tr><tr class="hit"><td class="line">526</td><td class="hits">1</td><td class="source">HRegionInfo.FIRST_META_REGIONINFO = new HRegionInfo(1, HConstants.META_TABLE_NAME);</td></tr><tr class="hit"><td class="line">527</td><td class="hits">1</td><td class="source">HRegionInfo.FIRST_META_REGIONINFO.isMeta = true;</td></tr><tr><td class="line">528</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">529</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">530</td><td class="hits">1</td><td class="source">module.exports = HRegionInfo;</td></tr><tr><td class="line">531</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/hregion_location.js">/Users/mk2/git/node-hbase-client/lib/hregion_location.js</h2><div id="stats" class="high"><div class="percentage">94%</div><div class="sloc">19</div><div class="hits">18</div><div class="misses">1</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/hregion_location.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> * Data structure to hold HRegionInfo and the address for the hosting</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> * HRegionServer.  Immutable.  Comparable, but we compare the 'location' only:</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> * i.e. the hostname and port, and *not* the regioninfo.  This means two</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> * instances are the same if they refer to the same 'location' (the same</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> * hostname and port), though they may be carrying different regions.</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">function HRegionLocation(regionInfo, hostname, port) {</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  // Cache of the 'toString' result.</td></tr><tr class="hit"><td class="line">22</td><td class="hits">306</td><td class="source">  this.cachedString = null;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  // Cache of the hostname + port</td></tr><tr class="hit"><td class="line">24</td><td class="hits">306</td><td class="source">  this.cachedHostnamePort = null;</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">   * Constructor</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">   * @param regionInfo the HRegionInfo for the region</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">   * @param hostname Hostname</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">   * @param port port</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">   */</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  // public HRegionLocation(HRegionInfo regionInfo, final String hostname, final int port) {</td></tr><tr class="hit"><td class="line">33</td><td class="hits">306</td><td class="source">  this.regionInfo = regionInfo;</td></tr><tr class="hit"><td class="line">34</td><td class="hits">306</td><td class="source">  this.hostname = hostname;</td></tr><tr class="hit"><td class="line">35</td><td class="hits">306</td><td class="source">  this.port = port;</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">38</td><td class="hits">1</td><td class="source">HRegionLocation.prototype = {</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  toString: function () {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">62</td><td class="source">    if (this.cachedString === null) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">62</td><td class="source">      this.cachedString = &quot;region=&quot; + this.regionInfo.toString() + </td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">        &quot;, hostname=&quot; + this.hostname + &quot;, port=&quot; + this.port;</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">44</td><td class="hits">62</td><td class="source">    return this.cachedString;</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  /** @return HRegionInfo */</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  getRegionInfo: function () {</td></tr><tr class="hit"><td class="line">49</td><td class="hits">116</td><td class="source">    return this.regionInfo;</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  getServerAddress: function () {</td></tr><tr class="miss"><td class="line">53</td><td class="hits">0</td><td class="source">    return {hostname: this.hostname, port: this.port};</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  getHostname: function () {</td></tr><tr class="hit"><td class="line">57</td><td class="hits">118</td><td class="source">    return this.hostname;</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  getPort: function () {</td></tr><tr class="hit"><td class="line">61</td><td class="hits">118</td><td class="source">    return this.port;</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  getHostnamePort: function () {</td></tr><tr class="hit"><td class="line">65</td><td class="hits">173</td><td class="source">    if (this.cachedHostnamePort === null) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">70</td><td class="source">      this.cachedHostnamePort = this.hostname + ':' + this.port;</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">68</td><td class="hits">173</td><td class="source">    return this.cachedHostnamePort;</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">73</td><td class="hits">1</td><td class="source">module.exports = HRegionLocation;</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/io/hbase_object_writable.js">/Users/mk2/git/node-hbase-client/lib/io/hbase_object_writable.js</h2><div id="stats" class="high"><div class="percentage">91%</div><div class="sloc">188</div><div class="hits">172</div><div class="misses">16</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/io/hbase_object_writable.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var debug = require('debug')('hbase:writable');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Bytes = require('../util/bytes');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var WritableUtils = require('../writable_utils');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var Text = require('../text');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var IOException = require('../errors').IOException;</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var UnsupportedOperationException = require('../errors').UnsupportedOperationException;</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var CODE_TO_CLASS = {};</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">var CLASS_TO_CODE = {};</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">var CLASSES = {};</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">1</td><td class="source">var addToMap = function (clazzName, code) {</td></tr><tr class="hit"><td class="line">27</td><td class="hits">81</td><td class="source">  CLASS_TO_CODE[clazzName] = code;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">81</td><td class="source">  CODE_TO_CLASS[code] = clazzName;</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">exports.addToClass = function (name, clazz) {</td></tr><tr class="hit"><td class="line">32</td><td class="hits">2</td><td class="source">  CLASSES[name] = clazz;</td></tr><tr class="hit"><td class="line">33</td><td class="hits">2</td><td class="source">  clazz.__classname = name;</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">////////////////////////////////////////////////////////////////////////////</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">// WARNING: Please do not insert, remove or swap any line in this static  //</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">// block.  Doing so would change or shift all the codes used to serialize //</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">// objects, which makes backwards compatibility very hard for clients.    //</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">// New codes should always be added at the end. Code removal is           //</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">// discouraged because code is a short now.                               //</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">////////////////////////////////////////////////////////////////////////////</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">44</td><td class="hits">1</td><td class="source">var NOT_ENCODED = 0;</td></tr><tr class="hit"><td class="line">45</td><td class="hits">1</td><td class="source">var code = NOT_ENCODED + 1;</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">// Primitive types.</td></tr><tr class="hit"><td class="line">47</td><td class="hits">1</td><td class="source">addToMap('Boolean.TYPE', code++);</td></tr><tr class="hit"><td class="line">48</td><td class="hits">1</td><td class="source">addToMap('Byte.TYPE', code++);</td></tr><tr class="hit"><td class="line">49</td><td class="hits">1</td><td class="source">addToMap('Character.TYPE', code++);</td></tr><tr class="hit"><td class="line">50</td><td class="hits">1</td><td class="source">addToMap('Short.TYPE', code++);</td></tr><tr class="hit"><td class="line">51</td><td class="hits">1</td><td class="source">addToMap('Integer.TYPE', code++);</td></tr><tr class="hit"><td class="line">52</td><td class="hits">1</td><td class="source">addToMap('Long.TYPE', code++);</td></tr><tr class="hit"><td class="line">53</td><td class="hits">1</td><td class="source">addToMap('Float.TYPE', code++);</td></tr><tr class="hit"><td class="line">54</td><td class="hits">1</td><td class="source">addToMap('Double.TYPE', code++);</td></tr><tr class="hit"><td class="line">55</td><td class="hits">1</td><td class="source">addToMap('Void.TYPE', code++);</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">// Other java types</td></tr><tr class="hit"><td class="line">58</td><td class="hits">1</td><td class="source">addToMap('String.class', code++);</td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">addToMap('byte[].class', code++);</td></tr><tr class="hit"><td class="line">60</td><td class="hits">1</td><td class="source">addToMap('byte[][].class', code++);</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">// Hadoop types</td></tr><tr class="hit"><td class="line">63</td><td class="hits">1</td><td class="source">addToMap('Text.class', code++);</td></tr><tr class="hit"><td class="line">64</td><td class="hits">1</td><td class="source">addToMap('Writable.class', code++);</td></tr><tr class="hit"><td class="line">65</td><td class="hits">1</td><td class="source">addToMap('Writable[].class', code++);</td></tr><tr class="hit"><td class="line">66</td><td class="hits">1</td><td class="source">addToMap('HbaseMapWritable.class', code++);</td></tr><tr class="hit"><td class="line">67</td><td class="hits">1</td><td class="source">addToMap('NullInstance.class', code++);</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">// Hbase types</td></tr><tr class="hit"><td class="line">70</td><td class="hits">1</td><td class="source">addToMap('HColumnDescriptor.class', code++);</td></tr><tr class="hit"><td class="line">71</td><td class="hits">1</td><td class="source">addToMap('HConstants.Modify.class', code++);</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">73</td><td class="hits">1</td><td class="source">addToMap('Integer.class', code++);</td></tr><tr class="hit"><td class="line">74</td><td class="hits">1</td><td class="source">addToMap('Integer[].class', code++);</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">76</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">77</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">78</td><td class="hits">1</td><td class="source">addToMap('HRegionInfo.class', code++);</td></tr><tr class="hit"><td class="line">79</td><td class="hits">1</td><td class="source">addToMap('HRegionInfo[].class', code++);</td></tr><tr class="hit"><td class="line">80</td><td class="hits">1</td><td class="source">addToMap('HServerAddress.class', code++);</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">82</td><td class="hits">1</td><td class="source">addToMap('HTableDescriptor.class', code++);</td></tr><tr class="hit"><td class="line">83</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">// HBASE-880</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">//</td></tr><tr class="hit"><td class="line">88</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">89</td><td class="hits">1</td><td class="source">addToMap('Delete.class', code++);</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1</td><td class="source">addToMap('Get.class', code++);</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">addToMap('KeyValue.class', code++);</td></tr><tr class="hit"><td class="line">92</td><td class="hits">1</td><td class="source">addToMap('KeyValue[].class', code++);</td></tr><tr class="hit"><td class="line">93</td><td class="hits">1</td><td class="source">addToMap('Put.class', code++);</td></tr><tr class="hit"><td class="line">94</td><td class="hits">1</td><td class="source">addToMap('Put[].class', code++);</td></tr><tr class="hit"><td class="line">95</td><td class="hits">1</td><td class="source">addToMap('Result.class', code++);</td></tr><tr class="hit"><td class="line">96</td><td class="hits">1</td><td class="source">addToMap('Result[].class', code++);</td></tr><tr class="hit"><td class="line">97</td><td class="hits">1</td><td class="source">addToMap('Scan.class', code++);</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">addToMap('WhileMatchFilter.class', code++);</td></tr><tr class="hit"><td class="line">100</td><td class="hits">1</td><td class="source">addToMap('PrefixFilter.class', code++);</td></tr><tr class="hit"><td class="line">101</td><td class="hits">1</td><td class="source">addToMap('PageFilter.class', code++);</td></tr><tr class="hit"><td class="line">102</td><td class="hits">1</td><td class="source">addToMap('InclusiveStopFilter.class', code++);</td></tr><tr class="hit"><td class="line">103</td><td class="hits">1</td><td class="source">addToMap('ColumnCountGetFilter.class', code++);</td></tr><tr class="hit"><td class="line">104</td><td class="hits">1</td><td class="source">addToMap('SingleColumnValueFilter.class', code++);</td></tr><tr class="hit"><td class="line">105</td><td class="hits">1</td><td class="source">addToMap('SingleColumnValueExcludeFilter.class', code++);</td></tr><tr class="hit"><td class="line">106</td><td class="hits">1</td><td class="source">addToMap('BinaryComparator.class', code++);</td></tr><tr class="hit"><td class="line">107</td><td class="hits">1</td><td class="source">addToMap('BitComparator.class', code++);</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1</td><td class="source">addToMap('CompareFilter.class', code++);</td></tr><tr class="hit"><td class="line">109</td><td class="hits">1</td><td class="source">addToMap('RowFilter.class', code++);</td></tr><tr class="hit"><td class="line">110</td><td class="hits">1</td><td class="source">addToMap('ValueFilter.class', code++);</td></tr><tr class="hit"><td class="line">111</td><td class="hits">1</td><td class="source">addToMap('QualifierFilter.class', code++);</td></tr><tr class="hit"><td class="line">112</td><td class="hits">1</td><td class="source">addToMap('SkipFilter.class', code++);</td></tr><tr class="hit"><td class="line">113</td><td class="hits">1</td><td class="source">addToMap('WritableByteArrayComparable.class', code++);</td></tr><tr class="hit"><td class="line">114</td><td class="hits">1</td><td class="source">addToMap('FirstKeyOnlyFilter.class', code++);</td></tr><tr class="hit"><td class="line">115</td><td class="hits">1</td><td class="source">addToMap('DependentColumnFilter.class', code++);</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">117</td><td class="hits">1</td><td class="source">addToMap('Delete[].class', code++);</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">119</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">120</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr class="hit"><td class="line">121</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">123</td><td class="hits">1</td><td class="source">addToMap('List.class', code++);</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">125</td><td class="hits">1</td><td class="source">addToMap('NavigableSet.class', code++);</td></tr><tr class="hit"><td class="line">126</td><td class="hits">1</td><td class="source">addToMap('ColumnPrefixFilter.class', code++);</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">// Multi</td></tr><tr class="hit"><td class="line">129</td><td class="hits">1</td><td class="source">addToMap('Row.class', code++);</td></tr><tr class="hit"><td class="line">130</td><td class="hits">1</td><td class="source">addToMap('Action.class', code++);</td></tr><tr class="hit"><td class="line">131</td><td class="hits">1</td><td class="source">addToMap('MultiAction.class', code++);</td></tr><tr class="hit"><td class="line">132</td><td class="hits">1</td><td class="source">addToMap('MultiResponse.class', code++);</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">// coprocessor execution</td></tr><tr class="hit"><td class="line">135</td><td class="hits">1</td><td class="source">addToMap('Exec.class', code++);</td></tr><tr class="hit"><td class="line">136</td><td class="hits">1</td><td class="source">addToMap('Increment.class', code++);</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">138</td><td class="hits">1</td><td class="source">addToMap('KeyOnlyFilter.class', code++);</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">// serializable</td></tr><tr class="hit"><td class="line">141</td><td class="hits">1</td><td class="source">addToMap('Serializable.class', code++);</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">143</td><td class="hits">1</td><td class="source">addToMap('RandomRowFilter.class', code++);</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">145</td><td class="hits">1</td><td class="source">addToMap('CompareOp.class', code++);</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">147</td><td class="hits">1</td><td class="source">addToMap('ColumnRangeFilter.class', code++);</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">149</td><td class="hits">1</td><td class="source">addToMap('HServerLoad.class', code++);</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">151</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">153</td><td class="hits">1</td><td class="source">addToMap('HTableDescriptor[].class', code++);</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">155</td><td class="hits">1</td><td class="source">addToMap('Append.class', code++);</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">157</td><td class="hits">1</td><td class="source">addToMap('RowMutations.class', code++);</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">159</td><td class="hits">1</td><td class="source">addToMap('MyClass.class', code++);</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">//java.lang.reflect.Array is a placeholder for arrays not defined above</td></tr><tr class="hit"><td class="line">162</td><td class="hits">1</td><td class="source">exports.GENERIC_ARRAY_CODE = code++;</td></tr><tr class="hit"><td class="line">163</td><td class="hits">1</td><td class="source">addToMap('Array.class', exports.GENERIC_ARRAY_CODE);</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">// make sure that this is the last statement in this static block</td></tr><tr class="hit"><td class="line">166</td><td class="hits">1</td><td class="source">exports.NEXT_CLASS_CODE = code;</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">168</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source"> * Read a {@link Writable}, {@link String}, primitive type, or an array of</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source"> * the preceding.</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source"> * @param io, input stream.</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source"> * @param objectWritable</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">175</td><td class="hits">1</td><td class="source">exports.readObject = function (io, objectWritable, conf) {</td></tr><tr class="hit"><td class="line">176</td><td class="hits">195</td><td class="source">  var code = io.readVInt();</td></tr><tr class="hit"><td class="line">177</td><td class="hits">195</td><td class="source">  var declaredClass = CODE_TO_CLASS[code];</td></tr><tr class="hit"><td class="line">178</td><td class="hits">195</td><td class="source">  debug('readObject: code: %s, class: %s', code, declaredClass);</td></tr><tr class="hit"><td class="line">179</td><td class="hits">195</td><td class="source">  var instance;</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source">  // primitive types</td></tr><tr class="hit"><td class="line">181</td><td class="hits">195</td><td class="source">  if (declaredClass === 'Boolean.TYPE') { // boolean</td></tr><tr class="miss"><td class="line">182</td><td class="hits">0</td><td class="source">    instance = io.readBoolean();</td></tr><tr class="hit"><td class="line">183</td><td class="hits">195</td><td class="source">  } else if (declaredClass === 'Character.TYPE') { // char</td></tr><tr class="miss"><td class="line">184</td><td class="hits">0</td><td class="source">    instance = io.readChar();</td></tr><tr class="hit"><td class="line">185</td><td class="hits">195</td><td class="source">  } else if (declaredClass === 'Byte.TYPE') { // byte</td></tr><tr class="miss"><td class="line">186</td><td class="hits">0</td><td class="source">    instance = io.readByte();</td></tr><tr class="hit"><td class="line">187</td><td class="hits">195</td><td class="source">  } else if (declaredClass === 'Short.TYPE') { // short</td></tr><tr class="miss"><td class="line">188</td><td class="hits">0</td><td class="source">    instance = io.readShort();</td></tr><tr class="hit"><td class="line">189</td><td class="hits">195</td><td class="source">  } else if (declaredClass === 'Integer.TYPE') { // int</td></tr><tr class="miss"><td class="line">190</td><td class="hits">0</td><td class="source">    instance = io.readInt();</td></tr><tr class="hit"><td class="line">191</td><td class="hits">195</td><td class="source">  } else if (declaredClass === 'Long.TYPE') { // long</td></tr><tr class="hit"><td class="line">192</td><td class="hits">44</td><td class="source">    instance = io.readLong();</td></tr><tr class="hit"><td class="line">193</td><td class="hits">151</td><td class="source">  } else if (declaredClass === 'Float.TYPE') { // float</td></tr><tr class="miss"><td class="line">194</td><td class="hits">0</td><td class="source">    instance = io.readFloat();</td></tr><tr class="hit"><td class="line">195</td><td class="hits">151</td><td class="source">  } else if (declaredClass === 'Double.TYPE') { // double</td></tr><tr class="miss"><td class="line">196</td><td class="hits">0</td><td class="source">    instance = io.readDouble();</td></tr><tr class="hit"><td class="line">197</td><td class="hits">151</td><td class="source">  } else if (declaredClass === 'Void.TYPE') { // void</td></tr><tr class="miss"><td class="line">198</td><td class="hits">0</td><td class="source">    instance = null;</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">    // array</td></tr><tr class="hit"><td class="line">200</td><td class="hits">151</td><td class="source">  } else if (declaredClass === 'byte[].class') {</td></tr><tr class="miss"><td class="line">201</td><td class="hits">0</td><td class="source">    instance = Bytes.readByteArray(io);</td></tr><tr class="hit"><td class="line">202</td><td class="hits">151</td><td class="source">  } else if (declaredClass === 'Result[].class') {</td></tr><tr class="hit"><td class="line">203</td><td class="hits">21</td><td class="source">    var Result = CLASSES['Result.class'];</td></tr><tr class="hit"><td class="line">204</td><td class="hits">21</td><td class="source">    instance = Result.readArray(io);</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">  // } else {</td></tr><tr><td class="line">206</td><td class="hits"></td><td class="source">  //   var length = io.readInt();</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">  //   instance = Array.newInstance(declaredClass.getComponentType(), length);</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">  //   for (var i = 0; i &lt; length; i++) {</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source">  //     Array.set(instance, i, readObject(io, null, conf));</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">  //   }</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source">  // } else if (declaredClass === 'Array.class') { //an array not declared in CLASS_TO_CODE</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">  //   // Class&lt;?&gt; componentType = readClass(conf, in);</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  //   var length = io.readInt();</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">    // console.log(declaredClass, length)</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">    // instance = Array.newInstance(componentType, length);</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">    // for (int i = 0; i &lt; length; i++) {</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">    //   Array.set(instance, i, readObject(in, conf));</td></tr><tr><td class="line">218</td><td class="hits"></td><td class="source">    // }</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source">  // } else if (List.class.isAssignableFrom(declaredClass)) { // List</td></tr><tr><td class="line">220</td><td class="hits"></td><td class="source">  //   int length = in.readInt();</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source">  //   instance = new ArrayList(length);</td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source">  //   for (int i = 0; i &lt; length; i++) {</td></tr><tr><td class="line">223</td><td class="hits"></td><td class="source">  //     ((ArrayList) instance).add(readObject(in, conf));</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">  //   }</td></tr><tr class="hit"><td class="line">225</td><td class="hits">130</td><td class="source">  } else if (declaredClass === 'String.class') { // String</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source">    // instance = Text.readString(io);</td></tr><tr class="miss"><td class="line">227</td><td class="hits">0</td><td class="source">    instance = io.readVString();</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">  // } else if (declaredClass.isEnum()) { // enum</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">  //   instance = Enum.valueOf((Class&lt;? extends Enum&gt;) declaredClass, Text.readString(in));</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">    </td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source">  //   //    } else if (declaredClass == Message.class) {</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source">  //   //      String className = Text.readString(in);</td></tr><tr><td class="line">233</td><td class="hits"></td><td class="source">  //   //      try {</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source">  //   //        declaredClass = getClassByName(conf, className);</td></tr><tr><td class="line">235</td><td class="hits"></td><td class="source">  //   //        instance = tryInstantiateProtobuf(declaredClass, in);</td></tr><tr><td class="line">236</td><td class="hits"></td><td class="source">  //   //      } catch (ClassNotFoundException e) {</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">  //   //        LOG.error(&quot;Can't find class &quot; + className, e);</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">  //   //        throw new IOException(&quot;Can't find class &quot; + className, e);</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source">  //   //      }</td></tr><tr><td class="line">240</td><td class="hits"></td><td class="source">  } else { </td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">    // Writable or Serializable</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source">    // int b = (byte) WritableUtils.readVInt(in);</td></tr><tr class="hit"><td class="line">243</td><td class="hits">130</td><td class="source">    var b = io.readVInt();</td></tr><tr class="hit"><td class="line">244</td><td class="hits">130</td><td class="source">    var name = CODE_TO_CLASS[b];</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source">    </td></tr><tr class="hit"><td class="line">246</td><td class="hits">130</td><td class="source">    debug('writable class: code: %s, name: %s', b, name);</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">248</td><td class="hits">130</td><td class="source">    if (b === NOT_ENCODED) {</td></tr><tr><td class="line">249</td><td class="hits"></td><td class="source">      // String className = Text.readString(in);</td></tr><tr class="miss"><td class="line">250</td><td class="hits">0</td><td class="source">      name = io.readVString();</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">      // try {</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">      //   instanceClass = getClassByName(conf, className);</td></tr><tr><td class="line">253</td><td class="hits"></td><td class="source">      // } catch (ClassNotFoundException e) {</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source">      //   LOG.error(&quot;Can't find class &quot; + className, e);</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source">      //   throw new IOException(&quot;Can't find class &quot; + className, e);</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source">      // }</td></tr><tr class="hit"><td class="line">257</td><td class="hits">130</td><td class="source">    } else if (name === 'NullInstance.class') {</td></tr><tr class="hit"><td class="line">258</td><td class="hits">33</td><td class="source">      instance = null;</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source">    } else {</td></tr><tr class="hit"><td class="line">260</td><td class="hits">97</td><td class="source">      var instanceClass = CLASSES[name];</td></tr><tr class="hit"><td class="line">261</td><td class="hits">97</td><td class="source">      instance = instanceClass();</td></tr><tr><td class="line">262</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">263</td><td class="hits">97</td><td class="source">      if (typeof instance.readFields === 'function') {</td></tr><tr class="hit"><td class="line">264</td><td class="hits">97</td><td class="source">        instance.readFields(io);</td></tr><tr><td class="line">265</td><td class="hits"></td><td class="source">      } else {</td></tr><tr class="miss"><td class="line">266</td><td class="hits">0</td><td class="source">        var len = io.readInt();</td></tr><tr class="miss"><td class="line">267</td><td class="hits">0</td><td class="source">        var objectBytes = io.read(len);</td></tr><tr class="miss"><td class="line">268</td><td class="hits">0</td><td class="source">        instance = objectBytes;</td></tr><tr><td class="line">269</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">270</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">271</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">272</td><td class="hits">130</td><td class="source">    declaredClass = name;</td></tr><tr><td class="line">273</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">274</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">275</td><td class="hits">195</td><td class="source">  if (objectWritable) { // store values</td></tr><tr class="hit"><td class="line">276</td><td class="hits">195</td><td class="source">    objectWritable.declaredClass = declaredClass;</td></tr><tr class="hit"><td class="line">277</td><td class="hits">195</td><td class="source">    objectWritable.instance = instance;</td></tr><tr><td class="line">278</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">279</td><td class="hits">195</td><td class="source">  return instance;</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">282</td><td class="hits">1</td><td class="source">exports.readFields = function (io) {</td></tr><tr class="hit"><td class="line">283</td><td class="hits">195</td><td class="source">  var obj = {};</td></tr><tr class="hit"><td class="line">284</td><td class="hits">195</td><td class="source">  exports.readObject(io, obj);</td></tr><tr class="hit"><td class="line">285</td><td class="hits">195</td><td class="source">  return obj;</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source"> * Write a {@link Writable}, {@link String}, primitive type, or an array of</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source"> * the preceding.</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source"> * @param out, output stream.</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source"> * @param instance</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source"> * @param declaredClass</td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">296</td><td class="hits">1</td><td class="source">exports.writeObject = function (out, instance, declaredClass) {</td></tr><tr class="hit"><td class="line">297</td><td class="hits">398</td><td class="source">  var name = instance.constructor.name;</td></tr><tr class="hit"><td class="line">298</td><td class="hits">398</td><td class="source">  var clazz = name + '.class';</td></tr><tr class="hit"><td class="line">299</td><td class="hits">398</td><td class="source">  if (Buffer.isBuffer(instance)) {</td></tr><tr class="hit"><td class="line">300</td><td class="hits">156</td><td class="source">    clazz = 'byte[].class';</td></tr><tr class="hit"><td class="line">301</td><td class="hits">156</td><td class="source">    exports.writeClassCode(out, clazz);</td></tr><tr class="hit"><td class="line">302</td><td class="hits">156</td><td class="source">    Bytes.writeByteArray(out, instance);</td></tr><tr class="hit"><td class="line">303</td><td class="hits">156</td><td class="source">    return;</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">305</td><td class="hits">242</td><td class="source">  if (instance instanceof Long) {</td></tr><tr class="hit"><td class="line">306</td><td class="hits">104</td><td class="source">    clazz = 'Long.TYPE';</td></tr><tr class="hit"><td class="line">307</td><td class="hits">104</td><td class="source">    exports.writeClassCode(out, clazz);</td></tr><tr class="hit"><td class="line">308</td><td class="hits">104</td><td class="source">    out.writeLong(instance);</td></tr><tr class="hit"><td class="line">309</td><td class="hits">104</td><td class="source">    return;</td></tr><tr><td class="line">310</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">311</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">312</td><td class="hits">138</td><td class="source">  if (clazz === 'Number.class') {</td></tr><tr class="hit"><td class="line">313</td><td class="hits">21</td><td class="source">    clazz = 'Integer.TYPE';</td></tr><tr><td class="line">314</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">315</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">316</td><td class="hits">138</td><td class="source">  exports.writeClassCode(out, clazz);</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source">  // writable</td></tr><tr class="hit"><td class="line">318</td><td class="hits">138</td><td class="source">  if (typeof instance.write === 'function') {</td></tr><tr class="hit"><td class="line">319</td><td class="hits">78</td><td class="source">    exports.writeClassCode(out, clazz);</td></tr><tr class="hit"><td class="line">320</td><td class="hits">78</td><td class="source">    instance.write(out);</td></tr><tr class="hit"><td class="line">321</td><td class="hits">78</td><td class="source">    return;</td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">323</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">324</td><td class="hits">60</td><td class="source">  if (clazz === 'String.class') {</td></tr><tr class="hit"><td class="line">325</td><td class="hits">39</td><td class="source">    Text.writeString(out, instance);</td></tr><tr class="hit"><td class="line">326</td><td class="hits">39</td><td class="source">    return;</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source">  // int</td></tr><tr class="hit"><td class="line">329</td><td class="hits">21</td><td class="source">  if (clazz === 'Integer.TYPE') {</td></tr><tr class="hit"><td class="line">330</td><td class="hits">21</td><td class="source">    out.writeInt(instance);</td></tr><tr class="hit"><td class="line">331</td><td class="hits">21</td><td class="source">    return;</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">334</td><td class="hits">0</td><td class="source">  throw new IOException(&quot;Can't write: &quot; + instance + &quot; as &quot; + clazz);</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">336</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">337</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">338</td><td class="hits"></td><td class="source"> * Write out the code for passed Class.</td></tr><tr><td class="line">339</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">340</td><td class="hits"></td><td class="source"> * @param out</td></tr><tr><td class="line">341</td><td class="hits"></td><td class="source"> * @param c</td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">343</td><td class="hits">1</td><td class="source">exports.writeClassCode = function (out, c) {</td></tr><tr class="hit"><td class="line">344</td><td class="hits">476</td><td class="source">  var code = CLASS_TO_CODE[c];</td></tr><tr class="hit"><td class="line">345</td><td class="hits">476</td><td class="source">  debug('writeClassCode: code: %s, class: %s', code, c);</td></tr><tr class="hit"><td class="line">346</td><td class="hits">476</td><td class="source">  if (code === null || code === undefined) {</td></tr><tr class="miss"><td class="line">347</td><td class="hits">0</td><td class="source">    throw new UnsupportedOperationException(&quot;No code for unexpected &quot; + c);</td></tr><tr><td class="line">348</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">349</td><td class="hits">476</td><td class="source">  WritableUtils.writeVInt(out, code);</td></tr><tr><td class="line">350</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">351</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/io/version_writable.js">/Users/mk2/git/node-hbase-client/lib/io/version_writable.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">6</div><div class="hits">6</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/io/version_writable.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var VersionMismatchException = require('../errors').VersionMismatchException;</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">function VersionedWritable() {}</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">VersionedWritable.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">18</td><td class="hits">208</td><td class="source">  out.writeByte(this.getVersion()); // store version</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">// VersionedWritable.prototype.readFields = function (io) {</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">//   var version = io.readByte(); // read version</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">//   if (version !== this.getVersion()) {</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">//     throw new VersionMismatchException(this.getVersion(), version);</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">//   }</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">// };</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">module.exports = VersionedWritable;</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/ipc/invocation.js">/Users/mk2/git/node-hbase-client/lib/ipc/invocation.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">31</div><div class="hits">31</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/ipc/invocation.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var debug = require('debug')('hbase:ipc:invocation');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var VersionedWritable = require('../io/version_writable');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var HbaseObjectWritable = require('../io/hbase_object_writable');</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var RPC_VERSION = 1;</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">/** A method invocation, including the method name and its parameters.*/</td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">function Invocation(method, parameters) {</td></tr><tr class="hit"><td class="line">22</td><td class="hits">210</td><td class="source">  Invocation.super_.call(this);</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  // method: {name, parameterTypes, parameters}</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  // name: 'get', parameterTypes: ['Buffer', 'Get.class'], parameters: [buf, get]</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  // public Invocation(Method method, Object[] parameters) {</td></tr><tr class="hit"><td class="line">26</td><td class="hits">210</td><td class="source">  this.methodName = method;</td></tr><tr class="hit"><td class="line">27</td><td class="hits">210</td><td class="source">  this.parameterClasses = [];</td></tr><tr class="hit"><td class="line">28</td><td class="hits">210</td><td class="source">  this.parameters = parameters;</td></tr><tr class="hit"><td class="line">29</td><td class="hits">210</td><td class="source">  for (var i = 0; i &lt; parameters.length; i++) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">402</td><td class="source">    this.parameterClasses.push(parameters[i].constructor);</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">32</td><td class="hits">210</td><td class="source">  this.clientVersion = 29; // HRegionInterface: public static final long VERSION = 29L;</td></tr><tr class="hit"><td class="line">33</td><td class="hits">210</td><td class="source">  this.clientMethodsHash = 0;</td></tr><tr class="hit"><td class="line">34</td><td class="hits">210</td><td class="source">  if (method === 'getProtocolVersion') {</td></tr><tr class="hit"><td class="line">35</td><td class="hits">41</td><td class="source">    this.clientVersion = 0;</td></tr><tr class="hit"><td class="line">36</td><td class="hits">41</td><td class="source">    this.clientMethodsHash = 0;</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">40</td><td class="hits">1</td><td class="source">util.inherits(Invocation, VersionedWritable);</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">42</td><td class="hits">1</td><td class="source">Invocation.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">43</td><td class="hits">208</td><td class="source">  Invocation.super_.prototype.write.call(this, out);</td></tr><tr class="hit"><td class="line">44</td><td class="hits">208</td><td class="source">  out.writeUTF(this.methodName);</td></tr><tr class="hit"><td class="line">45</td><td class="hits">208</td><td class="source">  out.writeLong(this.clientVersion);</td></tr><tr class="hit"><td class="line">46</td><td class="hits">208</td><td class="source">  out.writeInt(this.clientMethodsHash);</td></tr><tr class="hit"><td class="line">47</td><td class="hits">208</td><td class="source">  out.writeInt(this.parameters.length);</td></tr><tr class="hit"><td class="line">48</td><td class="hits">208</td><td class="source">  debug('writable: method: %s, clientVersion: %s, clientMethodsHash: %s, parameters len: %d', </td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">    this.methodName, this.clientVersion, this.clientMethodsHash, this.parameters.length);</td></tr><tr class="hit"><td class="line">50</td><td class="hits">208</td><td class="source">  for (var i = 0; i &lt; this.parameters.length; i++) {</td></tr><tr class="hit"><td class="line">51</td><td class="hits">398</td><td class="source">    HbaseObjectWritable.writeObject(out, this.parameters[i], this.parameterClasses[i]);</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">55</td><td class="hits">1</td><td class="source">Invocation.prototype.getVersion = function () {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">208</td><td class="source">  return RPC_VERSION;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">60</td><td class="hits">1</td><td class="source">module.exports = Invocation;</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/ipc/response_flag.js">/Users/mk2/git/node-hbase-client/lib/ipc/response_flag.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">7</div><div class="hits">7</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/ipc/resposer_flag.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> * Utility for managing the flag byte passed in response to a</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> * {@link HBaseServer.Call}</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var ERROR_BIT = 0x1;</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var LENGTH_BIT = 0x2;</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">exports.isError = function (flag) {</td></tr><tr class="hit"><td class="line">21</td><td class="hits">197</td><td class="source">  return (flag &amp; ERROR_BIT) !== 0;</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">exports.isLength = function (flag) {</td></tr><tr class="hit"><td class="line">25</td><td class="hits">197</td><td class="source">  return (flag &amp; LENGTH_BIT) !== 0;</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/keyvalue.js">/Users/mk2/git/node-hbase-client/lib/keyvalue.js</h2><div id="stats" class="high"><div class="percentage">77%</div><div class="sloc">144</div><div class="hits">111</div><div class="misses">33</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/keyvalue.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> * Key type.</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> * Has space for other key types to be added later.  Cannot rely on</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> * enum ordinals . They change if item is removed or moved.  Do our own codes.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">var Type = {</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  Minimum: 0,</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  Put: 4,</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  Delete: 8, </td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  DeleteColumn: 12, </td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  DeleteFamily: 14,</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  // Maximum is used when searching; you look from maximum on down.</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  Maximum: 255,</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> * An HBase Key/Value.  This is the fundamental HBase Type.</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> * &lt;p&gt;If being used client-side, the primary methods to access individual fields</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> * are {@link #getRow()}, {@link #getFamily()}, {@link #getQualifier()},</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> * {@link #getTimestamp()}, and {@link #getValue()}.  These methods allocate new</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> * byte arrays and return copies. Avoid their use server-side.</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> * &lt;p&gt;Instances of this class are immutable.  They do not implement Comparable</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> * but Comparators are provided.  Comparators change with context,</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> * whether user table or a catalog table comparison.  Its critical you use the</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> * appropriate comparator.  There are Comparators for KeyValue instances and</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> * then for just the Key portion of a KeyValue used mostly by {@link HFile}.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> * &lt;p&gt;KeyValue wraps a byte array and takes offsets and lengths into passed</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> * array at where to start interpreting the content as KeyValue.  The KeyValue</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> * format inside a byte array is:</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> * &lt;keylength&gt; &lt;valuelength&gt; &lt;key&gt; &lt;value&gt;</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> * Key is further decomposed as:</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> * &lt;rowlength&gt; &lt;row&gt; &lt;columnfamilylength&gt; &lt;columnfamily&gt; &lt;columnqualifier&gt; &lt;timestamp&gt; &lt;keytype&gt;</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> * The `rowlength` maximum is `Short.MAX_SIZE`,</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> * column family length maximum is</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> * `Byte.MAX_SIZE`, and column qualifier + key length must</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> * be &lt; `Integer.MAX_SIZE`.</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> * The column does not contain the family/qualifier delimiter, {@link #COLUMN_FAMILY_DELIMITER}</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> * KeyValue format:</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> * | 4 bytes   | 4 bytes     |     |       |</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> * | keylength | valuelength | key | value |</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> * Key format:</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> * | 2 bytes   |     | 1 byte             |              |                        |  8 bytes  | 1 byte  |</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * | rowlength | row | columnfamilylength | columnfamily | columnfamily qualifier | timestamp | keytype |</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">66</td><td class="hits">1</td><td class="source">function KeyValue(bytes, offset, length) {</td></tr><tr class="hit"><td class="line">67</td><td class="hits">979</td><td class="source">  this.bytes = bytes;</td></tr><tr class="hit"><td class="line">68</td><td class="hits">979</td><td class="source">  this.offset = offset || 0;</td></tr><tr class="hit"><td class="line">69</td><td class="hits">979</td><td class="source">  this.length = length || bytes.length;</td></tr><tr class="hit"><td class="line">70</td><td class="hits">979</td><td class="source">  this.keyLength = 0;</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  // default value is 0, aka DNC</td></tr><tr class="hit"><td class="line">72</td><td class="hits">979</td><td class="source">  this.memstoreTS = 0;</td></tr><tr class="hit"><td class="line">73</td><td class="hits">979</td><td class="source">  this.rowCache = null;</td></tr><tr class="hit"><td class="line">74</td><td class="hits">979</td><td class="source">  this.timestampCache = -1;</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> * Colon character in UTF-8</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">80</td><td class="hits">1</td><td class="source">KeyValue.COLUMN_FAMILY_DELIMITER = ':';</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">KeyValue.COLUMN_FAMILY_DELIM_ARRAY = new Buffer(KeyValue.COLUMN_FAMILY_DELIMITER);</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">/** Size of the key length field in bytes*/</td></tr><tr class="hit"><td class="line">84</td><td class="hits">1</td><td class="source">KeyValue.KEY_LENGTH_SIZE = Bytes.SIZEOF_INT;</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">/** Size of the key type field in bytes */</td></tr><tr class="hit"><td class="line">87</td><td class="hits">1</td><td class="source">KeyValue.TYPE_SIZE = Bytes.SIZEOF_BYTE;</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">/** Size of the row length field in bytes */</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1</td><td class="source">KeyValue.ROW_LENGTH_SIZE = Bytes.SIZEOF_SHORT;</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">/** Size of the family length field in bytes */</td></tr><tr class="hit"><td class="line">93</td><td class="hits">1</td><td class="source">KeyValue.FAMILY_LENGTH_SIZE = Bytes.SIZEOF_BYTE;</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">/** Size of the timestamp field in bytes */</td></tr><tr class="hit"><td class="line">96</td><td class="hits">1</td><td class="source">KeyValue.TIMESTAMP_SIZE = Bytes.SIZEOF_LONG;</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">// Size of the timestamp and type byte on end of a key -- a long + a byte.</td></tr><tr class="hit"><td class="line">99</td><td class="hits">1</td><td class="source">KeyValue.TIMESTAMP_TYPE_SIZE = KeyValue.TIMESTAMP_SIZE + KeyValue.TYPE_SIZE;</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">// Size of the length shorts and bytes in key.</td></tr><tr class="hit"><td class="line">102</td><td class="hits">1</td><td class="source">KeyValue.KEY_INFRASTRUCTURE_SIZE = KeyValue.ROW_LENGTH_SIZE + </td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  KeyValue.FAMILY_LENGTH_SIZE + KeyValue.TIMESTAMP_TYPE_SIZE;</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">// How far into the key the row starts at. First thing to read is the short</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">// that says how long the row is.</td></tr><tr class="hit"><td class="line">107</td><td class="hits">1</td><td class="source">KeyValue.ROW_OFFSET = Bytes.SIZEOF_INT /*keylength*/+ Bytes.SIZEOF_INT /*valuelength*/;</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">// Size of the length ints in a KeyValue datastructure.</td></tr><tr class="hit"><td class="line">110</td><td class="hits">1</td><td class="source">KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE = KeyValue.ROW_OFFSET;</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">112</td><td class="hits">1</td><td class="source">KeyValue.humanReadableTimestamp = function (timestamp) {</td></tr><tr class="miss"><td class="line">113</td><td class="hits">0</td><td class="source">  if (timestamp === HConstants.LATEST_TIMESTAMP) {</td></tr><tr class="miss"><td class="line">114</td><td class="hits">0</td><td class="source">    return &quot;LATEST_TIMESTAMP&quot;;</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">116</td><td class="hits">0</td><td class="source">  if (timestamp === HConstants.OLDEST_TIMESTAMP) {</td></tr><tr class="miss"><td class="line">117</td><td class="hits">0</td><td class="source">    return &quot;OLDEST_TIMESTAMP&quot;;</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">119</td><td class="hits">0</td><td class="source">  return String.valueOf(timestamp);</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">//  String representation</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">128</td><td class="hits">1</td><td class="source">KeyValue.prototype.toString = function () {</td></tr><tr class="miss"><td class="line">129</td><td class="hits">0</td><td class="source">  if (!this.bytes || this.bytes.length === 0) {</td></tr><tr class="miss"><td class="line">130</td><td class="hits">0</td><td class="source">    return &quot;empty&quot;;</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">132</td><td class="hits">0</td><td class="source">  var family = this.getFamily();</td></tr><tr class="miss"><td class="line">133</td><td class="hits">0</td><td class="source">  if (family) {</td></tr><tr class="miss"><td class="line">134</td><td class="hits">0</td><td class="source">    family = family.toString();</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">136</td><td class="hits">0</td><td class="source">  var qualifier = this.getQualifier();</td></tr><tr class="miss"><td class="line">137</td><td class="hits">0</td><td class="source">  if (qualifier) {</td></tr><tr class="miss"><td class="line">138</td><td class="hits">0</td><td class="source">    qualifier = qualifier.toString();</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">140</td><td class="hits">0</td><td class="source">  var timestamp = this.getTimestamp().toString();</td></tr><tr class="miss"><td class="line">141</td><td class="hits">0</td><td class="source">  return this.getRow().toString() + '/' + family + '/' + qualifier + '/' + timestamp + </td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">    &quot;/vlen=&quot; + this.getValueLength() + &quot;/ts=&quot; + this.memstoreTS;</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">//  Public Member Accessors</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> * @return The byte array backing this KeyValue.</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">154</td><td class="hits">1</td><td class="source">KeyValue.prototype.getBuffer = function () {</td></tr><tr class="hit"><td class="line">155</td><td class="hits">786</td><td class="source">  return this.bytes;</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> * @return Offset into {@link #getBuffer()} at which this KeyValue starts.</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">161</td><td class="hits">1</td><td class="source">KeyValue.prototype.getOffset = function () {</td></tr><tr class="hit"><td class="line">162</td><td class="hits">40</td><td class="source">  return this.offset;</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source"> * @return Length of bytes this KeyValue occupies in {@link #getBuffer()}.</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">168</td><td class="hits">1</td><td class="source">KeyValue.prototype.getLength = function () {</td></tr><tr class="hit"><td class="line">169</td><td class="hits">118</td><td class="source">  return this.length;</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">//  Length and Offset Calculators</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">176</td><td class="hits"></td><td class="source">//---------------------------------------------------------------------------</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source"> * @return Key offset in backing buffer..</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">181</td><td class="hits">1</td><td class="source">KeyValue.prototype.getKeyOffset = function () {</td></tr><tr class="hit"><td class="line">182</td><td class="hits">4135</td><td class="source">  return this.offset + KeyValue.ROW_OFFSET;</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">185</td><td class="hits">1</td><td class="source">KeyValue.prototype.getKeyString = function () {</td></tr><tr class="miss"><td class="line">186</td><td class="hits">0</td><td class="source">  return Bytes.toStringBinary(this.getBuffer(), this.getKeyOffset(), this.getKeyLength());</td></tr><tr><td class="line">187</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source"> * @return Length of key portion.</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">192</td><td class="hits">1</td><td class="source">KeyValue.prototype.getKeyLength = function () {</td></tr><tr class="hit"><td class="line">193</td><td class="hits">1472</td><td class="source">  if (this.keyLength === 0) {</td></tr><tr class="hit"><td class="line">194</td><td class="hits">653</td><td class="source">    this.keyLength = Bytes.toInt(this.bytes, this.offset);</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">196</td><td class="hits">1472</td><td class="source">  return this.keyLength;</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">198</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">200</td><td class="hits"></td><td class="source"> * @return Value offset</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">202</td><td class="hits">1</td><td class="source">KeyValue.prototype.getValueOffset = function () {</td></tr><tr class="hit"><td class="line">203</td><td class="hits">649</td><td class="source">  return this.getKeyOffset() + this.getKeyLength();</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">206</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source"> * @return Value length</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">209</td><td class="hits">1</td><td class="source">KeyValue.prototype.getValueLength = function () {</td></tr><tr class="hit"><td class="line">210</td><td class="hits">649</td><td class="source">  return Bytes.toInt(this.bytes, this.offset + Bytes.SIZEOF_INT);</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source"> * @return Row offset</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">216</td><td class="hits">1</td><td class="source">KeyValue.prototype.getRowOffset = function () {</td></tr><tr class="hit"><td class="line">217</td><td class="hits">97</td><td class="source">  return this.getKeyOffset() + Bytes.SIZEOF_SHORT;</td></tr><tr><td class="line">218</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">220</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source"> * @return Row length</td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">223</td><td class="hits">1</td><td class="source">KeyValue.prototype.getRowLength = function () {</td></tr><tr class="hit"><td class="line">224</td><td class="hits">3389</td><td class="source">  return Bytes.toShort(this.bytes, this.getKeyOffset());</td></tr><tr><td class="line">225</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source"> * @return Family offset</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">230</td><td class="hits">1</td><td class="source">KeyValue.prototype.getFamilyOffset = function (rlength) {</td></tr><tr class="hit"><td class="line">231</td><td class="hits">2469</td><td class="source">  rlength = rlength || this.getRowLength();</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source">  // row offset + rowlength data(2 bytes) + rowlength + familylength data(1 byte)</td></tr><tr class="hit"><td class="line">233</td><td class="hits">2469</td><td class="source">  return this.offset + KeyValue.ROW_OFFSET + Bytes.SIZEOF_SHORT + rlength + Bytes.SIZEOF_BYTE;</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">235</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">236</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source"> * @return Family length</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">239</td><td class="hits">1</td><td class="source">KeyValue.prototype.getFamilyLength = function (familyOffset) {</td></tr><tr class="hit"><td class="line">240</td><td class="hits">2469</td><td class="source">  familyOffset = familyOffset || this.getFamilyOffset();</td></tr><tr class="hit"><td class="line">241</td><td class="hits">2469</td><td class="source">  return this.bytes[familyOffset - 1];</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">244</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source"> * @return Qualifier offset</td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">247</td><td class="hits">1</td><td class="source">KeyValue.prototype.getQualifierOffset = function (familyOffset) {</td></tr><tr class="hit"><td class="line">248</td><td class="hits">823</td><td class="source">  familyOffset = familyOffset || this.getFamilyOffset();</td></tr><tr class="hit"><td class="line">249</td><td class="hits">823</td><td class="source">  return familyOffset + this.getFamilyLength(familyOffset);</td></tr><tr><td class="line">250</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">253</td><td class="hits"></td><td class="source"> * @return Qualifier length</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">255</td><td class="hits">1</td><td class="source">KeyValue.prototype.getQualifierLength = function (rlength, flength) {</td></tr><tr class="hit"><td class="line">256</td><td class="hits">823</td><td class="source">  rlength = rlength || this.getRowLength();</td></tr><tr class="hit"><td class="line">257</td><td class="hits">823</td><td class="source">  flength = flength || this.getFamilyLength();</td></tr><tr class="hit"><td class="line">258</td><td class="hits">823</td><td class="source">  return this.getKeyLength() - (KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength);</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">261</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">262</td><td class="hits"></td><td class="source"> * @return Column (family + qualifier) length</td></tr><tr><td class="line">263</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">264</td><td class="hits">1</td><td class="source">KeyValue.prototype.getTotalColumnLength = function (rlength, foffset) {</td></tr><tr class="miss"><td class="line">265</td><td class="hits">0</td><td class="source">  rlength = rlength || this.getRowLength();</td></tr><tr class="miss"><td class="line">266</td><td class="hits">0</td><td class="source">  foffset = foffset || this.getFamilyOffset(rlength);</td></tr><tr class="miss"><td class="line">267</td><td class="hits">0</td><td class="source">  var flength = this.getFamilyLength(foffset);</td></tr><tr class="miss"><td class="line">268</td><td class="hits">0</td><td class="source">  var qlength = this.getQualifierLength(rlength, flength);</td></tr><tr class="miss"><td class="line">269</td><td class="hits">0</td><td class="source">  return flength + qlength;</td></tr><tr><td class="line">270</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">271</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">272</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">273</td><td class="hits"></td><td class="source"> * @param keylength Pass if you have it to save on a int creation.</td></tr><tr><td class="line">274</td><td class="hits"></td><td class="source"> * @return Timestamp offset</td></tr><tr><td class="line">275</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">276</td><td class="hits">1</td><td class="source">KeyValue.prototype.getTimestampOffset = function (keylength) {</td></tr><tr class="miss"><td class="line">277</td><td class="hits">0</td><td class="source">  keylength = keylength || this.getKeyLength();</td></tr><tr class="miss"><td class="line">278</td><td class="hits">0</td><td class="source">  return this.getKeyOffset() + keylength - KeyValue.TIMESTAMP_TYPE_SIZE;</td></tr><tr><td class="line">279</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">282</td><td class="hits"></td><td class="source"> * @return True if this KeyValue has a LATEST_TIMESTAMP timestamp.</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">284</td><td class="hits">1</td><td class="source">KeyValue.prototype.isLatestTimestamp = function () {</td></tr><tr class="miss"><td class="line">285</td><td class="hits">0</td><td class="source">  return Bytes.equals(this.getBuffer(), this.getTimestampOffset(), Bytes.SIZEOF_LONG, </td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">    HConstants.LATEST_TIMESTAMP_BYTES, 0, Bytes.SIZEOF_LONG);</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source"> * Do not use unless you have to.  Used internally for compacting and testing.</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source"> * Use {@link #getRow()}, {@link #getFamily()}, {@link #getQualifier()}, and</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source"> * {@link #getValue()} if accessing a KeyValue client-side.</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source"> * @return Copy of the key portion only.</td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">296</td><td class="hits">1</td><td class="source">KeyValue.prototype.getKey = function () {</td></tr><tr class="miss"><td class="line">297</td><td class="hits">0</td><td class="source">  var keyLength = this.getKeyLength();</td></tr><tr class="miss"><td class="line">298</td><td class="hits">0</td><td class="source">  var offset = this.getKeyOffset();</td></tr><tr class="miss"><td class="line">299</td><td class="hits">0</td><td class="source">  return this.bytes.slice(offset, offset + keyLength);</td></tr><tr><td class="line">300</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">301</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">302</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">303</td><td class="hits"></td><td class="source"> * Returns value in a new byte array.</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source"> * Primarily for use client-side. If server-side, use</td></tr><tr><td class="line">305</td><td class="hits"></td><td class="source"> * {@link #getBuffer()} with appropriate offsets and lengths instead to</td></tr><tr><td class="line">306</td><td class="hits"></td><td class="source"> * save on allocations.</td></tr><tr><td class="line">307</td><td class="hits"></td><td class="source"> * @return Value in a new byte array.</td></tr><tr><td class="line">308</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">309</td><td class="hits">1</td><td class="source">KeyValue.prototype.getValue = function () {</td></tr><tr class="hit"><td class="line">310</td><td class="hits">649</td><td class="source">  var o = this.getValueOffset();</td></tr><tr class="hit"><td class="line">311</td><td class="hits">649</td><td class="source">  var l = this.getValueLength();</td></tr><tr class="hit"><td class="line">312</td><td class="hits">649</td><td class="source">  return this.getBuffer().slice(o, o + l);</td></tr><tr><td class="line">313</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">314</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">315</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source"> * Primarily for use client-side.  Returns the row of this KeyValue in a new</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source"> * byte array.&lt;p&gt;</td></tr><tr><td class="line">318</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">319</td><td class="hits"></td><td class="source"> * If server-side, use {@link #getBuffer()} with appropriate offsets and</td></tr><tr><td class="line">320</td><td class="hits"></td><td class="source"> * lengths instead.</td></tr><tr><td class="line">321</td><td class="hits"></td><td class="source"> * @return Row in a new byte array.</td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">323</td><td class="hits">1</td><td class="source">KeyValue.prototype.getRow = function () {</td></tr><tr class="hit"><td class="line">324</td><td class="hits">97</td><td class="source">  if (this.rowCache === null) {</td></tr><tr class="hit"><td class="line">325</td><td class="hits">97</td><td class="source">    var o = this.getRowOffset();</td></tr><tr class="hit"><td class="line">326</td><td class="hits">97</td><td class="source">    var l = this.getRowLength();</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source">    // initialize and copy the data into a local variable</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source">    // in case multiple threads race here.</td></tr><tr class="hit"><td class="line">329</td><td class="hits">97</td><td class="source">    this.rowCache = this.getBuffer().slice(o, o + l);</td></tr><tr><td class="line">330</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">331</td><td class="hits">97</td><td class="source">  return this.rowCache;</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">334</td><td class="hits">1</td><td class="source">KeyValue.prototype.getTimestamp = function () {</td></tr><tr class="miss"><td class="line">335</td><td class="hits">0</td><td class="source">  if (this.timestampCache === -1) {</td></tr><tr class="miss"><td class="line">336</td><td class="hits">0</td><td class="source">    var tsOffset = this.getTimestampOffset();</td></tr><tr class="miss"><td class="line">337</td><td class="hits">0</td><td class="source">    this.timestampCache = WritableUtils.toLong(this.bytes.slice(tsOffset, tsOffset + Bytes.SIZEOF_LONG));</td></tr><tr><td class="line">338</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">339</td><td class="hits">0</td><td class="source">  return this.timestampCache;</td></tr><tr><td class="line">340</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">341</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source"> * @param keylength Pass if you have it to save on a int creation.</td></tr><tr><td class="line">344</td><td class="hits"></td><td class="source"> * @return Type of this KeyValue.</td></tr><tr><td class="line">345</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">346</td><td class="hits">1</td><td class="source">KeyValue.prototype.getType = function (keylength) {</td></tr><tr class="miss"><td class="line">347</td><td class="hits">0</td><td class="source">  keylength = keylength || this.getKeyLength();</td></tr><tr class="miss"><td class="line">348</td><td class="hits">0</td><td class="source">  return this.bytes[this.offset + keylength - 1 + KeyValue.ROW_OFFSET];</td></tr><tr><td class="line">349</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">350</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">351</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">352</td><td class="hits"></td><td class="source"> * Primarily for use client-side.  Returns the family of this KeyValue in a</td></tr><tr><td class="line">353</td><td class="hits"></td><td class="source"> * new byte array.&lt;p&gt;</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source"> * If server-side, use {@link #getBuffer()} with appropriate offsets and</td></tr><tr><td class="line">356</td><td class="hits"></td><td class="source"> * lengths instead.</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source"> * @return Returns family. Makes a copy.</td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">359</td><td class="hits">1</td><td class="source">KeyValue.prototype.getFamily = function () {</td></tr><tr class="hit"><td class="line">360</td><td class="hits">823</td><td class="source">  var o = this.getFamilyOffset();</td></tr><tr class="hit"><td class="line">361</td><td class="hits">823</td><td class="source">  var l = this.getFamilyLength(o);</td></tr><tr class="hit"><td class="line">362</td><td class="hits">823</td><td class="source">  return this.bytes.slice(o, o + l);</td></tr><tr><td class="line">363</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">364</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">365</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">366</td><td class="hits"></td><td class="source"> * Primarily for use client-side.  Returns the column qualifier of this</td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source"> * KeyValue in a new byte array.&lt;p&gt;</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">369</td><td class="hits"></td><td class="source"> * If server-side, use {@link #getBuffer()} with appropriate offsets and</td></tr><tr><td class="line">370</td><td class="hits"></td><td class="source"> * lengths instead.</td></tr><tr><td class="line">371</td><td class="hits"></td><td class="source"> * Use {@link #getBuffer()} with appropriate offsets and lengths instead.</td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source"> * @return Returns qualifier. Makes a copy.</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">374</td><td class="hits">1</td><td class="source">KeyValue.prototype.getQualifier = function () {</td></tr><tr class="hit"><td class="line">375</td><td class="hits">823</td><td class="source">  var o = this.getQualifierOffset();</td></tr><tr class="hit"><td class="line">376</td><td class="hits">823</td><td class="source">  var l = this.getQualifierLength();</td></tr><tr class="hit"><td class="line">377</td><td class="hits">823</td><td class="source">  return this.bytes.slice(o, o + l);</td></tr><tr><td class="line">378</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">379</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">380</td><td class="hits">1</td><td class="source">KeyValue.Type = Type;</td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">382</td><td class="hits">1</td><td class="source">KeyValue.createKeyValue = function (row, family, qualifier, timestamp, type, value) {</td></tr><tr class="hit"><td class="line">383</td><td class="hits">44</td><td class="source">  var rlength = row.length;</td></tr><tr><td class="line">384</td><td class="hits"></td><td class="source">  // Family length</td></tr><tr class="hit"><td class="line">385</td><td class="hits">44</td><td class="source">  var flength = family ? family.length : 0;</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source">  // Qualifier length</td></tr><tr class="hit"><td class="line">387</td><td class="hits">44</td><td class="source">  var qlength = qualifier ? qualifier.length : 0;</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source">  // Key length</td></tr><tr class="hit"><td class="line">389</td><td class="hits">44</td><td class="source">  var keylength = KeyValue.KEY_INFRASTRUCTURE_SIZE + rlength + flength + qlength;</td></tr><tr><td class="line">390</td><td class="hits"></td><td class="source">  // Value length</td></tr><tr class="hit"><td class="line">391</td><td class="hits">44</td><td class="source">  var vlength = value ? value.length : 0;</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source">  // Allocate right-sized byte array.</td></tr><tr class="hit"><td class="line">393</td><td class="hits">44</td><td class="source">  var bytes = new Buffer(KeyValue.KEYVALUE_INFRASTRUCTURE_SIZE + keylength + vlength);</td></tr><tr><td class="line">394</td><td class="hits"></td><td class="source">  // Write key, value and key row length.</td></tr><tr class="hit"><td class="line">395</td><td class="hits">44</td><td class="source">  var pos = 0;</td></tr><tr class="hit"><td class="line">396</td><td class="hits">44</td><td class="source">  pos = Bytes.putInt(bytes, pos, keylength);</td></tr><tr class="hit"><td class="line">397</td><td class="hits">44</td><td class="source">  pos = Bytes.putInt(bytes, pos, vlength);</td></tr><tr class="hit"><td class="line">398</td><td class="hits">44</td><td class="source">  pos = Bytes.putShort(bytes, pos, rlength);</td></tr><tr class="hit"><td class="line">399</td><td class="hits">44</td><td class="source">  pos = Bytes.putBytes(bytes, pos, row);</td></tr><tr class="hit"><td class="line">400</td><td class="hits">44</td><td class="source">  pos = Bytes.putByte(bytes, pos, flength);</td></tr><tr class="hit"><td class="line">401</td><td class="hits">44</td><td class="source">  if (flength !== 0) {</td></tr><tr class="hit"><td class="line">402</td><td class="hits">44</td><td class="source">    pos = Bytes.putBytes(bytes, pos, family);</td></tr><tr><td class="line">403</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">404</td><td class="hits">44</td><td class="source">  if (qlength !== 0) {</td></tr><tr class="hit"><td class="line">405</td><td class="hits">44</td><td class="source">    pos = Bytes.putBytes(bytes, pos, qualifier);</td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">407</td><td class="hits">44</td><td class="source">  pos = Bytes.putLong(bytes, pos, timestamp);</td></tr><tr class="hit"><td class="line">408</td><td class="hits">44</td><td class="source">  pos = Bytes.putByte(bytes, pos, type);</td></tr><tr class="hit"><td class="line">409</td><td class="hits">44</td><td class="source">  if (value &amp;&amp; value.length &gt; 0) {</td></tr><tr class="hit"><td class="line">410</td><td class="hits">42</td><td class="source">    pos = Bytes.putBytes(bytes, pos, value);</td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">412</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">413</td><td class="hits">44</td><td class="source">  return new KeyValue(bytes);</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">416</td><td class="hits">1</td><td class="source">KeyValue.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">417</td><td class="hits">2</td><td class="source">  out.writeInt(this.getLength());</td></tr><tr class="hit"><td class="line">418</td><td class="hits">2</td><td class="source">  out.write(this.getBuffer(), this.getOffset(), this.getLength());</td></tr><tr><td class="line">419</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">420</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">421</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">422</td><td class="hits">1</td><td class="source">module.exports = KeyValue;</td></tr><tr><td class="line">423</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/operation_with_attributes.js">/Users/mk2/git/node-hbase-client/lib/operation_with_attributes.js</h2><div id="stats" class="low"><div class="percentage">44%</div><div class="sloc">38</div><div class="hits">17</div><div class="misses">21</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/operation_with_attributes.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var eventproxy = require('eventproxy');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">function OperationWithAttributes() {</td></tr><tr class="hit"><td class="line">18</td><td class="hits">95</td><td class="source">  this.attributes = {};</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * Set attribute.</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * @param {String} name</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> * @param {Bytes} value</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">27</td><td class="hits">1</td><td class="source">OperationWithAttributes.prototype.setAttribute = function (name, value) {</td></tr><tr class="miss"><td class="line">28</td><td class="hits">0</td><td class="source">  if (!this.attributes &amp;&amp; (value === null || value === undefined)) {</td></tr><tr class="miss"><td class="line">29</td><td class="hits">0</td><td class="source">    return;</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">32</td><td class="hits">0</td><td class="source">  if (!this.attributes) {</td></tr><tr class="miss"><td class="line">33</td><td class="hits">0</td><td class="source">    this.attributes = {};</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">36</td><td class="hits">0</td><td class="source">  if (value === null || value === undefined) {</td></tr><tr class="miss"><td class="line">37</td><td class="hits">0</td><td class="source">    delete this.attributes[name];</td></tr><tr class="miss"><td class="line">38</td><td class="hits">0</td><td class="source">    if (Object.keys(this.attributes).length === 0) {</td></tr><tr class="miss"><td class="line">39</td><td class="hits">0</td><td class="source">      this.attributes = null;</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">42</td><td class="hits">0</td><td class="source">    this.attributes[name] = value;</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">46</td><td class="hits">1</td><td class="source">OperationWithAttributes.prototype.getAttribute = function (name) {</td></tr><tr class="miss"><td class="line">47</td><td class="hits">0</td><td class="source">  if (!this.attributes) {</td></tr><tr class="miss"><td class="line">48</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">50</td><td class="hits">0</td><td class="source">  return this.attributes[name];</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">53</td><td class="hits">1</td><td class="source">OperationWithAttributes.prototype.getAttributesMap = function () {</td></tr><tr class="miss"><td class="line">54</td><td class="hits">0</td><td class="source">  return this.attributes || {};</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">57</td><td class="hits">1</td><td class="source">OperationWithAttributes.prototype.writeAttributes = function (out) {</td></tr><tr class="hit"><td class="line">58</td><td class="hits">88</td><td class="source">  if (!this.attributes) {</td></tr><tr class="miss"><td class="line">59</td><td class="hits">0</td><td class="source">    out.writeInt(0);</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="hit"><td class="line">61</td><td class="hits">88</td><td class="source">    out.writeInt(Object.keys(this.attributes).length);</td></tr><tr class="hit"><td class="line">62</td><td class="hits">88</td><td class="source">    for (var name in this.attributes) {</td></tr><tr class="miss"><td class="line">63</td><td class="hits">0</td><td class="source">      WritableUtils.writeString(out, name);</td></tr><tr class="miss"><td class="line">64</td><td class="hits">0</td><td class="source">      Bytes.writeByteArray(out, this.attributes[name]);</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">69</td><td class="hits">1</td><td class="source">OperationWithAttributes.prototype.readAttributes = function (io) {</td></tr><tr class="hit"><td class="line">70</td><td class="hits">3</td><td class="source">  var numAttributes = io.readInt();</td></tr><tr class="hit"><td class="line">71</td><td class="hits">3</td><td class="source">  if (numAttributes &gt; 0) {</td></tr><tr class="miss"><td class="line">72</td><td class="hits">0</td><td class="source">    this.attributes = {};</td></tr><tr class="miss"><td class="line">73</td><td class="hits">0</td><td class="source">    for (var i = 0; i &lt; numAttributes; i++) {</td></tr><tr class="miss"><td class="line">74</td><td class="hits">0</td><td class="source">      var name = io.readString();</td></tr><tr class="miss"><td class="line">75</td><td class="hits">0</td><td class="source">      var value = io.readByteArray();</td></tr><tr class="miss"><td class="line">76</td><td class="hits">0</td><td class="source">      this.attributes.put(name, value);</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">82</td><td class="hits">1</td><td class="source">module.exports = OperationWithAttributes;</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/put.js">/Users/mk2/git/node-hbase-client/lib/put.js</h2><div id="stats" class="high"><div class="percentage">96%</div><div class="sloc">65</div><div class="hits">63</div><div class="misses">2</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/put.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var errors = require('./errors');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var KeyValue = require('./keyvalue');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var OperationWithAttributes = require('./operation_with_attributes');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> * Used to perform Put operations for a single row.</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * To perform a Put, instantiate a Put object with the row to insert to and</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * for each column to be inserted, execute {@link #add(byte[], byte[], byte[]) add} or</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> * {@link #add(byte[], byte[], long, byte[]) add} if setting the timestamp.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">28</td><td class="hits">1</td><td class="source">var PUT_VERSION = 2;</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> * Create a Put operation for the specified row, using a given timestamp, and an existing row lock.</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> * @param row row key</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> * @param ts timestamp</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> * @param rowLock previously acquired row lock, or null</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">37</td><td class="hits">1</td><td class="source">function Put(row, ts, rowLock) {</td></tr><tr class="hit"><td class="line">38</td><td class="hits">23</td><td class="source">  OperationWithAttributes.call(this);</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">40</td><td class="hits">23</td><td class="source">  if (row &amp;&amp; !Buffer.isBuffer(row)) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">23</td><td class="source">    row = Bytes.toBytes(row);</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">43</td><td class="hits">23</td><td class="source">  if (row === null || row.length &gt; HConstants.MAX_ROW_LENGTH) {</td></tr><tr class="miss"><td class="line">44</td><td class="hits">0</td><td class="source">    throw new errors.IllegalArgumentException(&quot;Row key is invalid&quot;);</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">47</td><td class="hits">23</td><td class="source">  this.row = row;</td></tr><tr class="hit"><td class="line">48</td><td class="hits">23</td><td class="source">  this.ts = ts || HConstants.LATEST_TIMESTAMP;</td></tr><tr class="hit"><td class="line">49</td><td class="hits">23</td><td class="source">  this.lockId = -1;</td></tr><tr class="hit"><td class="line">50</td><td class="hits">23</td><td class="source">  if (rowLock) {</td></tr><tr class="miss"><td class="line">51</td><td class="hits">0</td><td class="source">    this.lockId = rowLock.getLockId();</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">53</td><td class="hits">23</td><td class="source">  this.familyMap = {};</td></tr><tr class="hit"><td class="line">54</td><td class="hits">23</td><td class="source">  this.writeToWAL = true;</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">57</td><td class="hits">1</td><td class="source">util.inherits(Put, OperationWithAttributes);</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">59</td><td class="hits">1</td><td class="source">Put.prototype.getRow = function () {</td></tr><tr class="hit"><td class="line">60</td><td class="hits">14</td><td class="source">  return this.row;</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * Add the specified column and value, with the specified timestamp as</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * its version to this Put operation.</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * @param qualifier column qualifier</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * @param value column value</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> * @param [ts] version timestamp</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> * @return this</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">73</td><td class="hits">1</td><td class="source">Put.prototype.add = function (family, qualifier, value, ts) {</td></tr><tr class="hit"><td class="line">74</td><td class="hits">38</td><td class="source">  var list = this.getKeyValueList(family);</td></tr><tr class="hit"><td class="line">75</td><td class="hits">38</td><td class="source">  var kv = this.createPutKeyValue(family, qualifier, ts || this.ts, value);</td></tr><tr class="hit"><td class="line">76</td><td class="hits">38</td><td class="source">  list.push(kv);</td></tr><tr class="hit"><td class="line">77</td><td class="hits">38</td><td class="source">  return this;</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">/*</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> * Create a KeyValue with this objects row key and the Put identifier.</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> * @return a KeyValue with this objects row key and the Put identifier.</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">85</td><td class="hits">1</td><td class="source">Put.prototype.createPutKeyValue = function (family, qualifier, ts, value) {</td></tr><tr class="hit"><td class="line">86</td><td class="hits">42</td><td class="source">  if (family &amp;&amp; !Buffer.isBuffer(family)) {</td></tr><tr class="hit"><td class="line">87</td><td class="hits">42</td><td class="source">    family = Bytes.toBytes(family);</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">89</td><td class="hits">42</td><td class="source">  if (qualifier &amp;&amp; !Buffer.isBuffer(qualifier)) {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">42</td><td class="source">    qualifier = Bytes.toBytes(qualifier);</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">92</td><td class="hits">42</td><td class="source">  if (value &amp;&amp; !Buffer.isBuffer(value)) {</td></tr><tr class="hit"><td class="line">93</td><td class="hits">42</td><td class="source">    value = Bytes.toBytes(value);</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">95</td><td class="hits">42</td><td class="source">  return KeyValue.createKeyValue(this.row, family, qualifier, ts, KeyValue.Type.Put, value);</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * Creates an empty list if one doesnt exist for the given column family</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * or else it returns the associated list of KeyValue objects.</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> * @param family column family</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> * @return a list of KeyValue objects, returns an empty list if one doesnt exist.</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">105</td><td class="hits">1</td><td class="source">Put.prototype.getKeyValueList = function (family) {</td></tr><tr class="hit"><td class="line">106</td><td class="hits">38</td><td class="source">  var list = this.familyMap[family];</td></tr><tr class="hit"><td class="line">107</td><td class="hits">38</td><td class="source">  if (!list) {</td></tr><tr class="hit"><td class="line">108</td><td class="hits">19</td><td class="source">    list = this.familyMap[family] = [];</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">110</td><td class="hits">38</td><td class="source">  return list;</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">113</td><td class="hits">1</td><td class="source">Put.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">114</td><td class="hits">19</td><td class="source">  out.writeByte(PUT_VERSION);</td></tr><tr class="hit"><td class="line">115</td><td class="hits">19</td><td class="source">  Bytes.writeByteArray(out, this.row);</td></tr><tr class="hit"><td class="line">116</td><td class="hits">19</td><td class="source">  out.writeLong(this.ts);</td></tr><tr class="hit"><td class="line">117</td><td class="hits">19</td><td class="source">  out.writeLong(this.lockId);</td></tr><tr class="hit"><td class="line">118</td><td class="hits">19</td><td class="source">  out.writeBoolean(this.writeToWAL);</td></tr><tr class="hit"><td class="line">119</td><td class="hits">19</td><td class="source">  out.writeInt(Object.keys(this.familyMap).length);</td></tr><tr class="hit"><td class="line">120</td><td class="hits">19</td><td class="source">  for (var family in this.familyMap) {</td></tr><tr class="hit"><td class="line">121</td><td class="hits">19</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(family));</td></tr><tr class="hit"><td class="line">122</td><td class="hits">19</td><td class="source">    var keys = this.familyMap[family];</td></tr><tr class="hit"><td class="line">123</td><td class="hits">19</td><td class="source">    out.writeInt(keys.length);</td></tr><tr class="hit"><td class="line">124</td><td class="hits">19</td><td class="source">    var totalLen = 0;</td></tr><tr class="hit"><td class="line">125</td><td class="hits">19</td><td class="source">    var j, kv;</td></tr><tr class="hit"><td class="line">126</td><td class="hits">19</td><td class="source">    for (j = 0; j &lt; keys.length; j++) {</td></tr><tr class="hit"><td class="line">127</td><td class="hits">38</td><td class="source">      kv = keys[j];</td></tr><tr class="hit"><td class="line">128</td><td class="hits">38</td><td class="source">      totalLen += kv.getLength();</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">130</td><td class="hits">19</td><td class="source">    out.writeInt(totalLen);</td></tr><tr class="hit"><td class="line">131</td><td class="hits">19</td><td class="source">    for (j = 0; j &lt; keys.length; j++) {</td></tr><tr class="hit"><td class="line">132</td><td class="hits">38</td><td class="source">      kv = keys[j];</td></tr><tr class="hit"><td class="line">133</td><td class="hits">38</td><td class="source">      out.writeInt(kv.getLength());</td></tr><tr class="hit"><td class="line">134</td><td class="hits">38</td><td class="source">      out.write(kv.getBuffer(), kv.getOffset(), kv.getLength());</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">137</td><td class="hits">19</td><td class="source">  this.writeAttributes(out);</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">141</td><td class="hits">1</td><td class="source">module.exports = Put;</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/result.js">/Users/mk2/git/node-hbase-client/lib/result.js</h2><div id="stats" class="high"><div class="percentage">90%</div><div class="sloc">108</div><div class="hits">98</div><div class="misses">10</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/result.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var HbaseObjectWritable = require('./io/hbase_object_writable');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var KeyValue = require('./keyvalue');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var errors = require('./errors');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var RESULT_VERSION = 1;</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">function Result(bytes) {</td></tr><tr class="hit"><td class="line">20</td><td class="hits">409</td><td class="source">  if (!(this instanceof Result)) {</td></tr><tr class="hit"><td class="line">21</td><td class="hits">97</td><td class="source">    return new Result();</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">23</td><td class="hits">312</td><td class="source">  this.kvs = null;</td></tr><tr class="hit"><td class="line">24</td><td class="hits">312</td><td class="source">  this.familyMap = null;</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  // We're not using java serialization.  Transient here is just a marker to say</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  // that this is where we cache row if we're ever asked for it.</td></tr><tr class="hit"><td class="line">27</td><td class="hits">312</td><td class="source">  this.row = null;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">312</td><td class="source">  this.bytes = bytes || null;</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">31</td><td class="hits">1</td><td class="source">Result.prototype.readFields = function (io) {</td></tr><tr class="hit"><td class="line">32</td><td class="hits">102</td><td class="source">  this.familyMap = null;</td></tr><tr class="hit"><td class="line">33</td><td class="hits">102</td><td class="source">  this.row = null;</td></tr><tr class="hit"><td class="line">34</td><td class="hits">102</td><td class="source">  this.kvs = null;</td></tr><tr class="hit"><td class="line">35</td><td class="hits">102</td><td class="source">  var totalBuffer = io.readInt();</td></tr><tr class="hit"><td class="line">36</td><td class="hits">102</td><td class="source">  if (totalBuffer === 0) {</td></tr><tr class="hit"><td class="line">37</td><td class="hits">13</td><td class="source">    this.bytes = null;</td></tr><tr class="hit"><td class="line">38</td><td class="hits">13</td><td class="source">    return;</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">40</td><td class="hits">89</td><td class="source">  var raw = io.read(totalBuffer);</td></tr><tr class="hit"><td class="line">41</td><td class="hits">89</td><td class="source">  this.bytes = raw;</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">44</td><td class="hits">1</td><td class="source">Result.prototype._readFields = function () {</td></tr><tr class="hit"><td class="line">45</td><td class="hits">311</td><td class="source">  if (this.bytes === null) {</td></tr><tr class="hit"><td class="line">46</td><td class="hits">13</td><td class="source">    this.kvs = [];</td></tr><tr class="hit"><td class="line">47</td><td class="hits">13</td><td class="source">    return;</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">49</td><td class="hits">298</td><td class="source">  var buf = this.bytes;</td></tr><tr class="hit"><td class="line">50</td><td class="hits">298</td><td class="source">  var offset = 0;</td></tr><tr class="hit"><td class="line">51</td><td class="hits">298</td><td class="source">  var finalOffset = buf.length;</td></tr><tr class="hit"><td class="line">52</td><td class="hits">298</td><td class="source">  var kvs = [];</td></tr><tr class="hit"><td class="line">53</td><td class="hits">298</td><td class="source">  while (offset &lt; finalOffset) {</td></tr><tr class="hit"><td class="line">54</td><td class="hits">935</td><td class="source">    var keyLength = Bytes.toInt(buf, offset);</td></tr><tr class="hit"><td class="line">55</td><td class="hits">935</td><td class="source">    offset += Bytes.SIZEOF_INT;</td></tr><tr class="hit"><td class="line">56</td><td class="hits">935</td><td class="source">    kvs.push(new KeyValue(buf, offset, keyLength));</td></tr><tr class="hit"><td class="line">57</td><td class="hits">935</td><td class="source">    offset += keyLength;</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">59</td><td class="hits">298</td><td class="source">  this.kvs = kvs;</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">Result.prototype.raw = function () {</td></tr><tr class="hit"><td class="line">63</td><td class="hits">583</td><td class="source">  if (this.kvs === null) {</td></tr><tr class="hit"><td class="line">64</td><td class="hits">311</td><td class="source">    this._readFields();</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">66</td><td class="hits">583</td><td class="source">  return this.kvs;</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">69</td><td class="hits">1</td><td class="source">Result.prototype.size = function () {</td></tr><tr class="hit"><td class="line">70</td><td class="hits">5</td><td class="source">  return this.raw().length;</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> * Get the latest version of the specified column.</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> * @param qualifier column qualifier</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> * @return value of latest version of column, null if none found</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">79</td><td class="hits">1</td><td class="source">Result.prototype.getValue = function (family, qualifier) {</td></tr><tr class="hit"><td class="line">80</td><td class="hits">534</td><td class="source">  var kv = this.getColumnLatest(family, qualifier);</td></tr><tr class="hit"><td class="line">81</td><td class="hits">534</td><td class="source">  if (kv === null) {</td></tr><tr class="miss"><td class="line">82</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">84</td><td class="hits">534</td><td class="source">  return kv.getValue();</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * Return the KeyValues for the specific column.  The KeyValues are sorted in</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * the {@link KeyValue#COMPARATOR} order.  That implies the first entry in</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> * the list is the most recent column.  If the query (Scan or Get) only</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> * requested 1 version the list will contain at most 1 entry.  If the column</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> * did not exist in the result set (either the column does not exist</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> * or the column was not selected in the query) the list will be empty.</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> * Also see getColumnLatest which returns just a KeyValue</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> * @param {byte[]} family the family</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> * @param {byte[]} qualifier</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * @return a list of KeyValues for this column or empty list if the column</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * did not exist in the result set</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">102</td><td class="hits">1</td><td class="source">Result.prototype.getColumn = function (family, qualifier) {</td></tr><tr class="hit"><td class="line">103</td><td class="hits">2</td><td class="source">  if (family !== null &amp;&amp; !Buffer.isBuffer(family)) {</td></tr><tr class="hit"><td class="line">104</td><td class="hits">2</td><td class="source">    family = Bytes.toBytes(family);</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">106</td><td class="hits">2</td><td class="source">  if (qualifier !== null &amp;&amp; !Buffer.isBuffer(qualifier)) {</td></tr><tr class="hit"><td class="line">107</td><td class="hits">2</td><td class="source">    qualifier = Bytes.toBytes(qualifier);</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">109</td><td class="hits">2</td><td class="source">  var result = [];</td></tr><tr class="hit"><td class="line">110</td><td class="hits">2</td><td class="source">  var kvs = this.raw();</td></tr><tr class="hit"><td class="line">111</td><td class="hits">2</td><td class="source">  if (kvs == null || kvs.length == 0) {</td></tr><tr class="miss"><td class="line">112</td><td class="hits">0</td><td class="source">    return result;</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">114</td><td class="hits">2</td><td class="source">  for (var i = 0; i &lt; kvs.length; i++) {</td></tr><tr class="hit"><td class="line">115</td><td class="hits">7</td><td class="source">    var kv = kvs[i];</td></tr><tr class="hit"><td class="line">116</td><td class="hits">7</td><td class="source">    if (!Bytes.equals(kv.getFamily(), family)) {</td></tr><tr class="miss"><td class="line">117</td><td class="hits">0</td><td class="source">      continue;</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">119</td><td class="hits">7</td><td class="source">    if (!Bytes.equals(kv.getQualifier(), qualifier)) {</td></tr><tr class="hit"><td class="line">120</td><td class="hits">4</td><td class="source">      continue;</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">122</td><td class="hits">3</td><td class="source">    result.push(kv);</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">124</td><td class="hits">2</td><td class="source">  return result;</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source"> * The KeyValue for the most recent for a given column. If the column does</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> * not exist in the result set - if it wasn't selected in the query (Get/Scan)</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> * or just does not exist in the row the return value is null.</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> * @param family</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> * @param qualifier</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> * @return KeyValue for the column or null</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">136</td><td class="hits">1</td><td class="source">Result.prototype.getColumnLatest = function (family, qualifier) {</td></tr><tr class="hit"><td class="line">137</td><td class="hits">534</td><td class="source">  var kvs = this.raw(); // side effect possibly.</td></tr><tr class="hit"><td class="line">138</td><td class="hits">534</td><td class="source">  if (kvs === null || kvs.length === 0) {</td></tr><tr class="miss"><td class="line">139</td><td class="hits">0</td><td class="source">    return null;</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">141</td><td class="hits">534</td><td class="source">  for (var i = 0; i &lt; kvs.length; i++) {</td></tr><tr class="hit"><td class="line">142</td><td class="hits">801</td><td class="source">    var kv = kvs[i];</td></tr><tr class="hit"><td class="line">143</td><td class="hits">801</td><td class="source">    if (!Bytes.equals(kv.getFamily(), family)) {</td></tr><tr class="miss"><td class="line">144</td><td class="hits">0</td><td class="source">      continue;</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">146</td><td class="hits">801</td><td class="source">    if (!Bytes.equals(kv.getQualifier(), qualifier)) {</td></tr><tr class="hit"><td class="line">147</td><td class="hits">267</td><td class="source">      continue;</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">149</td><td class="hits">534</td><td class="source">    return kv;</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">  // var pos = this.binarySearch(kvs, family, qualifier);</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source">  // if (pos === -1) {</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source">  //   return null;</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">  // var kv = kvs[pos];</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source">  // if (kv.matchingColumn(family, qualifier)) {</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source">  //   return kv;</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">  // }</td></tr><tr class="miss"><td class="line">159</td><td class="hits">0</td><td class="source">  return null;</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">162</td><td class="hits">1</td><td class="source">Result.readArray = function (io) {</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">  // Read version for array form.</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">  // This assumes that results are sent to the client as Result[], so we</td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">  // have an opportunity to handle version differences without affecting</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source">  // efficiency.</td></tr><tr class="hit"><td class="line">167</td><td class="hits">21</td><td class="source">  var version = io.readByte();</td></tr><tr class="hit"><td class="line">168</td><td class="hits">21</td><td class="source">  if (version &gt; RESULT_VERSION) {</td></tr><tr class="miss"><td class="line">169</td><td class="hits">0</td><td class="source">    throw new errors.IOException(&quot;version not supported&quot;);</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">171</td><td class="hits">21</td><td class="source">  var numResults = io.readInt();</td></tr><tr class="hit"><td class="line">172</td><td class="hits">21</td><td class="source">  if (numResults === 0) {</td></tr><tr class="miss"><td class="line">173</td><td class="hits">0</td><td class="source">    return [];</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">175</td><td class="hits">21</td><td class="source">  var results = [];</td></tr><tr class="hit"><td class="line">176</td><td class="hits">21</td><td class="source">  var bufSize = io.readInt();</td></tr><tr class="hit"><td class="line">177</td><td class="hits">21</td><td class="source">  var buf = new Buffer(bufSize);</td></tr><tr class="hit"><td class="line">178</td><td class="hits">21</td><td class="source">  var offset = 0;</td></tr><tr class="hit"><td class="line">179</td><td class="hits">21</td><td class="source">  for (var i = 0; i &lt; numResults; i++) {</td></tr><tr class="hit"><td class="line">180</td><td class="hits">210</td><td class="source">    var numKeys = io.readInt();</td></tr><tr class="hit"><td class="line">181</td><td class="hits">210</td><td class="source">    offset += Bytes.SIZEOF_INT;</td></tr><tr class="hit"><td class="line">182</td><td class="hits">210</td><td class="source">    if (numKeys === 0) {</td></tr><tr class="miss"><td class="line">183</td><td class="hits">0</td><td class="source">      results[i] = null;</td></tr><tr class="miss"><td class="line">184</td><td class="hits">0</td><td class="source">      continue;</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">186</td><td class="hits">210</td><td class="source">    var initialOffset = offset;</td></tr><tr class="hit"><td class="line">187</td><td class="hits">210</td><td class="source">    for (var j = 0; j &lt; numKeys; j++) {</td></tr><tr class="hit"><td class="line">188</td><td class="hits">630</td><td class="source">      var keyLen = io.readInt();</td></tr><tr class="hit"><td class="line">189</td><td class="hits">630</td><td class="source">      Bytes.putInt(buf, offset, keyLen);</td></tr><tr class="hit"><td class="line">190</td><td class="hits">630</td><td class="source">      offset += Bytes.SIZEOF_INT;</td></tr><tr class="hit"><td class="line">191</td><td class="hits">630</td><td class="source">      var bytes = io.read(keyLen);</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source">      // console.log(keyLen, bytes)</td></tr><tr class="hit"><td class="line">193</td><td class="hits">630</td><td class="source">      Bytes.putBytes(buf, offset, bytes);</td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">      // io.readFully(buf, offset, keyLen);</td></tr><tr class="hit"><td class="line">195</td><td class="hits">630</td><td class="source">      offset += keyLen;</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">197</td><td class="hits">210</td><td class="source">    var totalLength = offset - initialOffset;</td></tr><tr class="hit"><td class="line">198</td><td class="hits">210</td><td class="source">    results[i] = new Result(buf.slice(initialOffset, initialOffset + totalLength));</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">200</td><td class="hits">21</td><td class="source">  return results;</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">202</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">203</td><td class="hits">1</td><td class="source">Result.prototype.list = Result.prototype.raw;</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">206</td><td class="hits">1</td><td class="source">HbaseObjectWritable.addToClass('Result.class', Result);</td></tr><tr class="hit"><td class="line">207</td><td class="hits">1</td><td class="source">module.exports = Result;</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/scan.js">/Users/mk2/git/node-hbase-client/lib/scan.js</h2><div id="stats" class="high"><div class="percentage">76%</div><div class="sloc">68</div><div class="hits">52</div><div class="misses">16</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/scan.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var OperationWithAttributes = require('./operation_with_attributes');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var HConstants = require('./hconstants');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var TimeRange = require('./time_range');</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var RAW_ATTR = &quot;_raw_&quot;;</td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">var ISOLATION_LEVEL = &quot;_isolationlevel_&quot;;</td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var SCAN_VERSION = 3;</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">// If application wants to collect scan metrics, it needs to</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">// call scan.setAttribute(SCAN_ATTRIBUTES_ENABLE, Bytes.toBytes(Boolean.TRUE))</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">var SCAN_ATTRIBUTES_METRICS_ENABLE = &quot;scan.attributes.metrics.enable&quot;;</td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">var SCAN_ATTRIBUTES_METRICS_DATA = &quot;scan.attributes.metrics.data&quot;;</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> * Used to perform Scan operations.</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> * All operations are identical to {@link Get} with the exception of</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> * instantiation.  Rather than specifying a single row, an optional startRow</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> * and stopRow may be defined.  If rows are not specified, the Scanner will</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> * iterate over all rows.</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> * To scan everything for each row, instantiate a Scan object.</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> * To modify scanner caching for just this scan, use {@link #setCaching(int) setCaching}.</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> * If caching is NOT set, we will use the caching value of the hosting {@link HTable}.  See</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> * {@link HTable#setScannerCaching(int)}. In addition to row caching, it is possible to specify a</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> * maximum result size, using {@link #setMaxResultSize(long)}. When both are used,</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> * single server requests are limited by either number of rows or maximum result size, whichever</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> * limit comes first.</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> * To further define the scope of what to get when scanning, perform additional</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> * methods as outlined below.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> * To get all columns from specific families, execute {@link #addFamily(byte[]) addFamily}</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> * for each family to retrieve.</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> * To get specific columns, execute {@link #addColumn(byte[], byte[]) addColumn}</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> * for each column to retrieve.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> * To only retrieve columns within a specific range of version timestamps,</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> * execute {@link #setTimeRange(long, long) setTimeRange}.</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> * To only retrieve columns with a specific timestamp, execute</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> * {@link #setTimeStamp(long) setTimestamp}.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> * To limit the number of versions of each column to be returned, execute</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> * {@link #setMaxVersions(int) setMaxVersions}.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> * To limit the maximum number of values returned for each call to next(),</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> * execute {@link #setBatch(int) setBatch}.</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * To add a filter, execute {@link #setFilter(org.apache.hadoop.hbase.filter.Filter) setFilter}.</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * Expert: To explicitly disable server-side block caching for this scan,</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * execute {@link #setCacheBlocks(boolean)}.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">70</td><td class="hits">1</td><td class="source">function Scan(startRow, stopRow) {</td></tr><tr class="hit"><td class="line">71</td><td class="hits">14</td><td class="source">  OperationWithAttributes.call(this);</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">73</td><td class="hits">14</td><td class="source">  this.startRow = startRow || HConstants.EMPTY_START_ROW;</td></tr><tr class="hit"><td class="line">74</td><td class="hits">14</td><td class="source">  this.stopRow = stopRow || HConstants.EMPTY_END_ROW;</td></tr><tr class="hit"><td class="line">75</td><td class="hits">14</td><td class="source">  this.maxVersions = 1;</td></tr><tr class="hit"><td class="line">76</td><td class="hits">14</td><td class="source">  this.batch = -1;</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  /*</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">   * -1 means no caching</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">   */</td></tr><tr class="hit"><td class="line">81</td><td class="hits">14</td><td class="source">  this.caching = -1;</td></tr><tr class="hit"><td class="line">82</td><td class="hits">14</td><td class="source">  this.maxResultSize = -1;</td></tr><tr class="hit"><td class="line">83</td><td class="hits">14</td><td class="source">  this.cacheBlocks = true;</td></tr><tr class="hit"><td class="line">84</td><td class="hits">14</td><td class="source">  this.filter = null;</td></tr><tr class="hit"><td class="line">85</td><td class="hits">14</td><td class="source">  this.tr = new TimeRange();</td></tr><tr class="hit"><td class="line">86</td><td class="hits">14</td><td class="source">  this.familyMap = {};</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">89</td><td class="hits">1</td><td class="source">util.inherits(Scan, OperationWithAttributes);</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">Scan.prototype.getRow = function () {</td></tr><tr class="hit"><td class="line">92</td><td class="hits">12</td><td class="source">  return this.startRow;</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> * Get all columns from the specified family.</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> * Overrides previous calls to addColumn for this family.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * @return this</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">102</td><td class="hits">1</td><td class="source">Scan.prototype.addFamily = function (family) {</td></tr><tr class="hit"><td class="line">103</td><td class="hits">14</td><td class="source">  this.familyMap[family] = null;</td></tr><tr class="hit"><td class="line">104</td><td class="hits">14</td><td class="source">  return this;</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> * Get the column from the specified family with the specified qualifier.</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source"> * Overrides previous calls to addFamily for this family.</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> * @param family family name</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> * @param qualifier column qualifier</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> * @return this</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">115</td><td class="hits">1</td><td class="source">Scan.prototype.addColumn = function (family, qualifier) {</td></tr><tr class="miss"><td class="line">116</td><td class="hits">0</td><td class="source">  var set = this.familyMap[family];</td></tr><tr class="miss"><td class="line">117</td><td class="hits">0</td><td class="source">  if (!set) {</td></tr><tr class="miss"><td class="line">118</td><td class="hits">0</td><td class="source">    this.familyMap[family] = set = [];</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">120</td><td class="hits">0</td><td class="source">  set.push(qualifier);</td></tr><tr class="miss"><td class="line">121</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source"> * Get versions of columns only within the specified timestamp range,</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> * [minStamp, maxStamp).  Note, default maximum versions to return is 1.  If</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> * your time range spans more than one version and you want all versions</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source"> * returned, up the number of versions beyond the defaut.</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> * @param minStamp minimum timestamp value, inclusive</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> * @param maxStamp maximum timestamp value, exclusive</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> * @throws IOException if invalid time range</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> * @see #setMaxVersions()</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> * @see #setMaxVersions(int)</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> * @return this</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">136</td><td class="hits">1</td><td class="source">Scan.prototype.setTimeRange = function (minStamp, maxStamp) {</td></tr><tr class="miss"><td class="line">137</td><td class="hits">0</td><td class="source">  this.tr = new TimeRange(minStamp, maxStamp);</td></tr><tr class="miss"><td class="line">138</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source"> * Get versions of columns with the specified timestamp. Note, default maximum</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> * versions to return is 1.  If your time range spans more than one version</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> * and you want all versions returned, up the number of versions beyond the</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source"> * defaut.</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> * @param timestamp version timestamp</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> * @see #setMaxVersions()</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source"> * @see #setMaxVersions(int)</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source"> * @return this</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">151</td><td class="hits">1</td><td class="source">Scan.prototype.setTimeStamp = function (timestamp) {</td></tr><tr class="miss"><td class="line">152</td><td class="hits">0</td><td class="source">  this.tr = new TimeRange(timestamp, timestamp + 1);</td></tr><tr class="miss"><td class="line">153</td><td class="hits">0</td><td class="source">  return this;</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">156</td><td class="hits">1</td><td class="source">Scan.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">157</td><td class="hits">14</td><td class="source">  out.writeByte(SCAN_VERSION);</td></tr><tr class="hit"><td class="line">158</td><td class="hits">14</td><td class="source">  Bytes.writeByteArray(out, this.startRow);</td></tr><tr class="hit"><td class="line">159</td><td class="hits">14</td><td class="source">  Bytes.writeByteArray(out, this.stopRow);</td></tr><tr class="hit"><td class="line">160</td><td class="hits">14</td><td class="source">  out.writeInt(this.maxVersions);</td></tr><tr class="hit"><td class="line">161</td><td class="hits">14</td><td class="source">  out.writeInt(this.batch);</td></tr><tr class="hit"><td class="line">162</td><td class="hits">14</td><td class="source">  out.writeInt(this.caching);</td></tr><tr class="hit"><td class="line">163</td><td class="hits">14</td><td class="source">  out.writeBoolean(this.cacheBlocks);</td></tr><tr class="hit"><td class="line">164</td><td class="hits">14</td><td class="source">  if (!this.filter) {</td></tr><tr class="hit"><td class="line">165</td><td class="hits">14</td><td class="source">    out.writeBoolean(false);</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">167</td><td class="hits">0</td><td class="source">    out.writeBoolean(true);</td></tr><tr class="miss"><td class="line">168</td><td class="hits">0</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(this.filter.getClass().getName()));</td></tr><tr class="miss"><td class="line">169</td><td class="hits">0</td><td class="source">    this.filter.write(out);</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">171</td><td class="hits">14</td><td class="source">  this.tr.write(out);</td></tr><tr class="hit"><td class="line">172</td><td class="hits">14</td><td class="source">  out.writeInt(Object.keys(this.familyMap).length);</td></tr><tr class="hit"><td class="line">173</td><td class="hits">14</td><td class="source">  for (var family in this.familyMap) {</td></tr><tr class="hit"><td class="line">174</td><td class="hits">14</td><td class="source">    Bytes.writeByteArray(out, Bytes.toBytes(family));</td></tr><tr class="hit"><td class="line">175</td><td class="hits">14</td><td class="source">    var columnSet = this.familyMap[family];</td></tr><tr class="hit"><td class="line">176</td><td class="hits">14</td><td class="source">    if (columnSet &amp;&amp; columnSet.length &gt; 0) {</td></tr><tr class="miss"><td class="line">177</td><td class="hits">0</td><td class="source">      out.writeInt(columnSet.length);</td></tr><tr class="miss"><td class="line">178</td><td class="hits">0</td><td class="source">      for (var i = 0; i &lt; columnSet.length; i++) {</td></tr><tr class="miss"><td class="line">179</td><td class="hits">0</td><td class="source">        var qualifier = columnSet[i];</td></tr><tr class="miss"><td class="line">180</td><td class="hits">0</td><td class="source">        Bytes.writeByteArray(out, qualifier);</td></tr><tr><td class="line">181</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source">    } else {</td></tr><tr class="hit"><td class="line">183</td><td class="hits">14</td><td class="source">      out.writeInt(0);</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">186</td><td class="hits">14</td><td class="source">  this.writeAttributes(out);</td></tr><tr class="hit"><td class="line">187</td><td class="hits">14</td><td class="source">  out.writeLong(this.maxResultSize);</td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">191</td><td class="hits">1</td><td class="source">module.exports = Scan;</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/scanner.js">/Users/mk2/git/node-hbase-client/lib/scanner.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">13</div><div class="hits">13</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/scanner.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var EventEmitter = require('events').EventEmitter;</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var util = require('util');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">function Scanner(server, id) {</td></tr><tr class="hit"><td class="line">17</td><td class="hits">12</td><td class="source">  EventEmitter.call(this);</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">19</td><td class="hits">12</td><td class="source">  this.server = server;</td></tr><tr class="hit"><td class="line">20</td><td class="hits">12</td><td class="source">  this.id = id;</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">util.inherits(Scanner, EventEmitter);</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">Scanner.prototype.next = function (numberOfRows, callback) {</td></tr><tr class="hit"><td class="line">26</td><td class="hits">53</td><td class="source">  this.server.nextResult(this.id, numberOfRows, callback);</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">29</td><td class="hits">1</td><td class="source">Scanner.prototype.close = function (callback) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">12</td><td class="source">  this.server.closeScanner(this.id, callback);</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">34</td><td class="hits">1</td><td class="source">module.exports = Scanner;</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/text.js">/Users/mk2/git/node-hbase-client/lib/text.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/text.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var WritableUtils = require('./writable_utils');</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">/** Write a UTF8 encoded string to out</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">exports.writeString = function (out, s) {</td></tr><tr class="hit"><td class="line">18</td><td class="hits">56</td><td class="source">  var bytes = new Buffer(s, 'utf8');</td></tr><tr class="hit"><td class="line">19</td><td class="hits">56</td><td class="source">  var length = bytes.length;</td></tr><tr class="hit"><td class="line">20</td><td class="hits">56</td><td class="source">  WritableUtils.writeVInt(out, length);</td></tr><tr class="hit"><td class="line">21</td><td class="hits">56</td><td class="source">  out.write(bytes);</td></tr><tr class="hit"><td class="line">22</td><td class="hits">56</td><td class="source">  return length;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/time_range.js">/Users/mk2/git/node-hbase-client/lib/time_range.js</h2><div id="stats" class="medium"><div class="percentage">73%</div><div class="sloc">30</div><div class="hits">22</div><div class="misses">8</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/time_range.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var Bytes = require('./util/bytes');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> * Represents an interval of version timestamps.</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> * Evaluated according to minStamp &lt;= timestamp &lt; maxStamp</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> * or [minStamp,maxStamp) in interval notation.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> * &lt;p&gt;</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * Only used internally; should not be accessed directly by clients.</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">function TimeRange(minStamp, maxStamp, allTime) {</td></tr><tr class="hit"><td class="line">25</td><td class="hits">87</td><td class="source">  if (Buffer.isBuffer(minStamp)) {</td></tr><tr class="miss"><td class="line">26</td><td class="hits">0</td><td class="source">    minStamp = Bytes.toLong(minStamp);</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">28</td><td class="hits">87</td><td class="source">  if (Buffer.isBuffer(maxStamp)) {</td></tr><tr class="miss"><td class="line">29</td><td class="hits">0</td><td class="source">    maxStamp = Bytes.toLong(maxStamp);</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  </td></tr><tr class="hit"><td class="line">32</td><td class="hits">87</td><td class="source">  this.minStamp = minStamp || 0;</td></tr><tr class="hit"><td class="line">33</td><td class="hits">87</td><td class="source">  this.maxStamp = maxStamp || Long.MAX_VALUE;</td></tr><tr class="hit"><td class="line">34</td><td class="hits">87</td><td class="source">  if (allTime === undefined || allTime === null) {</td></tr><tr class="hit"><td class="line">35</td><td class="hits">75</td><td class="source">    allTime = true;</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">37</td><td class="hits">87</td><td class="source">  this.allTime = allTime;</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">}</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> * Compare the timestamp to timerange</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> * @param timestamp</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> * @return -1 if timestamp is less than timerange,</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> * 0 if timestamp is within timerange,</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source"> * 1 if timestamp is greater than timerange</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">47</td><td class="hits">1</td><td class="source">TimeRange.prototype.compare = function (timestamp) {</td></tr><tr class="miss"><td class="line">48</td><td class="hits">0</td><td class="source">  if (timestamp &lt; this.minStamp) {</td></tr><tr class="miss"><td class="line">49</td><td class="hits">0</td><td class="source">    return -1;</td></tr><tr class="miss"><td class="line">50</td><td class="hits">0</td><td class="source">  } else if (timestamp &gt;= this.maxStamp) {</td></tr><tr class="miss"><td class="line">51</td><td class="hits">0</td><td class="source">    return 1;</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  } else {</td></tr><tr class="miss"><td class="line">53</td><td class="hits">0</td><td class="source">    return 0;</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">57</td><td class="hits">1</td><td class="source">TimeRange.prototype.toString = function () {</td></tr><tr class="miss"><td class="line">58</td><td class="hits">0</td><td class="source">  return &quot;maxStamp=&quot; + this.maxStamp.toString() + &quot;, minStamp=&quot; + this.minStamp.toString();</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">//Writable</td></tr><tr class="hit"><td class="line">62</td><td class="hits">1</td><td class="source">TimeRange.prototype.readFields = function (io) {</td></tr><tr class="hit"><td class="line">63</td><td class="hits">9</td><td class="source">  this.minStamp = io.readLong();</td></tr><tr class="hit"><td class="line">64</td><td class="hits">9</td><td class="source">  this.maxStamp = io.readLong();</td></tr><tr class="hit"><td class="line">65</td><td class="hits">9</td><td class="source">  this.allTime = io.readBoolean();</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">68</td><td class="hits">1</td><td class="source">TimeRange.prototype.write = function (out) {</td></tr><tr class="hit"><td class="line">69</td><td class="hits">69</td><td class="source">  out.writeLong(this.minStamp);</td></tr><tr class="hit"><td class="line">70</td><td class="hits">69</td><td class="source">  out.writeLong(this.maxStamp);</td></tr><tr class="hit"><td class="line">71</td><td class="hits">69</td><td class="source">  out.writeBoolean(this.allTime);</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">75</td><td class="hits">1</td><td class="source">module.exports = TimeRange;</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/util/bytes.js">/Users/mk2/git/node-hbase-client/lib/util/bytes.js</h2><div id="stats" class="high"><div class="percentage">89%</div><div class="sloc">83</div><div class="hits">74</div><div class="misses">9</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/bytes.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">8</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">var utility = require('utility');</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">var WritableUtils = require('../writable_utils');</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">var errors = require('../errors');</td></tr><tr class="hit"><td class="line">18</td><td class="hits">1</td><td class="source">var IllegalArgumentException = errors.IllegalArgumentException;</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">var NegativeArraySizeException = errors.NegativeArraySizeException;</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">1</td><td class="source">var SIZEOF_BYTE = exports.SIZEOF_BYTE = 1;</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">var SIZEOF_BOOLEAN = exports.SIZEOF_BOOLEAN = 1;</td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">var SIZEOF_CHAR = exports.SIZEOF_CHAR = 2;</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">var SIZEOF_SHORT = exports.SIZEOF_SHORT = 2;</td></tr><tr class="hit"><td class="line">25</td><td class="hits">1</td><td class="source">var SIZEOF_INT = exports.SIZEOF_INT = 4;</td></tr><tr class="hit"><td class="line">26</td><td class="hits">1</td><td class="source">var SIZEOF_DOUBLE = exports.SIZEOF_DOUBLE = 8;</td></tr><tr class="hit"><td class="line">27</td><td class="hits">1</td><td class="source">var SIZEOF_LONG = exports.SIZEOF_LONG = 8;</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> * Write byte-array to out with a vint length prefix.</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> * @param out output stream</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> * @param b array</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> * @param offset offset into array</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> * @param length length past offset</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">36</td><td class="hits">1</td><td class="source">exports.writeByteArray = function (out, b, offset, length) {</td></tr><tr class="hit"><td class="line">37</td><td class="hits">436</td><td class="source">  length = length || (b &amp;&amp; b.length) || 0;</td></tr><tr class="hit"><td class="line">38</td><td class="hits">436</td><td class="source">  offset = offset || 0;</td></tr><tr class="hit"><td class="line">39</td><td class="hits">436</td><td class="source">  WritableUtils.writeVInt(out, length);</td></tr><tr class="hit"><td class="line">40</td><td class="hits">436</td><td class="source">  if (length &gt; 0) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">422</td><td class="source">    out.write(b, offset, length);</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> * Put an int value out to the specified byte array position.</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source"> * @param bytes the byte array</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> * @param offset position in the array</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> * @param val int to write out</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> * @return incremented offset</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> * @throws IllegalArgumentException if the byte array given doesn't have</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> * enough room at the offset specified.</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">54</td><td class="hits">1</td><td class="source">exports.putInt = function (bytes, offset, val) {</td></tr><tr class="hit"><td class="line">55</td><td class="hits">926</td><td class="source">  bytes.writeInt32BE(val, offset);</td></tr><tr class="hit"><td class="line">56</td><td class="hits">926</td><td class="source">  return offset + SIZEOF_INT;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> * Put a short value out to the specified byte array position.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> * @param bytes the byte array</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> * @param offset position in the array</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> * @param val short to write out</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> * @return incremented offset</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> * @throws IllegalArgumentException if the byte array given doesn't have</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> * enough room at the offset specified.</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">68</td><td class="hits">1</td><td class="source">exports.putShort = function (bytes, offset, val) {</td></tr><tr class="hit"><td class="line">69</td><td class="hits">44</td><td class="source">  bytes.writeInt16BE(val, offset);</td></tr><tr class="hit"><td class="line">70</td><td class="hits">44</td><td class="source">  return offset + SIZEOF_SHORT;</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> * Put bytes at the specified byte array position.</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> * @param bytes the byte array</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> * @param offset position in the array</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> * @param srcBytes array to write out</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> * @return incremented offset</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">80</td><td class="hits">1</td><td class="source">exports.putBytes = function (bytes, offset, srcBytes) {</td></tr><tr class="hit"><td class="line">81</td><td class="hits">804</td><td class="source">  srcBytes.copy(bytes, offset);</td></tr><tr class="hit"><td class="line">82</td><td class="hits">804</td><td class="source">  return offset + srcBytes.length;</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> * Write a single byte out to the specified byte array position.</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> * @param bytes the byte array</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * @param offset position in the array</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * @param b byte to write out</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> * @return incremented offset</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">92</td><td class="hits">1</td><td class="source">exports.putByte = function (bytes, offset, b) {</td></tr><tr class="hit"><td class="line">93</td><td class="hits">88</td><td class="source">  bytes[offset] = b;</td></tr><tr class="hit"><td class="line">94</td><td class="hits">88</td><td class="source">  return offset + 1;</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> * Put a long value out to the specified byte array position.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> * @param bytes the byte array</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> * @param offset position in the array</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source"> * @param val long to write out</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> * @return incremented offset</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> * @throws IllegalArgumentException if the byte array given doesn't have</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> * enough room at the offset specified.</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">107</td><td class="hits">1</td><td class="source">exports.putLong = function (bytes, offset, val) {</td></tr><tr class="hit"><td class="line">108</td><td class="hits">44</td><td class="source">  if (!(val instanceof Long)) {</td></tr><tr class="miss"><td class="line">109</td><td class="hits">0</td><td class="source">    val = Long.fromNumber(val);</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">111</td><td class="hits">44</td><td class="source">  bytes.writeInt32BE(val.high, offset);</td></tr><tr class="hit"><td class="line">112</td><td class="hits">44</td><td class="source">  bytes.writeInt32BE(val.low, offset + 4);</td></tr><tr class="hit"><td class="line">113</td><td class="hits">44</td><td class="source">  return offset + SIZEOF_LONG;</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> * Converts a byte array to an int value</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> * @param bytes byte array</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> * @param offset offset into array</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> * @param length length of int (has to be {@link #SIZEOF_INT})</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> * @return the int value</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> * @throws IllegalArgumentException if length is not {@link #SIZEOF_INT} or</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> * if there's not enough room in the array at the offset indicated.</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">125</td><td class="hits">1</td><td class="source">exports.toInt = function (bytes, offset, length) {</td></tr><tr class="hit"><td class="line">126</td><td class="hits">2239</td><td class="source">  return bytes.readInt32BE(offset);</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> * Converts a byte array to a short value</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> * @param bytes byte array</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> * @param offset offset into array</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> * @param length length, has to be {@link #SIZEOF_SHORT}</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source"> * @return the short value</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source"> * @throws IllegalArgumentException if length is not {@link #SIZEOF_SHORT}</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> * or if there's not enough room in the array at the offset indicated.</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">138</td><td class="hits">1</td><td class="source">exports.toShort = function (bytes, offset, length) {</td></tr><tr class="hit"><td class="line">139</td><td class="hits">3389</td><td class="source">  return bytes.readInt16BE(offset);</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> * Converts a string to a UTF-8 byte array.</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> * @param s string</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source"> * @return the byte array</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">147</td><td class="hits">1</td><td class="source">exports.toBytes = function (s) {</td></tr><tr class="hit"><td class="line">148</td><td class="hits">463</td><td class="source">  if (s instanceof Long) {</td></tr><tr class="hit"><td class="line">149</td><td class="hits">1</td><td class="source">    return WritableUtils.toLongBytes(s);</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">151</td><td class="hits">462</td><td class="source">  return new Buffer(s, 'utf8');</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">154</td><td class="hits">1</td><td class="source">exports.toString = function (b) {</td></tr><tr class="hit"><td class="line">155</td><td class="hits">272</td><td class="source">  return b.toString('utf8');</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> * @param left left operand</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source"> * @param right right operand</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source"> * @return True if equal</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">163</td><td class="hits">1</td><td class="source">exports.equals = function (left, right) {</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">  // Could use Arrays.equals?</td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">  //noinspection SimplifiableConditionalExpression</td></tr><tr class="hit"><td class="line">166</td><td class="hits">2272</td><td class="source">  if (left === right) {</td></tr><tr class="hit"><td class="line">167</td><td class="hits">79</td><td class="source">    return true;</td></tr><tr><td class="line">168</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">169</td><td class="hits">2193</td><td class="source">  if (left === null || right === null) {</td></tr><tr class="miss"><td class="line">170</td><td class="hits">0</td><td class="source">    return false;</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">172</td><td class="hits">2193</td><td class="source">  if (left.length !== right.length) {</td></tr><tr class="hit"><td class="line">173</td><td class="hits">616</td><td class="source">    return false;</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">175</td><td class="hits">1577</td><td class="source">  if (left.length === 0) {</td></tr><tr class="miss"><td class="line">176</td><td class="hits">0</td><td class="source">    return true;</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">  // Since we're often comparing adjacent sorted data,</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source">  // it's usual to have equal arrays except for the very last byte</td></tr><tr><td class="line">181</td><td class="hits"></td><td class="source">  // so check that first</td></tr><tr class="hit"><td class="line">182</td><td class="hits">1577</td><td class="source">  if (left[left.length - 1] !== right[right.length - 1]) {</td></tr><tr class="hit"><td class="line">183</td><td class="hits">42</td><td class="source">    return false;</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">186</td><td class="hits">1535</td><td class="source">  for (var i = 0; i &lt; left.length; i++) {</td></tr><tr class="hit"><td class="line">187</td><td class="hits">10608</td><td class="source">    if (left[i] !== right[i]) {</td></tr><tr class="miss"><td class="line">188</td><td class="hits">0</td><td class="source">      return false;</td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">192</td><td class="hits">1535</td><td class="source">  return true;</td></tr><tr><td class="line">193</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source"> * Write a printable representation of a byte array. Non-printable</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source"> * characters are hex escaped in the format \\x%02X, eg:</td></tr><tr><td class="line">198</td><td class="hits"></td><td class="source"> * \x00 \x05 etc</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">200</td><td class="hits"></td><td class="source"> * @param b array to write out</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source"> * @param off offset to start at</td></tr><tr><td class="line">202</td><td class="hits"></td><td class="source"> * @param len length to write</td></tr><tr><td class="line">203</td><td class="hits"></td><td class="source"> * @return string output</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">205</td><td class="hits">1</td><td class="source">exports.toStringBinary = function (b, off, len) {</td></tr><tr class="hit"><td class="line">206</td><td class="hits">393</td><td class="source">  return b.toString('utf8');</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">  // off = off || 0;</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">  // len = len || b.length;</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source">  // var result = '';</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">  // var first = new String(b, off, len, &quot;ISO-8859-1&quot;);</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source">  // for (int i = 0; i &lt; first.length(); ++i) {</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">  //   int ch = first.charAt(i) &amp; 0xFF;</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  //   if ((ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">  //       || &quot; `~!@#$%^&amp;*()-_=+[]{}\\|;:'\&quot;,.&lt;&gt;/?&quot;.indexOf(ch) &gt;= 0) {</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">  //     result.append(first.charAt(i));</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">  //   } else {</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">  //     result.append(String.format(&quot;\\x%02X&quot;, ch));</td></tr><tr><td class="line">218</td><td class="hits"></td><td class="source">  //   }</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source">  // }</td></tr><tr><td class="line">220</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">223</td><td class="hits"></td><td class="source"> * @return 0 if equal, &lt; 0 if left is less than right, etc.</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">225</td><td class="hits">1</td><td class="source">exports.compareTo = function (buffer1, buffer2) {</td></tr><tr class="hit"><td class="line">226</td><td class="hits">4660</td><td class="source">  var length1 = buffer1.length;</td></tr><tr class="hit"><td class="line">227</td><td class="hits">4660</td><td class="source">  var length2 = buffer2.length;</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">  // Short circuit equal case</td></tr><tr class="hit"><td class="line">229</td><td class="hits">4660</td><td class="source">  if (buffer1 === buffer2 &amp;&amp; length1 === length2) {</td></tr><tr class="miss"><td class="line">230</td><td class="hits">0</td><td class="source">    return 0;</td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source">  // Bring WritableComparator code local</td></tr><tr class="hit"><td class="line">233</td><td class="hits">4660</td><td class="source">  for (var i = 0, j = 0; i &lt; length1 &amp;&amp; j &lt; length2; i++, j++) {</td></tr><tr class="hit"><td class="line">234</td><td class="hits">31681</td><td class="source">    var a = buffer1[i];</td></tr><tr class="hit"><td class="line">235</td><td class="hits">31681</td><td class="source">    var b = buffer2[j];</td></tr><tr class="hit"><td class="line">236</td><td class="hits">31681</td><td class="source">    if (a !== b) {</td></tr><tr class="hit"><td class="line">237</td><td class="hits">2873</td><td class="source">      return a - b;</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">240</td><td class="hits">1787</td><td class="source">  return length1 - length2;</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source">/** Compute hash for binary data. */</td></tr><tr class="hit"><td class="line">244</td><td class="hits">1</td><td class="source">exports.hashBytes = function (bytes) {</td></tr><tr class="miss"><td class="line">245</td><td class="hits">0</td><td class="source">  var hash = 1;</td></tr><tr class="miss"><td class="line">246</td><td class="hits">0</td><td class="source">  for (var i = 0; i &lt; bytes.length; i++) {</td></tr><tr class="miss"><td class="line">247</td><td class="hits">0</td><td class="source">    hash = (31 * hash) + bytes[i];</td></tr><tr><td class="line">248</td><td class="hits"></td><td class="source">  }</td></tr><tr class="miss"><td class="line">249</td><td class="hits">0</td><td class="source">  return hash;</td></tr><tr><td class="line">250</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">253</td><td class="hits"></td><td class="source"> * @param b bytes to hash</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source"> * @return A hash of &lt;code&gt;b&lt;/code&gt; as an Integer that can be used as key in</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source"> * Maps.</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">257</td><td class="hits">1</td><td class="source">exports.mapKey = function (bytes) {</td></tr><tr class="hit"><td class="line">258</td><td class="hits">65</td><td class="source">  return utility.md5(bytes);</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">261</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="/Users/mk2/git/node-hbase-client/lib/writable_utils.js">/Users/mk2/git/node-hbase-client/lib/writable_utils.js</h2><div id="stats" class="high"><div class="percentage">95%</div><div class="sloc">66</div><div class="hits">63</div><div class="misses">3</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/*!</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> * node-hbase-client - lib/writable_utils.js</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> * Copyright(c) 2013 fengmk2 &lt;fengmk2@gmail.com&gt;</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> * MIT Licensed</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">7</td><td class="hits">1</td><td class="source">&quot;use strict&quot;;</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source"> * Module dependencies.</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> */</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">var Long = require('long');</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> * Serializes a long to a binary stream with zero-compressed encoding.</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> * For -112 &lt;= i &lt;= 127, only one byte is used with the actual value.</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> * For other values of i, the first byte value indicates whether the</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> * long is positive or negative, and the number of bytes that follow.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> * If the first byte value v is between -113 and -120, the following long</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> * is positive, with number of bytes that follow are -(v+112).</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> * If the first byte value v is between -121 and -128, the following long</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> * is negative, with number of bytes that follow are -(v+120). Bytes are</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> * stored in the high-non-zero-byte-first order.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> * @param stream Binary output stream</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> * @param i Long to be serialized</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">30</td><td class="hits">1</td><td class="source">exports.writeVLong = function (stream, i) {</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  // TODO: support Long</td></tr><tr class="hit"><td class="line">32</td><td class="hits">1009</td><td class="source">  if (i &gt;= -112 &amp;&amp; i &lt;= 127) {</td></tr><tr class="hit"><td class="line">33</td><td class="hits">986</td><td class="source">    stream.writeByte(i);</td></tr><tr class="hit"><td class="line">34</td><td class="hits">986</td><td class="source">    return;</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">37</td><td class="hits">23</td><td class="source">  var len = -112;</td></tr><tr class="hit"><td class="line">38</td><td class="hits">23</td><td class="source">  if (i &lt; 0) {</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">    // i ^= -1L; // take one's complement'</td></tr><tr class="hit"><td class="line">40</td><td class="hits">10</td><td class="source">    i ^= -1; // take one's complement'</td></tr><tr class="hit"><td class="line">41</td><td class="hits">10</td><td class="source">    len = -120;</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">44</td><td class="hits">23</td><td class="source">  var tmp = i;</td></tr><tr class="hit"><td class="line">45</td><td class="hits">23</td><td class="source">  while (tmp !== 0) {</td></tr><tr class="hit"><td class="line">46</td><td class="hits">63</td><td class="source">    tmp = tmp &gt;&gt; 8;</td></tr><tr class="hit"><td class="line">47</td><td class="hits">63</td><td class="source">    len--;</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  // stream.writeByte(len);</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">52</td><td class="hits">23</td><td class="source">  var left = (len &lt; -120) ? -(len + 120) : -(len + 112);</td></tr><tr class="hit"><td class="line">53</td><td class="hits">23</td><td class="source">  var buf = new Buffer(left + 1);</td></tr><tr class="hit"><td class="line">54</td><td class="hits">23</td><td class="source">  buf[0] = len;</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">56</td><td class="hits">23</td><td class="source">  for (var idx = left, bi = 1; idx !== 0; idx--, bi++) {</td></tr><tr class="hit"><td class="line">57</td><td class="hits">63</td><td class="source">    var shiftbits = (idx - 1) * 8;</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">    // var mask = 0xFFL &lt;&lt; shiftbits;</td></tr><tr class="hit"><td class="line">59</td><td class="hits">63</td><td class="source">    var mask = 0xFF &lt;&lt; shiftbits;</td></tr><tr class="hit"><td class="line">60</td><td class="hits">63</td><td class="source">    buf[bi] = (i &amp; mask) &gt;&gt; shiftbits;</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">63</td><td class="hits">23</td><td class="source">  stream.writeBytes(buf);</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> * Serializes an integer to a binary stream with zero-compressed encoding.</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> * For -120 &lt;= i &lt;= 127, only one byte is used with the actual value.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> * For other values of i, the first byte value indicates whether the</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> * integer is positive or negative, and the number of bytes that follow.</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> * If the first byte value v is between -121 and -124, the following integer</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source"> * is positive, with number of bytes that follow are -(v+120).</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source"> * If the first byte value v is between -125 and -128, the following integer</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> * is negative, with number of bytes that follow are -(v+124). Bytes are</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> * stored in the high-non-zero-byte-first order.</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> *</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> * @param stream Binary output stream</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> * @param i Integer to be serialized</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> * @throws java.io.IOException </td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">81</td><td class="hits">1</td><td class="source">exports.writeVInt = function (stream, i) {</td></tr><tr class="hit"><td class="line">82</td><td class="hits">968</td><td class="source">  exports.writeVLong(stream, i);</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> * Reads a zero-compressed encoded long from input stream and returns it.</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> * @param stream Binary input stream</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> * @throws java.io.IOException </td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> * @return deserialized long from stream.</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1</td><td class="source">exports.readVLong = function (stream, callback) {</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">  // TODO: support Long</td></tr><tr class="hit"><td class="line">93</td><td class="hits">41</td><td class="source">  stream.readFields([{name: 'firstByte', method: 'readByte'}], function (err, data) {</td></tr><tr class="hit"><td class="line">94</td><td class="hits">41</td><td class="source">    if (err) {</td></tr><tr class="miss"><td class="line">95</td><td class="hits">0</td><td class="source">      return callback(err);</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">97</td><td class="hits">41</td><td class="source">    var firstByte = data.firstByte;</td></tr><tr class="hit"><td class="line">98</td><td class="hits">41</td><td class="source">    var len = exports.decodeVIntSize(firstByte);</td></tr><tr class="hit"><td class="line">99</td><td class="hits">41</td><td class="source">    if (len === 1) {</td></tr><tr class="hit"><td class="line">100</td><td class="hits">18</td><td class="source">      return callback(null, firstByte);</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">102</td><td class="hits">23</td><td class="source">    var size = len - 1;</td></tr><tr class="hit"><td class="line">103</td><td class="hits">23</td><td class="source">    stream.readFully(size, function (err, buf) {</td></tr><tr class="hit"><td class="line">104</td><td class="hits">23</td><td class="source">      if (err) {</td></tr><tr class="miss"><td class="line">105</td><td class="hits">0</td><td class="source">        return callback(err);</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">107</td><td class="hits">23</td><td class="source">      var i = 0;</td></tr><tr class="hit"><td class="line">108</td><td class="hits">23</td><td class="source">      for (var idx = 0; idx &lt; size; idx++) {</td></tr><tr class="hit"><td class="line">109</td><td class="hits">63</td><td class="source">        var b = buf[idx];</td></tr><tr class="hit"><td class="line">110</td><td class="hits">63</td><td class="source">        i = i &lt;&lt; 8;</td></tr><tr class="hit"><td class="line">111</td><td class="hits">63</td><td class="source">        i = i | (b &amp; 0xFF);</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">113</td><td class="hits">23</td><td class="source">      callback(null, exports.isNegativeVInt(firstByte) ? (i ^ -1) : i);</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">    });</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> * Reads a zero-compressed encoded integer from input stream and returns it.</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source"> * @param stream Binary input stream</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source"> * @throws java.io.IOException </td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> * @return deserialized integer from stream.</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">124</td><td class="hits">1</td><td class="source">exports.readVInt = function (stream, callback) {</td></tr><tr class="miss"><td class="line">125</td><td class="hits">0</td><td class="source">  exports.readVLong(stream, callback);</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> * Given the first byte of a vint/vlong, determine the sign</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> * @param value the first byte</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source"> * @return is the value negative</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">133</td><td class="hits">1</td><td class="source">exports.isNegativeVInt = function (value) {</td></tr><tr class="hit"><td class="line">134</td><td class="hits">23</td><td class="source">  return value &lt; -120 || (value &gt;= -112 &amp;&amp; value &lt; 0);</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> * Parse the first byte of a vint/vlong to determine the number of bytes</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source"> * @param value the first byte of the vint/vlong</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source"> * @return the total number of bytes (1 to 9)</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">142</td><td class="hits">1</td><td class="source">exports.decodeVIntSize = function (value) {</td></tr><tr class="hit"><td class="line">143</td><td class="hits">41</td><td class="source">  if (value &gt;= -112) {</td></tr><tr class="hit"><td class="line">144</td><td class="hits">18</td><td class="source">    return 1;</td></tr><tr class="hit"><td class="line">145</td><td class="hits">23</td><td class="source">  } else if (value &lt; -120) {</td></tr><tr class="hit"><td class="line">146</td><td class="hits">10</td><td class="source">    return -119 - value;</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">148</td><td class="hits">13</td><td class="source">  return -111 - value;</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source"> * Convert v to Long.</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> * </td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source"> * @param {Number|String} v</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source"> * @return {Long}</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source"> */</td></tr><tr class="hit"><td class="line">157</td><td class="hits">1</td><td class="source">exports.toLong = function (v) {</td></tr><tr class="hit"><td class="line">158</td><td class="hits">849</td><td class="source">  if (v instanceof Long) {</td></tr><tr class="hit"><td class="line">159</td><td class="hits">196</td><td class="source">    return v;</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">161</td><td class="hits">653</td><td class="source">  if (Buffer.isBuffer(v)) {</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source">    // buffer must be 8 bytes</td></tr><tr class="hit"><td class="line">163</td><td class="hits">332</td><td class="source">    return Long.fromBits(v.readInt32BE(4), v.readInt32BE(0));</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">165</td><td class="hits">321</td><td class="source">  if (typeof v === 'string') {</td></tr><tr class="hit"><td class="line">166</td><td class="hits">3</td><td class="source">    return Long.fromString(v);</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source">  }</td></tr><tr class="hit"><td class="line">168</td><td class="hits">318</td><td class="source">  return Long.fromNumber(v);</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">171</td><td class="hits">1</td><td class="source">exports.toLongBytes = function (v) {</td></tr><tr class="hit"><td class="line">172</td><td class="hits">517</td><td class="source">  var buf = new Buffer(8);</td></tr><tr class="hit"><td class="line">173</td><td class="hits">517</td><td class="source">  var longV = exports.toLong(v);</td></tr><tr class="hit"><td class="line">174</td><td class="hits">517</td><td class="source">  buf.writeInt32BE(longV.high, 0);</td></tr><tr class="hit"><td class="line">175</td><td class="hits">517</td><td class="source">  buf.writeInt32BE(longV.low, 4);</td></tr><tr class="hit"><td class="line">176</td><td class="hits">517</td><td class="source">  return buf;</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div></div></div></body></html>